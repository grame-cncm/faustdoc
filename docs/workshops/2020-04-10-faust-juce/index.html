<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <title> 2020-04-10 Faust & JUCE  - Faust Documentation
    </title>
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="/css/quickref.css" rel="stylesheet">
    <link href="/css/github.min.css" rel="stylesheet">
    <link href="/rail/railroad-diagrams.css" rel="stylesheet">
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <script src="../../js/bootstrap.min.js" defer></script>
    <script src="../../js/MathJax-2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"defer></script>
    <script src="../../js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="../.."><img
                    src="../../img/faustText.svg" width="150px"> </a>
            <!-- Expander button -->
            <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Expanded navigation -->
            <div id="navbar-collapse" class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li class="navitem">
                        <a href="../.." class="nav-link">Home</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Manual <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../manual/introduction/" class="dropdown-item">Introduction</a>
</li>
                            
<li>
    <a href="../../manual/overview/" class="dropdown-item">Overview of the Faust Universe</a>
</li>
                            
<li>
    <a href="../../manual/quick-start/" class="dropdown-item">Quick Start</a>
</li>
                            
<li>
    <a href="../../manual/syntax/" class="dropdown-item">Faust Syntax</a>
</li>
                            
<li>
    <a href="../../manual/errors/" class="dropdown-item">Error Messages</a>
</li>
                            
<li>
    <a href="../../manual/compiler/" class="dropdown-item">Using the Compiler</a>
</li>
                            
<li>
    <a href="../../manual/options/" class="dropdown-item">Compiler Options</a>
</li>
                            
<li>
    <a href="../../manual/tools/" class="dropdown-item">faust2[...] Tools</a>
</li>
                            
<li>
    <a href="../../manual/architectures/" class="dropdown-item">Architecture Files</a>
</li>
                            
<li>
    <a href="../../manual/embedding/" class="dropdown-item">Embedding the Compiler</a>
</li>
                            
<li>
    <a href="../../manual/optimizing/" class="dropdown-item">Optimizing the Code</a>
</li>
                            
<li>
    <a href="../../manual/debugging/" class="dropdown-item">Debugging the Code</a>
</li>
                            
<li>
    <a href="../../manual/deploying/" class="dropdown-item">Deploying on the Web</a>
</li>
                            
<li>
    <a href="../../manual/remote/" class="dropdown-item">Remote Compilation</a>
</li>
                            
<li>
    <a href="../../manual/mathdoc/" class="dropdown-item">Mathematical Documentation</a>
</li>
                            
<li>
    <a href="../../manual/osc/" class="dropdown-item">OSC Support</a>
</li>
                            
<li>
    <a href="../../manual/http/" class="dropdown-item">HTTP Support</a>
</li>
                            
<li>
    <a href="../../manual/midi/" class="dropdown-item">MIDI Support</a>
</li>
                            
<li>
    <a href="../../manual/soundfiles/" class="dropdown-item">Soundfiles Support</a>
</li>
                            
<li>
    <a href="../../manual/community/" class="dropdown-item">Community</a>
</li>
                            
<li>
    <a href="../../manual/faq/" class="dropdown-item">Frequently Asked Questions</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Examples <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../examples/ambisonics/" class="dropdown-item"> ambisonics </a>
</li>
                            
<li>
    <a href="../../examples/analysis/" class="dropdown-item"> analysis </a>
</li>
                            
<li>
    <a href="../../examples/bela/" class="dropdown-item"> bela </a>
</li>
                            
<li>
    <a href="../../examples/delayEcho/" class="dropdown-item"> delayEcho </a>
</li>
                            
<li>
    <a href="../../examples/dynamic/" class="dropdown-item"> dynamic </a>
</li>
                            
<li>
    <a href="../../examples/filtering/" class="dropdown-item"> filtering </a>
</li>
                            
<li>
    <a href="../../examples/gameaudio/" class="dropdown-item"> gameaudio </a>
</li>
                            
<li>
    <a href="../../examples/generator/" class="dropdown-item"> generator </a>
</li>
                            
<li>
    <a href="../../examples/misc/" class="dropdown-item"> misc </a>
</li>
                            
<li>
    <a href="../../examples/phasing/" class="dropdown-item"> phasing </a>
</li>
                            
<li>
    <a href="../../examples/physicalModeling/" class="dropdown-item"> physicalModeling </a>
</li>
                            
<li>
    <a href="../../examples/pitchShifting/" class="dropdown-item"> pitchShifting </a>
</li>
                            
<li>
    <a href="../../examples/psychoacoustic/" class="dropdown-item"> psychoacoustic </a>
</li>
                            
<li>
    <a href="../../examples/reverb/" class="dropdown-item"> reverb </a>
</li>
                            
<li>
    <a href="../../examples/SAM/" class="dropdown-item"> SAM </a>
</li>
                            
<li>
    <a href="../../examples/smartKeyboard/" class="dropdown-item"> smartKeyboard </a>
</li>
                            
<li>
    <a href="../../examples/spat/" class="dropdown-item"> spat </a>
</li>
                            
<li>
    <a href="../../rsrc/examples.zip" class="dropdown-item"> Download examples </a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tutorials <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="./" class="dropdown-item">Faust & JUCE</a>
</li>
                            
<li>
    <a href="../../tutorials/teensy/" class="dropdown-item">DSP on the Teensy With Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/esp32/" class="dropdown-item">DSP on the ESP-32 With Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/basic-osc/" class="dropdown-item">Making a Sine Oscillator From Scratch</a>
</li>
                            
<li>
    <a href="../../tutorials/summation/" class="dropdown-item">RMS and Summation in Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/box-api/" class="dropdown-item">Using the box API</a>
</li>
                            
<li>
    <a href="../../tutorials/signal-api/" class="dropdown-item">Using the signal API</a>
</li>
                            
<li>
    <a href="../../tutorials/julia/" class="dropdown-item">Using Faust in Julia</a>
</li>
                            
<li>
    <a href="../../tutorials/cmajor/" class="dropdown-item">Using Faust in Cmajor</a>
</li>
                            
<li>
    <a href="../../tutorials/jsfx/" class="dropdown-item">Using Faust in JSFX</a>
</li>
                            
<li>
    <a href="../../tutorials/rnbo/" class="dropdown-item">Using Faust in RNBO with codebox~</a>
</li>
                            
<li>
    <a href="../../tutorials/debugging/" class="dropdown-item">Advanced debugging with interp-tracer</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Workshops <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../2018-12-01-paw/" class="dropdown-item"> 2018-12-01 PAW </a>
</li>
                            
<li>
    <a href="../2020-03-24-faust-citi/" class="dropdown-item"> 2020-03-24 CITI </a>
</li>
                            
<li>
    <a href="../2020-04-10-faust-101/" class="dropdown-item"> 2020-04-10 Faust 101 </a>
</li>
                            
<li>
    <a href="./" class="dropdown-item active"> 2020-04-10 Faust & JUCE </a>
</li>
                            
<li>
    <a href="../2020-11-21-faust-vcvrack/" class="dropdown-item"> 2020-11-21 Faust & VCV Rack </a>
</li>
                        </ul>
                    </li>
                    <li class="navitem">
                        <a href="../../about/" class="nav-link">About</a>
                    </li>
                </ul>

                <ul class="nav navbar-nav ml-auto">
                    <li class="nav-item">
                        <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fa fa-search"></i> Search
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    

    <div class="container">
        <div class="row"><div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#faust-for-the-confined-adding-faust-dsp-support-to-your-juce-plug-ins" class="nav-link">Faust For the Confined: Adding Faust DSP Support to Your JUCE Plug-ins</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#simple-monophonic-synth-plug-in" class="nav-link">Simple Monophonic Synth Plug-In</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#generating-the-dsp-engine" class="nav-link">Generating the DSP Engine</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#creating-an-empty-juce-plug-in-project" class="nav-link">Creating an Empty JUCE Plug-In Project</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#integrating-the-faust-dsp-object-to-the-juce-project" class="nav-link">Integrating the Faust DSP Object to The JUCE Project</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#simple-audio-effect-plug-in" class="nav-link">Simple Audio Effect Plug-In</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#generating-the-dsp-engine_1" class="nav-link">Generating the DSP Engine</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#creating-a-new-empty-juce-plug-in-project" class="nav-link">Creating a New Empty JUCE Plug-In Project</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#integrating-the-faust-dsp-object-to-the-juce-project_1" class="nav-link">Integrating the Faust DSP Object to The JUCE Project</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#creating-and-using-a-polyphonic-faust-dsp-object" class="nav-link">Creating and Using a Polyphonic Faust DSP Object</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
            <div class="col-md-9 main-container" role="main">

<h1 id="faust-for-the-confined-adding-faust-dsp-support-to-your-juce-plug-ins">Faust For the Confined: Adding Faust DSP Support to Your JUCE Plug-ins</h1>
<p><a href="https:/juce.com/">JUCE</a> is a well-known framework for creating audio plug-ins (i.e., VST, AU, AAX, etc.) and applications for a wide range of platforms. Faust can be used to generate ready-to-use JUCE applications and plug-ins implementing the standard user interface (UI) described in the Faust code using <a href="https://github.com/grame-cncm/faust/tree/master-dev/architecture/juce">faust2juce</a>. However, it is sooo easy to make professional looking UIs from scratch in JUCE that you might want to use Faust to implement the DSP portion of your plug-in and build your own UI.</p>
<p>In this tutorial, we demonstrate how to use the Faust compiler to generate a C++ DSP object and how to interface it with your JUCE plug-in/UI. We'll cover basic examples (monophonic synth, polyphonic synth, and audio effect) as well as more advanced applications involving polyphony, etc.</p>
<h2 id="simple-monophonic-synth-plug-in">Simple Monophonic Synth Plug-In</h2>
<p><a href="misc/mono.zip">&lt;&lt; Download the source of this tutorial &gt;&gt;</a></p>
<p>In this section, we demonstrate how to use a Faust synth to build a plug-in in JUCE with a custom UI from scratch.</p>
<h3 id="generating-the-dsp-engine">Generating the DSP Engine</h3>
<p>First, let's implement a basic subtractive synthesizer in Faust based on a filtered sawtooth wave (<code>FaustSynth.dsp</code>):</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust0/exfaust0.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = nentry("freq",200,50,1000,0.01);
gain = nentry("gain",0.5,0,1,0.01) : si.smoo;
gate = button("gate") : si.smoo;
cutoff = nentry("cutoff",10000,50,10000,0.01) : si.smoo;
process = os.sawtooth(freq)*gain*gate : fi.lowpass(3,cutoff) <: _,_;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Feel free to run it in the web IDE to see how it sounds!</p>
<blockquote>
<p>The output of the lowpass is split into 2 signals to create a stereo object.</p>
</blockquote>
<p>Note that all the parameters are smoothed to prevent clicking (we want our plug-in to be clean!). Even <code>gate</code> is smoothed, which will apply a gentle exponential envelope when the trigger signal is sent, etc.</p>
<p>Since Faust will not build its own UI here, the type of UI element used in this code doesn't really matter. They just serve as a point of entry to control the parameters of the audio engine we're about to generate. So <code>nentry</code> could be replaced by <code>hslider</code> or <code>vslider</code>, it would not make any difference. However, we encourage you to always write "coherent" interfaces in case someone would like to use your Faust code "as such" at some point.</p>
<p>In order to turn this Faust program into a C++ DSP object usable in JUCE, we must use a Faust architecture file that will wrap the C++ code generated by the Faust compiler (that literally just contains an audio callback function). That's what <a href="misc/faustMinimal.h"><code>faustMinimal.h</code></a> (which is part of the package that you downloaded at the beginning of this tutorial) does. Actually, if you open it, you'll see:</p>
<pre><code>#include &lt;cmath&gt;
#include &lt;cstring&gt;

#include &quot;faust/gui/MapUI.h&quot;
#include &quot;faust/gui/meta.h&quot;
#include &quot;faust/dsp/dsp.h&quot;

// BEGIN-FAUSTDSP

&lt;&lt;includeIntrinsic&gt;&gt;

&lt;&lt;includeclass&gt;&gt;

// END-FAUSTDSP
</code></pre>
<p>The <code>faust/...</code> files should be on your system if Faust is installed on it. If not, you can use the inlined version of the architecture file (<a href="misc/faustMinimalInlined.h"><code>faustMinimalInlined.h</code></a>) which can also be found in the package that you downloaded at the beginning of this tutorial.</p>
<p><code>MapUI.h</code> will allow us to easily control the parameters of the Faust object using their declared names in the Faust code. The other includes are necessary in most cases and are just parent classes of the DSP class generated by the Faust compiler. <code>&lt;&lt;includeclass&gt;&gt;</code> is where the code generated by the Faust compiler gets pasted.</p>
<p>This architecture file can be used with the Faust compiler simply by running:</p>
<pre><code>faust -i -a faustMinimal.h FaustSynth.dsp -o FaustSynth.h 
</code></pre>
<p>where <code>FaustSynth.h</code> is the name of the generated file that we will import in our JUCE project later in this tutorial. The <code>-i</code> option inlines the included C++ files in the generated file. </p>
<p>Alternatively, if Faust is not installed on your system, the Faust online IDE can be used to carry out the same task by choosing <code>source/cplusplus</code> in the Export (truck) function. The content of the downloaded C++ file can then be copied and pasted between the <code>BEGIN-FAUSTDSP</code> and <code>END-FAUSTDSP</code> tags.</p>
<p>We're now ready to create a new JUCE plug-in project!</p>
<h3 id="creating-an-empty-juce-plug-in-project">Creating an Empty JUCE Plug-In Project</h3>
<p>In this section, we'll assume that you're a bit familiar with <a href="https://juce.com/">JUCE</a>. If that's not your case, don't panic and just read their <a href="https://docs.juce.com/master/tutorial_new_projucer_project.html">Getting started with the Projucer</a> tutorial. We also recommend you to have a look a the next few following tutorials to have a sense of how things work. They're nice and easy to read!</p>
<p>In the Projucer, create a new Audio Plug-In, add the targets that you want, in the settings, make sure that "Plugin is a Synth" is enabled. In our case, we named it "MonoSynth" (choose this name wisely as it will impact the class names of your program).</p>
<p><img src="img/newPlugin.jpg" class="mx-auto d-block" width="70%"></p>
<p>Now, place the <code>FaustSynth.h</code> file generated in the previous step in the <code>Source</code> folder of your JUCE plug-in project. Then select it in <code>Source</code> in your file browser and drag it to the Projucer so that it becomes visible in the <code>Source</code> tab:</p>
<p><img src="img/juceProject.jpg" class="mx-auto d-block" width="70%"></p>
<p>At this point, try to compile your plug-in and see if it runs. Remember that JUCE now generates a "standalone plug-in" by default which is super convenient to test things without having to open the plug-in in a third party application.</p>
<h3 id="integrating-the-faust-dsp-object-to-the-juce-project">Integrating the Faust DSP Object to The JUCE Project</h3>
<p>Let's now integrate our Faust-generated DSP object to the <code>PluginProcessor</code>. Declare the following elements in the private section of the <code>MonoSynthAudioProcessor</code> class of <code>PluginProcessor.h</code>:</p>
<pre><code>private:
    MapUI* fUI;
    dsp* fDSP;
    float** outputs;
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MonoSynthAudioProcessor)
</code></pre>
<p><code>fUI</code> will be used to control the parameters of the Faust DSP, and <code>fDSP</code> will contain the audio DSP/callback itself (that's basically the object generated by the Faust compiler). In order to declare these objects without knowing the definition of <code>MapUI</code> and <code>dsp</code> you'll also have to declare empty class definitions at the beginning of the file:</p>
<pre><code>class dsp;
class MapUI;

class MonoSynthAudioProcessor : public AudioProcessor
</code></pre>
<p>In <code>PluginProcessor.cpp</code>, include <code>FaustSynth.h</code> at the beginning of the file in the includes section:</p>
<pre><code>#include &quot;PluginProcessor.h&quot;
#include &quot;PluginEditor.h&quot;
#include &quot;FaustSynth.h&quot;
</code></pre>
<p>Write the following in the <code>prepareToPlay</code> method:</p>
<pre><code>void MonoSynthAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    fDSP = new mydsp();
    fDSP-&gt;init(sampleRate);
    fUI = new MapUI();
    fDSP-&gt;buildUserInterface(fUI);
    outputs = new float*[2];
    for (int channel = 0; channel &lt; 2; ++channel) {
        outputs[channel] = new float[samplesPerBlock];
    }
}
</code></pre>
<p>Here, <code>fDSP</code> which is the Faust DSP object is first instantiated. Then <code>fUI</code> which will be used to control the parameters of the DSP is instantiated. These 2 objects are bound together using the <code>buildUserInterface</code> method of <code>fDSP</code>. Finally, memory is allocated for the stereo output of the Faust object. Note that <code>outputs</code> is a double array (one dimension for audio channels and one dimension for audio samples/buffers).</p>
<p>Conversly, write the following in the <code>releaseResources</code> method of <code>MonoSynthAudioProcessor</code>:</p>
<pre><code>void MonoSynthAudioProcessor::releaseResources()
{
    delete fDSP;
    delete fUI;
    for (int channel = 0; channel &lt; 2; ++channel) {
        delete[] outputs[channel];
    }
    delete [] outputs;
}
</code></pre>
<p>Here, we just free the memory allocated in the previous steps when resources are released.</p>
<p>Let's now get into the heart of the matter: the audio callback which is implemented through the <code>processBlock</code> method of <code>MonoSynthAudioProcessor</code>:</p>
<pre><code>void MonoSynthAudioProcessor::processBlock (AudioBuffer&lt;float&gt;&amp; buffer, MidiBuffer&amp; midiMessages)
{
    ScopedNoDenormals noDenormals;
    auto totalNumInputChannels = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();

    fDSP-&gt;compute(buffer.getNumSamples(),NULL,outputs);

    for (int channel = 0; channel &lt; totalNumOutputChannels; ++channel) {
        for (int i = 0; i &lt; buffer.getNumSamples(); i++) {
            *buffer.getWritePointer(channel,i) = outputs[channel][i];
        }
    }
}
</code></pre>
<p>Here, we basically compute one full audio block of size <code>buffer.getNumSamples()</code>, we store it in <code>outputs</code> and we then link <code>outputs</code> to the actual audio output of <code>processBlock</code> (<code>*buffer.getWritePointer(channel,i)</code>).</p>
<p>At this point, you should be able to produce sound with your plug-in! Temporarily add the following line to the <code>prepareToPlay</code> method to set the value of the <code>gate</code> parameter to one:</p>
<pre><code>fUI-&gt;setParamValue(&quot;gate&quot;,1);
</code></pre>
<p>Note how <code>fUI</code> is used here to configure the parameter of the Faust DSP using its <code>setParamValue</code> method which has 2 arguments: the path/name of the parameter in the Faust code, and its value.</p>
<p>Try to compile the plug-in for your desired target (e.g., VST, AU, etc.). In our case we'll juste generate a standalone plug-in for convenience. When running the plug-in, you should now hear sound!</p>
<p>Since we want to control the parameters of our synth from the <code>PluginEditor</code>, we must create a series of public methods in <code>PluginProcessor</code> to control each parameter of our synth. In <code>PluginProcessor.h</code> this will look like:</p>
<pre><code>public:
  void setFreq(float freq);
  void setGain(float gain);
  void setCutoff(float cutoff);
  void setGate(bool gate);
</code></pre>
<p>and the corresponding implementation in <code>PluginProcessor.cpp</code> will be:</p>
<pre><code>void MonoSynthAudioProcessor::setFreq(float freq)
{
    fUI-&gt;setParamValue(&quot;freq&quot;,freq);
}

void MonoSynthAudioProcessor::setGain(float gain)
{
    fUI-&gt;setParamValue(&quot;gain&quot;,gain);
}

void MonoSynthAudioProcessor::setGate(bool gate)
{
    if(gate) {
        fUI-&gt;setParamValue(&quot;gate&quot;,1);
    } else {
        fUI-&gt;setParamValue(&quot;gate&quot;,0);
    }
}

void MonoSynthAudioProcessor::setCutoff(float cutoff)
{
    fUI-&gt;setParamValue(&quot;cutoff&quot;,cutoff);
}
</code></pre>
<p>That's it for the <code>PluginProcessor</code>! Easy isn't it ;)? Now, let's add a basic interface to control this synth.</p>
<p>We add a series of sliders, button, and labels to the private section of <code>MonoSynthAudioProcessorEditor</code> in <code>PluginEditor.h</code>:</p>
<pre><code>private:
  Slider frequencySlider;
  Slider gainSlider;
  Slider cutoffSlider;
  ToggleButton onOffButton;

  Label frequencyLabel;
  Label gainLabel;
  Label cutoffLabel;
  Label onOffLabel;
</code></pre>
<p>and their corresponding implementation in <code>PluginEditor.cpp</code>:</p>
<pre><code>MonoSynthAudioProcessorEditor::MonoSynthAudioProcessorEditor(MonoSynthAudioProcessor&amp; p)
    : AudioProcessorEditor(&amp;p), processor(p)
{
    setSize (800, 130);

    addAndMakeVisible(frequencySlider);
    frequencySlider.setRange(50.0, 5000.0);
    frequencySlider.setSkewFactorFromMidPoint(500.0);
    frequencySlider.setValue(300);
    frequencySlider.onValueChange = [this] {
        processor.setFreq(frequencySlider.getValue());  
    };

    addAndMakeVisible(frequencyLabel);
    frequencyLabel.setText(&quot;Frequency&quot;, dontSendNotification);
    frequencyLabel.attachToComponent(&amp;frequencySlider, true);

    addAndMakeVisible(gainSlider);
    gainSlider.setRange(0.0, 1.0);
    gainSlider.setValue(0.5);
    gainSlider.onValueChange = [this] { 
        processor.setGain(gainSlider.getValue()); 
    };

    addAndMakeVisible(gainLabel);
    gainLabel.setText(&quot;Gain&quot;, dontSendNotification);
    gainLabel.attachToComponent (&amp;gainSlider, true);

    addAndMakeVisible(cutoffSlider);
    cutoffSlider.setRange(50.0, 10000.0);
    cutoffSlider.setValue(5000.0);
    cutoffSlider.onValueChange = [this] { 
        processor.setCutoff(cutoffSlider.getValue()); 
    };

    addAndMakeVisible(cutoffLabel);
    cutoffLabel.setText(&quot;Cutoff&quot;, dontSendNotification);
    cutoffLabel.attachToComponent(&amp;cutoffSlider, true);

    addAndMakeVisible(onOffButton);
    onOffButton.onClick = [this] { 
        processor.setGate(onOffButton.getToggleState());
    };

    addAndMakeVisible(onOffLabel);
    onOffLabel.setText(&quot;On/Off&quot;, dontSendNotification);
    onOffLabel.attachToComponent (&amp;onOffButton, true);
}
</code></pre>
<p>The methods that we declared in the previous step are basically called to set the value of the parameters of our DSP engine thanks to the <code>processor</code> object.</p>
<p>The <code>resized</code> method must be implemented so that the various UI elements that we created actually have a size:</p>
<pre><code>void MonoSynthAudioProcessorEditor::resized()
{
    const int sliderLeft = 80;
    frequencySlider.setBounds(sliderLeft, 10, getWidth() - sliderLeft - 20, 20);
    gainSlider.setBounds(sliderLeft, 40, getWidth() - sliderLeft - 20, 20);
    cutoffSlider.setBounds(sliderLeft, 70, getWidth() - sliderLeft - 20, 20);
    onOffButton.setBounds(sliderLeft, 100, getWidth() - sliderLeft - 20, 20);
}
</code></pre>
<p>Finally, make sure that you clean the implementation of the <code>paint</code> method to get rid of the default ugly "Hello World:"</p>
<pre><code>void MonoSynthAudioProcessorEditor::paint (Graphics&amp; g)
{
    g.fillAll(getLookAndFeel().findColour (ResizableWindow::backgroundColourId));
}
</code></pre>
<p>Compile your plug-in and run it, it should look like this:</p>
<p><img src="img/plugin.jpg" class="mx-auto d-block" width="60%"></p>
<p>The goal of this section was just to show you how to integrate a Faust DSP object into a JUCE plug-in project and how to control it with a simple UI. 
Once again, JUCE is a powerful tool to implement sophisticated UI in a very simple way. You'll find all the documentation you need on their website](https://juce.com/) to start making beautiful plug-ins!</p>
<h2 id="simple-audio-effect-plug-in">Simple Audio Effect Plug-In</h2>
<p><a href="misc/effect.zip">&lt;&lt; Download the source of this tutorial &gt;&gt;</a></p>
<p>In this section, we demonstrate how to use a Faust effect to build a plug-in in JUCE with a custom UI from scratch.</p>
<h3 id="generating-the-dsp-engine_1">Generating the DSP Engine</h3>
<p>The steps for generating an audio effect C++ DSP object with Faust are exactly the same as for a synth (<a href="#simple-monophonic-synth-plug-in">see the previous section</a>) and the <a href="misc/faustMinimal.h"><code>faustMinimal.h</code></a> architecture file can be used as well.</p>
<p>For this example, we'll be using a stereo echo:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust1/exfaust1.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
echo(d,f) = +~de.delay(48000,del)*f
with {
  del = d*ma.SR;
};
delay = nentry("delay",0.25,0,1,0.01) : si.smoo;
feedback = nentry("feedback",0.5,0,1,0.01) : si.smoo;
process = par(i,2,echo(delay,feedback));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Then run something like:</p>
<pre><code>faust -i -a faustMinimal.h FaustEffect.dsp -o Effect/Source/FaustEffect.h 
</code></pre>
<h3 id="creating-a-new-empty-juce-plug-in-project">Creating a New Empty JUCE Plug-In Project</h3>
<p>The steps are the same as for the <a href="#simple-monophonic-synth-plug-in">mono synthesizer tutorial</a> except that the "Plug-in is a Synth" checkbox shouldn't be checked this time. For this example, we decided to give a very bad and explicit name to our plug-in project: "Effect.""</p>
<p>Finally, import the C++ file generated in the previous step (i.e., <code>FaustEffect.h</code>) in your project. </p>
<h3 id="integrating-the-faust-dsp-object-to-the-juce-project_1">Integrating the Faust DSP Object to The JUCE Project</h3>
<p>Steps are also similar to the <a href="#simple-monophonic-synth-plug-in">mono synthesizer tutorial</a> here, except that an audio input should be created. So, in <code>PluginProcessor.h</code>, we'll have:</p>
<pre><code>private:
    MapUI* fUI;
    dsp* fDSP;
    float **inputs;
    float **outputs;
</code></pre>
<p>In <code>PluginProcessor.cpp</code>, for the <code>prepareToPlay</code> and <code>releaseResources</code> methods:</p>
<pre><code>void EffectAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    fDSP = new mydsp();
    fDSP-&gt;init(sampleRate);
    fUI = new MapUI();
    fDSP-&gt;buildUserInterface(fUI);
    inputs = new float*[2];
    outputs = new float*[2];
    for (int channel = 0; channel &lt; 2; ++channel) {
        inputs[channel] = new float[samplesPerBlock];
        outputs[channel] = new float[samplesPerBlock];
    }
}

void EffectAudioProcessor::releaseResources()
{
    delete fDSP;
    delete fUI;
    for (int channel = 0; channel &lt; 2; ++channel) {
        delete[] inputs[channel];
        delete[] outputs[channel];
    }
    delete [] inputs;
    delete [] outputs;
}
</code></pre>
<p>and the audio callback:</p>
<pre><code>void EffectAudioProcessor::processBlock (AudioBuffer&lt;float&gt;&amp; buffer, MidiBuffer&amp; midiMessages)
{
    ScopedNoDenormals noDenormals;
    auto totalNumInputChannels  = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();

    for (int channel = 0; channel &lt; totalNumInputChannels; ++channel) {
        for (int i = 0; i &lt; buffer.getNumSamples(); i++) {
            inputs[channel][i] = *buffer.getWritePointer(channel,i);
        }
    }

    fDSP-&gt;compute(buffer.getNumSamples(),inputs,outputs);

    for (int channel = 0; channel &lt; totalNumOutputChannels; ++channel) {
        for (int i = 0; i &lt; buffer.getNumSamples(); i++){
            *buffer.getWritePointer(channel,i) = outputs[channel][i];
        }
    }
}
</code></pre>
<p>This should be relatively self-explanatory.</p>
<p>Of course, the corresponding control methods should be created as well, etc.:</p>
<pre><code>void EffectAudioProcessor::setDelay(float delay)
{
    fUI-&gt;setParamValue(&quot;delay&quot;,delay);
}

void EffectAudioProcessor::setFeedback(float feedback)
{
    fUI-&gt;setParamValue(&quot;feedback&quot;,feedback);
}
</code></pre>
<p>On the interface side, things can be easily adapted to match this new configuration with something like this:</p>
<pre><code>EffectAudioProcessorEditor::EffectAudioProcessorEditor (EffectAudioProcessor&amp; p)
    : AudioProcessorEditor(&amp;p), processor(p)
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize(800, 100);

    addAndMakeVisible (delaySlider);
    delaySlider.setRange(0.0, 1.0);
    delaySlider.setValue(0.5);
    delaySlider.onValueChange = [this] {
        processor.setDelay(delaySlider.getValue());  
    };

    addAndMakeVisible(delayLabel);
    delayLabel.setText(&quot;Delay (s)&quot;, dontSendNotification);
    delayLabel.attachToComponent (&amp;delaySlider, true);

    addAndMakeVisible(feedbackSlider);
    feedbackSlider.setRange(0.0, 1.0);
    feedbackSlider.setValue(0.5);
    feedbackSlider.onValueChange = [this] {
        processor.setFeedback(feedbackSlider.getValue());  
    };

    addAndMakeVisible(feedbackLabel);
    feedbackLabel.setText(&quot;Feedback&quot;, dontSendNotification);
    feedbackLabel.attachToComponent(&amp;feedbackSlider, true);    
}

void EffectAudioProcessorEditor::resized()
{
    const int sliderLeft = 80;
    delaySlider.setBounds(sliderLeft, 10, getWidth() - sliderLeft - 20, 20);
    feedbackSlider.setBounds(sliderLeft, 40, getWidth() - sliderLeft - 20, 20);
}
</code></pre>
<p>Try to compile your program and you should have a beautiful effect plug-in :).</p>
<h2 id="creating-and-using-a-polyphonic-faust-dsp-object">Creating and Using a Polyphonic Faust DSP Object</h2>
<p><a href="misc/poly.zip">&lt;&lt; Download the source of this tutorial &gt;&gt;</a></p>
<p>The procedure to create a polyphonic synthesizer DSP object is slightly different than for a simple monophonic synth such as the one presented at the beginning of this tutorial. Here, we'll be using the same Faust program as one used for the <a href="#simple-monophonic-synth-plug-in">mono synthesizer example</a>. To enable polyphony, we just need to configure the <code>nvoices</code> metadata which allows us to specify the maximum number of voices of polyphony of the DSP object that will be generated:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust2/exfaust2.svg" class="mx-auto d-block">
<faust-editor><!--

declare options "[midi:on][nvoices:12]";

import("stdfaust.lib");
freq = nentry("freq",200,50,1000,0.01);
gain = nentry("gain",0.5,0,1,0.01) : si.smoo;
gate = button("gate") : si.smoo;
cutoff = nentry("cutoff",10000,50,10000,0.01) : si.smoo;
process = os.sawtooth(freq)*gain*gate : fi.lowpass(3,cutoff) <: _,_;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>The package downloadable at the beginning of this tutorial contains a Faust architecture file slightly different from the one used in the previous examples (mono synth and effect): <a href="misc/faustMinimalPoly.h">faustMinimalPoly.h</a>. If you open it, you'll see:</p>
<pre><code>#include &lt;cmath&gt;
#include &lt;cstring&gt;

#include &quot;faust/misc.h&quot;
#include &quot;faust/gui/UI.h&quot;
#include &quot;faust/gui/JSONUIDecoder.h&quot;
#include &quot;faust/dsp/dsp.h&quot;
#include &quot;faust/dsp/dsp-adapter.h&quot;
#include &quot;faust/gui/meta.h&quot;

// BEGIN-FAUSTDSP

&lt;&lt;includeIntrinsic&gt;&gt;

&lt;&lt;includeclass&gt;&gt;

// END-FAUSTDSP

#include &quot;faust/dsp/faust-poly-engine.h&quot;
#include &quot;faust/audio/dummy-audio.h&quot;

std::list&lt;GUI*&gt; GUI::fGuiList;
ztimedmap GUI::gTimedZoneMap;
</code></pre>
<p><code>faust-poly-engine.h</code> contains the <code>FaustPolyEngine</code> class which can be used to turn a Faust C++ DSP object into a polyphonic synthesizer. In order for this class to work, an "audio driver" must be provided which is what the <code>dummyaudio</code> class available in <code>dummy-audio.h</code> can be used for. It also allows us to pass the sampling rate and the buffer size to <code>FaustPolyEngine</code>.</p>
<p>Compile the previous Faust program using this architecture file either by using the Faust command-line compiler or web IDE:</p>
<pre><code>faust -i -a faustMinimalPoly.h FaustSynth.dsp -o PolySynth/Source/FaustSynth.h
</code></pre>
<p>and integrate <code>FaustSynth.h</code> to a new JUCE synth plug-in project (following the same steps as in the <a href="#simple-monophonic-synth-plug-in">mono synth tutorial</a>).</p>
<p>In <code>PluginProcessor.h</code>, declare the following objects:</p>
<pre><code>private:
    audio *driver;
    FaustPolyEngine *faustObject;
    float **outputs;
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PolySynthAudioProcessor)
</code></pre>
<p>Once again, <code>faustObject</code> here will be the polyphonic Faust object and <code>driver</code> will be used to pass the sampling rate and buffer size to the system.</p>
<p>Don't forget the declare the corresponding empty classes at the beginning of the file:</p>
<pre><code>class FaustPolyEngine;
class audio;

class PolySynthAudioProcessor : public AudioProcessor
{
</code></pre>
<p>In <code>PluginProcessor.cpp</code>, first don't forget to include <code>FaustSynth.h</code>. Then fill <code>prepareToPlay</code> with the following code:</p>
<pre><code>void PolySynthAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    driver =  new dummyaudio(sampleRate,samplesPerBlock);
    faustObject = new FaustPolyEngine(NULL,driver,NULL);
    outputs = new float*[2];
    for (int channel = 0; channel &lt; 2; ++channel){
        outputs[channel] = new float[samplesPerBlock];
    }
}
</code></pre>
<p>First, the empty audio driver is instantiated and passed to the Faust polyphonic object. Of course, we allocate memory for the audio output.</p>
<p>Resources are freed as follows:</p>
<pre><code>void PolySynthAudioProcessor::releaseResources()
{
    //delete faustObject;
    delete driver;
    for (int channel = 0; channel &lt; 2; ++channel) {
        delete[] outputs[channel];
    }
    delete [] outputs;
}
</code></pre>
<p>The <code>processBlock</code> method works the same way as for the <a href="#simple-monophonic-synth-plug-in">mono synth tutorial</a> except that the compute method is called here directly from the <code>faustObject</code> (<code>FaustPolyEngine</code>).</p>
<pre><code>void PolySynthAudioProcessor::processBlock (AudioBuffer&lt;float&gt;&amp; buffer, MidiBuffer&amp; midiMessages)
{
    ScopedNoDenormals noDenormals;
    auto totalNumInputChannels = getTotalNumInputChannels();
    auto totalNumOutputChannels = getTotalNumOutputChannels();

    faustObject-&gt;compute(buffer.getNumSamples(),NULL,outputs);

    for (int channel = 0; channel &lt; totalNumOutputChannels; ++channel) {
        for (int i = 0; i &lt; buffer.getNumSamples(); i++) {
            *buffer.getWritePointer(channel,i) = outputs[channel][i];
        }
    }
}
</code></pre>
<p>While the <code>setParamValue</code> method can now be called directly from <code>faustObject</code> to set the value of specific parameters of the Faust object, other polyphony-specific methods are available such as <code>keyOn</code> and <code>keyOff</code>. For an exhaustive list, you can have a look at the source of <code>FaustPolyEngine</code> which should just speak by itself.</p>
<p>Our final goal for this tutorial is to create a simple plug-in with the following interface:</p>
<p><img src="img/polyPlugin.jpg" class="mx-auto d-block" width="60%"></p>
<p>Hence, the Faust DSP object should be controlled with a polyphonic keyboard. New methods must be created in <code>PluginProcessor.cpp</code> to send keyon and keyoff events from the <code>PluginEditor</code> to the <code>PluginProcessor</code>:</p>
<pre><code>void PolySynthAudioProcessor::keyOn(int pitch, int velocity)
{
    faustObject-&gt;keyOn(pitch,velocity);
}

void PolySynthAudioProcessor::keyOff(int pitch)
{
    faustObject-&gt;keyOff(pitch);
}

void PolySynthAudioProcessor::setCutoff(float cutoff)
{
    faustObject-&gt;setParamValue(&quot;cutoff&quot;,cutoff);
}
</code></pre>
<p>Don't forget to declare these methods in <code>PluginProcessor.h</code>, of course.</p>
<p><code>keyOn</code> will allocate a new voice, convert its <code>pitch</code> parameter into a frequency that will be sent automatically to the Faust <code>freq</code> parameter, <code>velocity</code> is converted to a level that will be sent to the <code>gain</code> parameter, and the <code>gate</code> parameter is set to 1. Inversely, <code>keyOff</code> sets <code>gate</code> to 0 and waits for t60 to be reached to de-allocate the current voice.</p>
<p><code>keyOn</code> returns a voice ID whose type is <code>unsigned long</code>. This ID can then be used to change the parameter of a specific voice. We're not using this functionality in the example presented in this tutorial but here is how this would work:</p>
<pre><code>unsigned long voiceID = dspFaust.keyOn(60,110);
dspFaust.setVoiceParamValue(&quot;/synth/cutoff&quot;,voiceID,378);
</code></pre>
<p>Note that voices can also be allocated directly without using <code>keyOn</code> and <code>keyOff</code> with the <code>newVoice</code> and the <code>deleteVoice</code> methods:</p>
<pre><code>unsigned long voiceID = dspFaust.newVoice();
dspFaust.setVoiceParamValue(&quot;/synth/gate&quot;,voiceID,1);
// do something...
dspFaust.deleteVoice(voiceID);
</code></pre>
<p>Using <code>setParamValue</code> as we're doing in the current example, we can set the value of a parameter for all the voices of the DSP engine.</p>
<p>The following implementation is extremely primitive and only the messages from the UI keyboard are processed: we're just doing this for the sake of the example. If you've never worked with keyboards and MIDI in JUCE, we strongly recommend you to read <a href="https://docs.juce.com/master/tutorial_handling_midi_events.html">this tutorial</a>.</p>
<p>In <code>PluginEditor.h</code>, let's first add the following inheritance to the <code>PolySynthAudioProcessorEditor</code> class:</p>
<pre><code>class PolySynthAudioProcessorEditor : 
  public AudioProcessorEditor, 
  private MidiInputCallback, 
  private MidiKeyboardStateListener
{
</code></pre>
<p>This is necessary to implement the MIDI callback and the keyboard (UI) listener.
This inheritance requires us to implement the following methods in the
private section of <code>PluginEditor.h</code>. We also add an instance of a UI keyboard
and its associated state as well as a slider and its label to control the
cutoff frequency of the lowpass:</p>
<pre><code>private:
  void handleNoteOn(MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;
  void handleNoteOff(MidiKeyboardState*, int midiChannel, int midiNoteNumber, float /*velocity*/) override;
  void handleIncomingMidiMessage(MidiInput* source, const MidiMessage&amp; message) override;

  MidiKeyboardState keyboardState;   
  MidiKeyboardComponent keyboardComponent; 

  Slider cutoffSlider;
  Label cutoffLabel;
</code></pre>
<p>In <code>PluginEditor.cpp</code>, we can add the keyboard and the slider to the constructor:</p>
<pre><code>PolySynthAudioProcessorEditor::PolySynthAudioProcessorEditor (PolySynthAudioProcessor&amp; p)
    : AudioProcessorEditor(&amp;p), processor(p), keyboardComponent (keyboardState, MidiKeyboardComponent::horizontalKeyboard)
{
    setSize (800, 150);

    addAndMakeVisible(keyboardComponent);
    keyboardState.addListener(this);

    addAndMakeVisible(cutoffSlider);
    cutoffSlider.setRange(50.0, 10000.0);
    cutoffSlider.setValue(5000.0);
    cutoffSlider.onValueChange = [this] { 
        processor.setCutoff(cutoffSlider.getValue()); 
    };

    addAndMakeVisible(cutoffLabel);
    cutoffLabel.setText(&quot;Cutoff&quot;, dontSendNotification);
    cutoffLabel.attachToComponent(&amp;cutoffSlider, true);
}
</code></pre>
<p>and we must de-allocate the keyboard state listener in the destructor:</p>
<pre><code>PolySynthAudioProcessorEditor::~PolySynthAudioProcessorEditor()
{
    keyboardState.removeListener(this);
}
</code></pre>
<p>The implementation of the <code>setCutoff</code> method is detailed later in this tutorial and is very similar to the one described in the previous section.</p>
<p>We also need to define the size of the various elements in the interface (as we did before):</p>
<pre><code>void PolySynthAudioProcessorEditor::resized()
{
    const int sliderLeft = 80;
    keyboardComponent.setBounds (10,10,getWidth()-30,100);
    cutoffSlider.setBounds(sliderLeft, 120, getWidth() - sliderLeft - 20, 20);
}
</code></pre>
<p>MIDI messages are retrieved from the keyboard simply by implementing the following inherited methods:</p>
<pre><code>void PolySynthAudioProcessorEditor::handleIncomingMidiMessage (MidiInput* source, const MidiMessage&amp; message) {}

void PolySynthAudioProcessorEditor::handleNoteOn(MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
    processor.keyOn(midiNoteNumber,int(127*velocity));
}

void PolySynthAudioProcessorEditor::handleNoteOff(MidiKeyboardState*, int midiChannel, int midiNoteNumber, float /*velocity*/)
{
    processor.keyOff(midiNoteNumber);
}
</code></pre>
<p>That's it folks! Try to compile and run your plug-in, it should just work. Of course, things could be significantly improved here but at this point, you should be able to sail on your own.  </p></div>
        </div>
    </div>

    <footer class="col-md-12">
        <hr>
        <p>Copyright &copy; 2020-2025 <a href="https://www.grame.fr">Grame-CNCM</a></p>
    </footer>
    <script>
        var base_url = "../..",
        shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
    </script>
    <script src="../../js/base.js" defer></script>
    <script src="/js/faust-web-component.js" defer></script>
    <script src="../../search/main.js" defer></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
