<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <title>Architecture Files - Faust Documentation
    </title>
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="/css/quickref.css" rel="stylesheet">
    <link href="/css/github.min.css" rel="stylesheet">
    <link href="/rail/railroad-diagrams.css" rel="stylesheet">
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <script src="../../js/bootstrap.min.js" defer></script>
    <script src="../../js/MathJax-2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"defer></script>
    <script src="../../js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="../.."><img
                    src="../../img/faustText.svg" width="150px"> </a>
            <!-- Expander button -->
            <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Expanded navigation -->
            <div id="navbar-collapse" class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li class="navitem">
                        <a href="../.." class="nav-link">Home</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Manual <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../introduction/" class="dropdown-item">Introduction</a>
</li>
                            
<li>
    <a href="../overview/" class="dropdown-item">Overview of the Faust Universe</a>
</li>
                            
<li>
    <a href="../quick-start/" class="dropdown-item">Quick Start</a>
</li>
                            
<li>
    <a href="../syntax/" class="dropdown-item">Faust Syntax</a>
</li>
                            
<li>
    <a href="../errors/" class="dropdown-item">Error Messages</a>
</li>
                            
<li>
    <a href="../compiler/" class="dropdown-item">Using the Compiler</a>
</li>
                            
<li>
    <a href="../options/" class="dropdown-item">Compiler Options</a>
</li>
                            
<li>
    <a href="../tools/" class="dropdown-item">faust2[...] Tools</a>
</li>
                            
<li>
    <a href="./" class="dropdown-item active">Architecture Files</a>
</li>
                            
<li>
    <a href="../embedding/" class="dropdown-item">Embedding the Compiler</a>
</li>
                            
<li>
    <a href="../optimizing/" class="dropdown-item">Optimizing the Code</a>
</li>
                            
<li>
    <a href="../debugging/" class="dropdown-item">Debugging the Code</a>
</li>
                            
<li>
    <a href="../deploying/" class="dropdown-item">Deploying on the Web</a>
</li>
                            
<li>
    <a href="../remote/" class="dropdown-item">Remote Compilation</a>
</li>
                            
<li>
    <a href="../mathdoc/" class="dropdown-item">Mathematical Documentation</a>
</li>
                            
<li>
    <a href="../osc/" class="dropdown-item">OSC Support</a>
</li>
                            
<li>
    <a href="../http/" class="dropdown-item">HTTP Support</a>
</li>
                            
<li>
    <a href="../midi/" class="dropdown-item">MIDI Support</a>
</li>
                            
<li>
    <a href="../soundfiles/" class="dropdown-item">Soundfiles Support</a>
</li>
                            
<li>
    <a href="../community/" class="dropdown-item">Community</a>
</li>
                            
<li>
    <a href="../faq/" class="dropdown-item">Frequently Asked Questions</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Examples <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../examples/ambisonics/" class="dropdown-item"> ambisonics </a>
</li>
                            
<li>
    <a href="../../examples/analysis/" class="dropdown-item"> analysis </a>
</li>
                            
<li>
    <a href="../../examples/bela/" class="dropdown-item"> bela </a>
</li>
                            
<li>
    <a href="../../examples/delayEcho/" class="dropdown-item"> delayEcho </a>
</li>
                            
<li>
    <a href="../../examples/dynamic/" class="dropdown-item"> dynamic </a>
</li>
                            
<li>
    <a href="../../examples/filtering/" class="dropdown-item"> filtering </a>
</li>
                            
<li>
    <a href="../../examples/gameaudio/" class="dropdown-item"> gameaudio </a>
</li>
                            
<li>
    <a href="../../examples/generator/" class="dropdown-item"> generator </a>
</li>
                            
<li>
    <a href="../../examples/misc/" class="dropdown-item"> misc </a>
</li>
                            
<li>
    <a href="../../examples/phasing/" class="dropdown-item"> phasing </a>
</li>
                            
<li>
    <a href="../../examples/physicalModeling/" class="dropdown-item"> physicalModeling </a>
</li>
                            
<li>
    <a href="../../examples/pitchShifting/" class="dropdown-item"> pitchShifting </a>
</li>
                            
<li>
    <a href="../../examples/psychoacoustic/" class="dropdown-item"> psychoacoustic </a>
</li>
                            
<li>
    <a href="../../examples/reverb/" class="dropdown-item"> reverb </a>
</li>
                            
<li>
    <a href="../../examples/smartKeyboard/" class="dropdown-item"> smartKeyboard </a>
</li>
                            
<li>
    <a href="../../examples/spat/" class="dropdown-item"> spat </a>
</li>
                            
<li>
    <a href="../../rsrc/examples.zip" class="dropdown-item"> Download examples </a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tutorials <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item">Faust & JUCE</a>
</li>
                            
<li>
    <a href="../../tutorials/teensy/" class="dropdown-item">DSP on the Teensy With Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/esp32/" class="dropdown-item">DSP on the ESP-32 With Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/basic-osc/" class="dropdown-item">Making a Sine Oscillator From Scratch</a>
</li>
                            
<li>
    <a href="../../tutorials/summation/" class="dropdown-item">RMS and Summation in Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/box-api/" class="dropdown-item">Using the box API</a>
</li>
                            
<li>
    <a href="../../tutorials/signal-api/" class="dropdown-item">Using the signal API</a>
</li>
                            
<li>
    <a href="../../tutorials/julia/" class="dropdown-item">Using Faust in Julia</a>
</li>
                            
<li>
    <a href="../../tutorials/cmajor/" class="dropdown-item">Using Faust in Cmajor</a>
</li>
                            
<li>
    <a href="../../tutorials/jsfx/" class="dropdown-item">Using Faust in JSFX</a>
</li>
                            
<li>
    <a href="../../tutorials/rnbo/" class="dropdown-item">Using Faust in RNBO with codebox~</a>
</li>
                            
<li>
    <a href="../../tutorials/debugging/" class="dropdown-item">Advanced debugging with interp-tracer</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Workshops <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../workshops/2018-12-01-paw/" class="dropdown-item"> 2018-12-01 PAW </a>
</li>
                            
<li>
    <a href="../../workshops/2020-03-24-faust-citi/" class="dropdown-item"> 2020-03-24 CITI </a>
</li>
                            
<li>
    <a href="../../workshops/2020-04-10-faust-101/" class="dropdown-item"> 2020-04-10 Faust 101 </a>
</li>
                            
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item"> 2020-04-10 Faust & JUCE </a>
</li>
                            
<li>
    <a href="../../workshops/2020-11-21-faust-vcvrack/" class="dropdown-item"> 2020-11-21 Faust & VCV Rack </a>
</li>
                        </ul>
                    </li>
                    <li class="navitem">
                        <a href="../../about/" class="nav-link">About</a>
                    </li>
                </ul>

                <ul class="nav navbar-nav ml-auto">
                    <li class="nav-item">
                        <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fa fa-search"></i> Search
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    

    <div class="container">
        <div class="row"><div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#architecture-files" class="nav-link">Architecture Files</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#minimal-structure-of-an-architecture-file" class="nav-link">Minimal Structure of an Architecture File</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#audio-architecture-modules" class="nav-link">Audio Architecture Modules</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#external-and-internal-audio-sample-formats" class="nav-link">External and internal audio sample formats</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#connection-to-an-audio-driver-api" class="nav-link">Connection to an audio driver API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#connection-to-a-plugin-audio-api" class="nav-link">Connection to a plugin audio API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#midi-architecture-modules" class="nav-link">MIDI Architecture Modules</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#midi-messages-in-the-dsp-source-code" class="nav-link">MIDI Messages in the DSP Source Code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#defined-standard-midi-messages" class="nav-link">Defined Standard MIDI Messages</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#midi-classes" class="nav-link">MIDI Classes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ui-architecture-modules" class="nav-link">UI Architecture Modules</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#active-widgets" class="nav-link">Active Widgets</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#passive-widgets" class="nav-link">Passive Widgets</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#widgets-layout" class="nav-link">Widgets Layout</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#metadata" class="nav-link">Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#graphic-oriented-pure-controllers-code-generator-ui" class="nav-link">Graphic-oriented, pure controllers, code generator UI</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#dsp-json-description" class="nav-link">DSP JSON Description</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#gui-builders" class="nav-link">GUI Builders</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#non-gui-controllers" class="nav-link">Non-GUI Controllers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#some-useful-ui-classes-and-tools-for-developers" class="nav-link">Some Useful UI Classes and Tools for Developers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#multi-controller-and-synchronization" class="nav-link">Multi-Controller and Synchronization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#dsp-architecture-modules" class="nav-link">DSP Architecture Modules</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#the-base-dsp-class" class="nav-link">The Base dsp Class</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#changing-the-generated-class-name" class="nav-link">Changing the generated class name</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#global-dsp-metadata" class="nav-link">Global DSP metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#macro-construction-of-dsp-components" class="nav-link">Macro Construction of DSP Components</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#dsp-decorator-pattern" class="nav-link">DSP Decorator Pattern</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#combining-dsp-components" class="nav-link">Combining DSP Components</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#sample-accurate-control" class="nav-link">Sample Accurate Control</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#control-to-dsp-link" class="nav-link">Control to DSP Link</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#timestamped-control" class="nav-link">Timestamped Control</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#slices-based-dsp-computation" class="nav-link">Slices Based DSP Computation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#audio-driver-timestamping" class="nav-link">Audio driver timestamping</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#typical-use-case" class="nav-link">Typical Use-Case</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#polyphonic-instruments" class="nav-link">Polyphonic Instruments</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#polyphonic-ready-dsp-code" class="nav-link">Polyphonic ready DSP Code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-the-mydsp_poly-class" class="nav-link">Using the mydsp_poly Class</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#polyphonic-instrument-with-a-global-output-effect" class="nav-link">Polyphonic Instrument With a Global Output Effect</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#controlling-the-polyphonic-instrument" class="nav-link">Controlling the Polyphonic Instrument</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#deploying-the-polyphonic-instrument" class="nav-link">Deploying the Polyphonic Instrument</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#custom-memory-manager" class="nav-link">Custom Memory Manager</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#the-mem-option" class="nav-link">The -mem option</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#static-tables" class="nav-link">Static tables</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#defining-and-using-a-custom-memory-manager" class="nav-link">Defining and using a custom memory manager</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#allocating-several-dsp-instances" class="nav-link">Allocating several DSP instances</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#measuring-the-dsp-cpu" class="nav-link">Measuring the DSP CPU</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#the-proxy-dsp-class" class="nav-link">The Proxy DSP Class</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#embedded-platforms" class="nav-link">Embedded Platforms</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#metadata-naming-convention" class="nav-link">Metadata Naming Convention</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-the-uim-compiler-option" class="nav-link">Using the -uim Compiler Option</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#developing-a-new-architecture-file" class="nav-link">Developing a New Architecture File</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#adapting-the-generated-dsp" class="nav-link">Adapting the Generated DSP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#developing-new-ui-architectures" class="nav-link">Developing New UI Architectures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#developing-new-audio-architectures" class="nav-link">Developing New Audio Architectures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#developing-a-new-soundfile-loader" class="nav-link">Developing a New Soundfile Loader</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#other-languages-than-c" class="nav-link">Other Languages Than C++</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#the-faust2xx-scripts" class="nav-link">The faust2xx Scripts</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#using-faust2xx-scripts" class="nav-link">Using faust2xx Scripts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#developing-a-faust2xx-script" class="nav-link">Developing a faust2xx Script</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#the-faust2api-model" class="nav-link">The faust2api Model</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#using-the-inj-option-with-faust2xx-scripts" class="nav-link">Using the -inj Option With faust2xx Scripts</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#using-the-template-llvmcpp-architecture" class="nav-link">Using the template-llvm.cpp architecture</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#second-use-case-computing-the-spectrogram-of-a-set-of-audio-files" class="nav-link">Second use-case computing the spectrogram of a set of audio files</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#writting-the-dsp-code" class="nav-link">Writting the DSP code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#customizing-the-c-code" class="nav-link">Customizing the C++ code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#deploying-it-as-a-maxmsp-external-using-the-faust2max6-script" class="nav-link">Deploying it as a Max/MSP External Using the faust2max6 Script</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#additional-ressources" class="nav-link">Additional Ressources</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#preprocessing-tools" class="nav-link">Preprocessing tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#fpp" class="nav-link">fpp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#c-tools" class="nav-link">C++ tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#faust2hpp" class="nav-link">faust2hpp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustpp" class="nav-link">faustpp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustdoctor" class="nav-link">faustdoctor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#dpf-faust-project-template" class="nav-link">dpf-faust-project-template</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustmd" class="nav-link">faustmd</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustcppconverter" class="nav-link">FaustCPPConverter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#josmodules-and-josm_faust" class="nav-link">JOSModules and josm_faust</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#arduino-tools" class="nav-link">Arduino tools</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#cmajor-tools" class="nav-link">Cmajor tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#using-faust-in-cmajor" class="nav-link">Using Faust in Cmajor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#rnbo-tools" class="nav-link">RNBO tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#using-faust-in-rnbo-with-codebox" class="nav-link">Using Faust in RNBO with codebox~</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#dlang-tools" class="nav-link">DLang tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#faust-2-dplug-guide" class="nav-link">Faust 2 Dplug Guide</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#dplug-faust-example" class="nav-link">Dplug Faust Example</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#julia-tools" class="nav-link">Julia tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#faustjl" class="nav-link">Faust.jl</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-faust-in-julia" class="nav-link">Using Faust in Julia</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#python-tools" class="nav-link">Python tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#faustpy" class="nav-link">FAUSTPy</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faust-ctypes" class="nav-link">Faust Ctypes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#an-scons-tool-for-faust" class="nav-link">An SCons Tool for FAUST</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustwatch" class="nav-link">Faustwatch</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustwidgets" class="nav-link">faustWidgets</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faust-synth" class="nav-link">Faust Synth</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#dawdreamer" class="nav-link">DawDreamer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#ode2dsp" class="nav-link">ode2dsp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustlab" class="nav-link">faustlab</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#cyfaust" class="nav-link">cyfaust</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#rust-tools" class="nav-link">Rust tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#rust-faust" class="nav-link">rust-faust</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faust-egui" class="nav-link">Faust egui</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#rustfaustexperiments" class="nav-link">RustFaustExperiments</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#fl-tui" class="nav-link">fl-tui</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faustlive-jack-rs" class="nav-link">faustlive-jack-rs</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#lowpass-lr4-faust-nih-plug" class="nav-link">lowpass-lr4-faust-nih-plug</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#nih-faust-jit" class="nav-link">nih-faust-jit</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#webassembly-tools" class="nav-link">WebAssembly tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#deploying-faust-dsp-on-the-web" class="nav-link">Deploying Faust DSP on the Web</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faust-loader" class="nav-link">faust-loader</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faust2cpp2wasm" class="nav-link">faust2cpp2wasm</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faust-compiler-microservice" class="nav-link">Faust Compiler Microservice</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#mosfez-faust" class="nav-link">mosfez-faust</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#faust-wap2-playground" class="nav-link">faust-wap2-playground</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#vite-plugin-faust" class="nav-link">vite-plugin-faust</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#dart-tools" class="nav-link">Dart tools</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#flutter_faust_ffi" class="nav-link">flutter_faust_ffi</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
            <div class="col-md-9 main-container" role="main">

<h1 id="architecture-files">Architecture Files</h1>
<p>A Faust program describes a <em>signal processor</em>, a pure DSP computation that maps <em>input signals</em> to <em>output signals</em>. It says nothing about audio drivers or controllers (like GUI, OSC, MIDI, sensors) that are going to control the DSP. This additional information is provided by <em>architecture files</em>.</p>
<p>An <em>architecture file</em> describes how to relate a Faust program to the external world, in particular the audio drivers and the controllers interfaces to be used. This approach allows a single Faust program to be easily deployed to a large variety of audio standards (e.g., Max/MSP externals, PD externals, VST plugins, CoreAudio applications, JACK applications, iPhone/Android, etc.):</p>
<p><img src="img/Architectures.png" class="mx-auto d-block" width="90%"></p>
<p>The architecture to be used is specified at compile time with the <code>-a</code> option. For example <code>faust -a jack-gtk.cpp foo.dsp</code> indicates to use the JACK GTK architecture when compiling <code>foo.dsp</code>.</p>
<p>Some of these architectures are a modular combination of an <em>audio module</em> and one or more <em>controller modules</em>. Some architecture only combine an <em>audio module</em> with the generated DSP to create an <em>audio engine</em> to be controlled with an additional <code>setParamValue/getParamValue</code> kind of API, so that the controller part can be completeley defined externally. This is the purpose of the <a href="#the-faust2api-model">faust2api</a> script explained later on.  </p>
<h2 id="minimal-structure-of-an-architecture-file">Minimal Structure of an Architecture File</h2>
<p>Before going into the details of the architecture files provided with Faust distribution, it is important to have an idea of the essential parts that compose an architecture file. Technically, an architecture file is any text file with two placeholders <code>&lt;&lt;includeIntrinsic&gt;&gt;</code> and <code>&lt;&lt;includeclass&gt;&gt;</code>. The first placeholder is currently not used, and the second one is replaced by the code generated by the FAUST compiler. </p>
<p>Therefore, the <em>really minimal</em> architecture file, let's call it <code>nullarch.cpp</code>, is the following:</p>
<pre><code>&lt;&lt;includeIntrinsic&gt;&gt;
&lt;&lt;includeclass&gt;&gt;
</code></pre>
<p>This <code>nullarch.cpp</code> architecture has the property that <code>faust foo.dsp</code> and <code>faust -a nullarch.cpp foo.dsp</code> produce the same result. Obviously, this is not very useful, moreover the resulting <code>cpp</code> file doesn't compile. </p>
<p>Here is <code>miniarch.cpp</code>, a minimal architecture file that contains enough information to produce a <code>cpp</code> file that can be successfully compiled:</p>
<pre><code class="language-c++">&lt;&lt;includeIntrinsic&gt;&gt;

#define FAUSTFLOAT float

class dsp {};

struct Meta {
    virtual void declare(const char* key, const char* value) {};
};

struct Soundfile {};

struct UI {
    // -- widget's layouts
    virtual void openTabBox(const char* label) {}
    virtual void openHorizontalBox(const char* label) {}
    virtual void openVerticalBox(const char* label) {}
    virtual void closeBox() {}

    // -- active widgets
    virtual void addButton(const char* label, FAUSTFLOAT* zone) {}
    virtual void addCheckButton(const char* label, FAUSTFLOAT* zone) {}
    virtual void addVerticalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    virtual void addHorizontalSlider(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}
    virtual void addNumEntry(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT init, FAUSTFLOAT min, FAUSTFLOAT max, FAUSTFLOAT step) {}

    // -- passive widgets
    virtual void addHorizontalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}
    virtual void addVerticalBargraph(const char* label, FAUSTFLOAT* zone, FAUSTFLOAT min, FAUSTFLOAT max) {}

    // -- soundfiles
    virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) {}

    // -- metadata declarations
    virtual void declare(FAUSTFLOAT* zone, const char* key, const char* val) {}
};

&lt;&lt;includeclass&gt;&gt;
</code></pre>
<p>This architecture is still not very useful, but it gives an idea of what a real-life architecture file has to implement, in addition to the audio part itself. As we will see in the next section, Faust architectures are implemented using a modular approach to avoid code duplication and favor code maintenance and reuse.</p>
<h2 id="audio-architecture-modules">Audio Architecture Modules</h2>
<p>A Faust generated program has to connect to a underlying audio layer. Depending if the final program is a application or plugin, the way to connect to this audio layer will differ:</p>
<ul>
<li>applications typically use the OS audio driver API, which will be CoreAudio on macOS, ALSA on Linux, WASAPI on Windows for instance, or any kind of multi-platforms API like <a href="http://portaudio.com">PortAudio</a> or <a href="https://jackaudio.org">JACK</a>. In this case a subclass of the base class <code>audio</code> (see later) has to be written</li>
<li>plugins (like <a href="https://www.steinberg.net/en/company/technologies/vst3.html">VST3</a>, <a href="https://developer.apple.com/documentation/audiounit">Audio Unit</a> or <a href="https://juce.com">JUCE</a> for instance) usually have to follow a more constrained API which imposes a <em>life cyle</em>, something like <em>loading/initializing/starting/running/stopping/unloading</em> sequence of operations. In this case the Faust generated module <em>new/init/compute/delete</em> methods have to be inserted in the plugin API, by calling each module function at the appropriate place.</li>
</ul>
<h3 id="external-and-internal-audio-sample-formats">External and internal audio sample formats</h3>
<p>Audio samples are managed by the underlying audio layer, typically as 32 bits <code>float</code> or 64 bits <code>double</code> values in the <em>[-1..1]</em> interval. Their format is defined with the <code>FAUSTFLOAT</code> macro implemented in the architecture file as <code>float</code> by default. The DSP audio samples format is choosen at compile time, with the <code>-single</code> (= default), <code>-double</code> or <code>-quad</code> compilation option. Control parameters like buttons, sliders... also use the <code>FAUSTFLOAT</code> format.</p>
<p>By default, the <code>FAUSTFLOAT</code> macro is written with the following code:</p>
<pre><code class="language-c++">#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif
</code></pre>
<p>which gives it a value (<em>if not already defined</em>), and since the default internal format is <code>float</code>, nothing special has to be done in the general case. But when the DSP is compiled using the <code>-double</code> option, the audio inputs/outputs buffers have to be <em>adapted</em>, with a <a href="https://github.com/grame-cncm/faust/blob/fcc51c12184b6e07ebdfc6fd51427ad1af498ac2/architecture/faust/dsp/dsp-adapter.h">dsp_sample_adapter</a> class, for instance like in the <a href="https://github.com/grame-cncm/faust/blob/07ce81dac88afe76475e93e797b94982c9298b58/tools/benchmark/dynamic-jack-gtk.cpp">dynamic-jack-gt tool</a>.</p>
<p>Note that an architecture may redefine <code>FAUSTFLOAT</code> in double, and have the complete audio chain running in double. This has to be done <em>before including</em> any architecture file that would define <code>FAUSTFLOAT</code> itself (because of the <code>#ifndef</code> logic). </p>
<h3 id="connection-to-an-audio-driver-api">Connection to an audio driver API</h3>
<p>An <em>audio driver architecture</em> typically connects a Faust program to the audio drivers. It is responsible for:</p>
<ul>
<li>allocating and releasing the audio channels and presenting the audio as non-interleaved float/double data (depending of the <code>FAUSTFLOAT</code> macro definition), normalized between -1.0 and 1.0</li>
<li>calling the DSP <code>init</code> method at init time, to setup the <code>ma.SR</code> variable possibly used in the DSP code</li>
<li>calling the DSP <code>compute</code> method to handle incoming audio buffers and/or to produce audio outputs. </li>
</ul>
<p>The default compilation model uses separated audio input and output buffers not referring to the same memory locations. The <code>-inpl (--in-place)</code> code generation model allows us to generate code working when <em>input and output buffers are the same</em> (which is typically needed in some embedded devices). This option currently only works in scalar (= default) code generation mode.</p>
<p>A Faust audio architecture module derives from an <em>audio</em> class can be defined as below (simplified version, see the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/audio/audio.h">real version here)</a>:</p>
<pre><code class="language-c++">class audio {

    public:

        audio() {}
        virtual ~audio() {}

        /**
         * Init the DSP.
         * @param name - the DSP name to be given to the audio driven 
         * (could appear as a JACK client for instance)
         * @param dsp - the dsp that will be initialized with the driver sample rate
         *
         * @return true is sucessful, false if case of driver failure.
         **/
        virtual bool init(const char* name, dsp* dsp) = 0;

        /**
         * Start audio processing.
         * @return true is sucessfull, false if case of driver failure.
         **/
        virtual bool start() = 0;

        /**
         * Stop audio processing.
         **/
        virtual void stop() = 0;

        void setShutdownCallback(shutdown_callback cb, void* arg) = 0;

         // Return buffer size in frames.
        virtual int getBufferSize() = 0;

        // Return the driver sample rate in Hz.
        virtual int getSampleRate() = 0;

        // Return the driver hardware inputs number.
        virtual int getNumInputs() = 0;

        // Return the driver hardware outputs number.
        virtual int getNumOutputs() = 0;

        /**
        * @return Returns the average proportion of available CPU 
        * being spent inside the audio callbacks (between 0.0 and 1.0).
        **/
        virtual float getCPULoad() = 0;
};
</code></pre>
<p>The API is simple enough to give a great flexibility to audio architectures implementations. The  <code>init</code> method should initialize the audio. At  <code>init</code> exit, the system should be in a safe state to recall the  <code>dsp</code> object state. Here is the hierarchy of some of the supported audio drivers:</p>
<p><img src="img/AudioHierarchy.jpg" class="mx-auto d-block" width="70%"></p>
<h3 id="connection-to-a-plugin-audio-api">Connection to a plugin audio API</h3>
<p>In the case of plugin, an <em>audio plugin architecture</em> has to be developed, by integrating the Faust DSP <em>new/init/compute/delete</em> methods in the plugin API. Here is a concrete example using the JUCE framework:</p>
<ul>
<li>
<p>a <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/juce/juce-plugin.cpp#L227">FaustPlugInAudioProcessor</a> class, subclass of the <code>juce::AudioProcessor</code> has to be defined. The Faust generated C++ instance will be created in its constructor, either in monophonic of polyphonic mode (see later sections)</p>
</li>
<li>
<p>the Faust DSP instance is initialized in the JUCE <code>prepareToPlay</code> method using the current sample rate value</p>
</li>
<li>
<p>the Faust dsp <code>compute</code> is called in the JUCE <code>process</code> which receives the audio inputs/outputs buffers to be processed</p>
</li>
<li>
<p>additional methods can possibly be implemented to handle MIDI messages or save/restore the plugin parameters state for instance. </p>
</li>
</ul>
<p>This methodology obviously has to be adapted for each supported plugin API.</p>
<h2 id="midi-architecture-modules">MIDI Architecture Modules</h2>
<p>A <em>MIDI architecture module</em> typically connects a Faust program to the MIDI drivers. MIDI control connects DSP parameters with MIDI messages (in both directions), and can be used to trigger polyphonic instruments.</p>
<h4 id="midi-messages-in-the-dsp-source-code">MIDI Messages in the DSP Source Code</h4>
<p>MIDI control messages are described as metadata in UI elements. They are decoded by a <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/MidiUI.h">MidiUI</a> class, subclass of <code>UI</code>, which parses incoming MIDI messages and updates the appropriate control parameters, or sends MIDI messages when the UI elements (sliders, buttons...) are moved.</p>
<h4 id="defined-standard-midi-messages">Defined Standard MIDI Messages</h4>
<p>A special <code>[midi:xxx yyy...]</code> metadata needs to be added to the UI element. The full description of supported MIDI messages is part of the <a href="../midi/">Faust documentation</a>.</p>
<h4 id="midi-classes">MIDI Classes</h4>
<p>A <code>midi</code> base class defining MIDI messages decoding/encoding methods has been developed. It will be used to receive and transmit MIDI messages:</p>
<pre><code class="language-c++">class midi {

public:

    midi() {}
    virtual ~midi() {}

    // Additional timestamped API for MIDI input
    virtual MapUI* keyOn(double, int channel, int pitch, int velocity)
    {
        return keyOn(channel, pitch, velocity);
    }

    virtual void keyOff(double, int channel, int pitch, int velocity = 0)
    {
        keyOff(channel, pitch, velocity);
    }

    virtual void keyPress(double, int channel, int pitch, int press)
    {
        keyPress(channel, pitch, press);
    }

    virtual void chanPress(double date, int channel, int press)
    {
        chanPress(channel, press);
    }

    virtual void pitchWheel(double, int channel, int wheel)
    {
        pitchWheel(channel, wheel);
    }

    virtual void ctrlChange(double, int channel, int ctrl, int value)
    {
        ctrlChange(channel, ctrl, value);
    }

    virtual void ctrlChange14bits(double, int channel, int ctrl, int value)
    {
        ctrlChange14bits(channel, ctrl, value);
    }

    virtual void rpn(double, int channel, int ctrl, int value)
    {
        rpn(channel, ctrl, value);
    }

    virtual void progChange(double, int channel, int pgm)
    {
        progChange(channel, pgm);
    }

    virtual void sysEx(double, std::vector&lt;unsigned char&gt;&amp; message)
    {
        sysEx(message);
    }

    // MIDI sync
    virtual void startSync(double date)  {}
    virtual void stopSync(double date)   {}
    virtual void clock(double date)  {}

    // Standard MIDI API
    virtual MapUI* keyOn(int channel, int pitch, int velocity)      { return nullptr; }
    virtual void keyOff(int channel, int pitch, int velocity)       {}
    virtual void keyPress(int channel, int pitch, int press)        {}
    virtual void chanPress(int channel, int press)                  {}
    virtual void ctrlChange(int channel, int ctrl, int value)       {}
    virtual void ctrlChange14bits(int channel, int ctrl, int value) {}
    virtual void rpn(int channel, int ctrl, int value)              {}
    virtual void pitchWheel(int channel, int wheel)                 {}
    virtual void progChange(int channel, int pgm)                   {}
    virtual void sysEx(std::vector&lt;unsigned char&gt;&amp; message)         {}

    enum MidiStatus {
        // channel voice messages
        MIDI_NOTE_OFF = 0x80,
        MIDI_NOTE_ON = 0x90,
        MIDI_CONTROL_CHANGE = 0xB0,
        MIDI_PROGRAM_CHANGE = 0xC0,
        MIDI_PITCH_BEND = 0xE0,
        MIDI_AFTERTOUCH = 0xD0,         // aka channel pressure
        MIDI_POLY_AFTERTOUCH = 0xA0,    // aka key pressure
        MIDI_CLOCK = 0xF8,
        MIDI_START = 0xFA,
        MIDI_CONT = 0xFB,
        MIDI_STOP = 0xFC,
        MIDI_SYSEX_START = 0xF0,
        MIDI_SYSEX_STOP = 0xF7
    };

    enum MidiCtrl {
        ALL_NOTES_OFF = 123,
        ALL_SOUND_OFF = 120
    };

    enum MidiNPN {
        PITCH_BEND_RANGE = 0
    };
};
</code></pre>
<p>A pure interface for MIDI handlers that can send/receive MIDI messages to/from <code>midi</code>objects is defined:</p>
<pre><code class="language-c++">struct midi_interface {
    virtual void addMidiIn(midi* midi_dsp)      = 0;
    virtual void removeMidiIn(midi* midi_dsp)   = 0;
    virtual ~midi_interface() {}
};
</code></pre>
<p>A <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/midi/midi.h#L261">midi_hander</a> subclass implements actual MIDI decoding and <em>maintains a list of MIDI aware components</em> (classes inheriting from <code>midi</code> and ready to send and/or receive MIDI events) using the <code>addMidiIn/removeMidiIn</code> methods:</p>
<pre><code class="language-c++">class midi_handler : public midi, public midi_interface {

    protected:

        std::vector&lt;midi*&gt; fMidiInputs;
        std::string fName;
        MidiNRPN fNRPN;

    public:

        midi_handler(const std::string&amp; name = &quot;MIDIHandler&quot;):fName(name) {}
        virtual ~midi_handler() {}

        void addMidiIn(midi* midi_dsp) {...}
        void removeMidiIn(midi* midi_dsp) {...}
        ...
        ...
};
</code></pre>
<p>Several concrete implementations subclassing <code>midi_handler</code> using native APIs have been written and can be found in the <a href="https://github.com/grame-cncm/faust/tree/master-dev/architecture/faust/midi">faust/midi</a> folder:</p>
<p><img src="img/MIDIHierarchy.jpg" class="mx-auto d-block" width="80%"></p>
<p>Depending on the native MIDI API being used, event timestamps are either expressed in absolute time or in frames. They are converted to offsets expressed in samples relative to the beginning of the audio buffer.</p>
<p>Connected with the <code>MidiUI</code> class (a subclass of <code>UI</code>), they allow a given DSP to be controlled with incoming MIDI messages or possibly send MIDI messages when its internal control state changes.</p>
<p>In the following piece of code, a <code>MidiUI</code> object is created and connected to a <code>rt_midi</code> MIDI messages handler (using the <a href="http://www.music.mcgill.ca/~gary/rtmidi/">RTMidi</a> library), then given as a parameter to the standard <code>buildUserInterface</code> to control DSP parameters:</p>
<pre><code class="language-c++">...
rt_midi midi_handler(&quot;MIDI&quot;);
MidiUI midi_interface(&amp;midi_handler);
DSP-&gt;buildUserInterface(&amp;midi_interface);
...
</code></pre>
<h2 id="ui-architecture-modules">UI Architecture Modules</h2>
<p>A UI architecture module links user actions (i.e., via graphic widgets, command line parameters, OSC messages, etc.) with the Faust program to control. It is responsible for associating program parameters to user interface elements and to update parameter’s values according to user actions. This association is triggered by the <code>buildUserInterface</code> call, where the <code>dsp</code> asks a UI object to build the DSP module controllers.</p>
<p>Since the interface is basically graphic-oriented, the main concepts are <em>widget</em> based: an UI architecture module is semantically oriented to handle active widgets, passive widgets and widgets layout.</p>
<p>A Faust UI architecture module derives the <code>UI</code> base class: </p>
<pre><code class="language-c++">template &lt;typename REAL&gt;
struct UIReal {

    UIReal() {}
    virtual ~UIReal() {}

    // -- widget's layouts

    virtual void openTabBox(const char* label) = 0;
    virtual void openHorizontalBox(const char* label) = 0;
    virtual void openVerticalBox(const char* label) = 0;
    virtual void closeBox() = 0;

    // -- active widgets

    virtual void addButton(const char* label, REAL* zone) = 0;
    virtual void addCheckButton(const char* label, REAL* zone) = 0;
    virtual void addVerticalSlider(const char* label, REAL* zone, REAL init, 
                                   REAL min, REAL max, REAL step) = 0;
    virtual void addHorizontalSlider(const char* label, REAL* zone, REAL init, 
                                     REAL min, REAL max, REAL step) = 0;
    virtual void addNumEntry(const char* label, REAL* zone, REAL init, 
                             REAL min, REAL max, REAL step) = 0;

    // -- passive widgets

    virtual void addHorizontalBargraph(const char* label, REAL* zone, REAL min, REAL max) = 0;
    virtual void addVerticalBargraph(const char* label, REAL* zone, REAL min, REAL max) = 0;

    // -- soundfiles

    virtual void addSoundfile(const char* label, const char* filename, Soundfile** sf_zone) = 0;

    // -- metadata declarations

    virtual void declare(REAL* zone, const char* key, const char* val) {}
};

struct UI : public UIReal&lt;FAUSTFLOAT&gt;
{
    UI() {}
    virtual ~UI() {}
};
</code></pre>
<p>The <code>FAUSTFLOAT* zone</code> element is the <em>primary connection point between the control interface and the dsp code.</em> The compiled dsp Faust code will give access to all internal control value addresses used by the dsp code by calling the approriate <code>addButton</code>, <code>addVerticalSlider</code>, <code>addNumEntry</code> etc. methods (depending of what is described in the original Faust DSP source code). </p>
<p>The control/UI code keeps those addresses, and will typically change their pointed values each time a control value in the dsp code has to be changed. On the dsp side, all control values are <em>sampled</em> once at the beginning of the <code>compute</code> method, so that to <em>keep the same value during the entire audio buffer.</em> </p>
<p>Writing and reading the control values is typically done in two different threads: the controller (a GUI, an OSC or MIDI.etc. one) write the values, and the audio real-time thread read them in the audio callback. Since writing/reading the <code>FAUSTFLOAT* zone</code> element is atomic, there is no need (in general) of complex synchronization mechanism between the writer (controller) and the reader (the Faust <code>dsp</code> object). </p>
<p>Here is part of the UI classes hierarchy:</p>
<p><img src="img/GUIHierarchy.png" class="mx-auto d-block" width="80%"></p>
<h4 id="active-widgets">Active Widgets</h4>
<p>Active widgets are graphical elements controlling a parameter value. They are initialized with the widget name and a pointer to the linked value, using the <code>FAUSTFLOAT</code> macro type (defined at compile time as either <code>float</code> or <code>double</code>). Active widgets in Faust are <code>Button</code>, <code>CheckButton</code>, <code>VerticalSlider</code>, <code>HorizontalSlider</code> and <code>NumEntry</code>.</p>
<p>A GUI architecture must implement a method <code>addXxx(const char* name, FAUSTFLOAT* zone, ...)</code> for each active widget. Additional parameters are available for <code>Slider</code> and <code>NumEntry</code>: the <code>init</code>, <code>min</code>, <code>max</code> and <code>step</code> values.</p>
<h4 id="passive-widgets">Passive Widgets</h4>
<p>Passive widgets are graphical elements reflecting values. Similarly to active widgets, they are initialized with the widget name and a pointer to the linked value. Passive widgets in Faust are <code>HorizontalBarGraph</code> and <code>VerticalBarGraph</code>.</p>
<p>A UI architecture must implement a method <code>addXxx(const char* name, FAUSTFLOAT* zone, ...)</code> for each passive widget. Additional parameters are available, depending on the passive widget type.</p>
<h4 id="widgets-layout">Widgets Layout</h4>
<p>Generally, a GUI is hierarchically organized into boxes and/or tab boxes. A UI architecture must support the following methods to setup this hierarchy:</p>
<pre><code class="language-c++">  openTabBox(const char* label);
  openHorizontalBox(const char* label);
  openVerticalBox(const char* label);
  closeBox(const char* label);
</code></pre>
<p>Note that all the widgets are added to the current box.  </p>
<h4 id="metadata">Metadata</h4>
<p>The Faust language allows widget labels to contain metadata enclosed in square brackets as key/value pairs. These metadata are handled at GUI level by a <code>declare</code> method taking as argument, a pointer to the widget associated zone, the metadata key and value:</p>
<pre><code class="language-c++">declare(FAUSTFLOAT* zone, const char* key, const char* value);
</code></pre>
<p>Here is the table of currently supported general medadata:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>tooltip</td>
<td>actual string content</td>
</tr>
<tr>
<td>hidden</td>
<td>0 or 1</td>
</tr>
<tr>
<td>unit</td>
<td><em>Hz</em> or <em>dB</em></td>
</tr>
<tr>
<td>scale</td>
<td><em>log</em> or <em>exp</em></td>
</tr>
<tr>
<td>style</td>
<td><em>knob</em> or <em>led</em> or <em>numerical</em></td>
</tr>
<tr>
<td>style</td>
<td><em>radio{’label1’:v1;’label2’:v2...}</em></td>
</tr>
<tr>
<td>style</td>
<td><em>menu{’label1’:v1;’label2’:v2...}</em></td>
</tr>
<tr>
<td>acc</td>
<td><em>axe curve amin amid amax</em></td>
</tr>
<tr>
<td>gyr</td>
<td><em>axe curve amin amid amax</em></td>
</tr>
<tr>
<td>screencolor</td>
<td><em>red</em> or <em>green</em> or <em>blue</em> or <em>white</em></td>
</tr>
</tbody>
</table>
<p>Here <code>acc</code> means <em>accelerometer</em> and <code>gyr</code> means <em>gyroscope</em>, both use the same parameters (a mapping description) but are linked to different sensors.</p>
<p>Some typical example where several metadata are defined could be:</p>
<pre><code>nentry(&quot;freq [unit:Hz][scale:log][acc:0 0 -30 0 30][style:menu{’white noise’:0;’pink noise’:1;’sine’:2}][hidden:0]&quot;, 0, 20, 100, 1)
</code></pre>
<p>or:</p>
<pre><code>vslider(&quot;freq [unit:dB][style:knob][gyr:0 0 -30 0 30]&quot;, 0, 20, 100, 1)
</code></pre>
<p>When one or several metadata are added in the same item label, then will appear in the generated code as one or successives <code>declare(FAUSTFLOAT* zone, const char* key, const char* value);</code> lines <em>before</em> the line describing the item itself. Thus the UI managing code has to associate them with the proper item. Look at the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/MetaDataUI.h">MetaDataUI</a> class for an example of this technique.</p>
<p>MIDI specific metadata are <a href="../midi/">described here</a> and are decoded the <code>MidiUI</code> class.</p>
<p>Note that medatada are not supported in all architecture files. Some of them like (<code>acc</code> or <code>gyr</code> for example) only make sense on platforms with accelerometers or gyroscopes sensors. The set of medatada may be extended in the future and <em>can possibly be adapted for a specific project.</em> They can be decoded using the <code>MetaDataUI</code>class.</p>
<h4 id="graphic-oriented-pure-controllers-code-generator-ui">Graphic-oriented, pure controllers, code generator UI</h4>
<p>Even if the UI architecture module is graphic-oriented, a given implementation can perfectly choose to ignore all layout information and only keep the controller ones, like the buttons, sliders, nentries, bargraphs. This is typically what is done in the <code>MidiUI</code> or <code>OSCUI</code> architectures. </p>
<p>Note that pure code generator can also be written. The <code>JSONUI</code> UI architecture is an example of an architecture generating the DSP JSON description as a text file. </p>
<h4 id="dsp-json-description">DSP JSON Description</h4>
<p>The full description of a given compiled DSP can be generated as a JSON file, to be used at several places in the architecture system. This JSON describes the DSP with its inputs/outputs number, some metadata (filename, name, used compilation parameters, used libraries etc.) as well as its UI with a hierarchy of groups up to terminal items (<em>buttons</em>, <em>sliders</em>, <em>nentries</em>, <em>bargraphs</em>) with all their parameters (<em>type</em>, <em>label</em>, <em>shortname</em>, <em>address</em>, <em>meta</em>, <em>init</em>, <em>min</em>, <em>max</em> and <em>step</em> values). For the following DSP program:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
vol = hslider(&quot;volume [unit:dB]&quot;, 0, -96, 0, 0.1) : ba.db2linear : si.smoo;
freq = hslider(&quot;freq [unit:Hz]&quot;, 600, 20, 2000, 1);

process = vgroup(&quot;Oscillator&quot;, os.osc(freq) * vol) &lt;: (_,_);
</code></pre>
<p>The generated JSON file is then:</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;foo&quot;,
    &quot;filename&quot;: &quot;foo.dsp&quot;,
    &quot;version&quot;: &quot;2.40.8&quot;,
    &quot;compile_options&quot;: &quot;-lang cpp -es 1 -mcd 16 -single -ftz 0&quot;,
    &quot;library_list&quot;: [],
    &quot;include_pathnames&quot;: [&quot;/usr/local/share/faust&quot;],
    &quot;inputs&quot;: 0,
    &quot;outputs&quot;: 2,
    &quot;meta&quot;: [ 
        { &quot;basics.lib/name&quot;: &quot;Faust Basic Element Library&quot; },
        { &quot;basics.lib/version&quot;: &quot;0.6&quot; },
        { &quot;compile_options&quot;: &quot;-lang cpp -es 1 -mcd 16 -single -ftz 0&quot; },
        { &quot;filename&quot;: &quot;foo.dsp&quot; },
        { &quot;maths.lib/author&quot;: &quot;GRAME&quot; },
        { &quot;maths.lib/copyright&quot;: &quot;GRAME&quot; },
        { &quot;maths.lib/license&quot;: &quot;LGPL with exception&quot; },
        { &quot;maths.lib/name&quot;: &quot;Faust Math Library&quot; },
        { &quot;maths.lib/version&quot;: &quot;2.5&quot; },
        { &quot;name&quot;: &quot;tes&quot; },
        { &quot;oscillators.lib/name&quot;: &quot;Faust Oscillator Library&quot; },
        { &quot;oscillators.lib/version&quot;: &quot;0.3&quot; },
        { &quot;platform.lib/name&quot;: &quot;Generic Platform Library&quot; },
        { &quot;platform.lib/version&quot;: &quot;0.2&quot; },
        { &quot;signals.lib/name&quot;: &quot;Faust Signal Routing Library&quot; },
        { &quot;signals.lib/version&quot;: &quot;0.1&quot; }
    ],
    &quot;ui&quot;: [ 
        {
            &quot;type&quot;: &quot;vgroup&quot;,
            &quot;label&quot;: &quot;Oscillator&quot;,
            &quot;items&quot;: [ 
                {
                    &quot;type&quot;: &quot;hslider&quot;,
                    &quot;label&quot;: &quot;freq&quot;,
                    &quot;shortname&quot;: &quot;freq&quot;,
                    &quot;address&quot;: &quot;/Oscillator/freq&quot;,
                    &quot;meta&quot;: [
                        { &quot;unit&quot;: &quot;Hz&quot; }
                    ],
                    &quot;init&quot;: 600,
                    &quot;min&quot;: 20,
                    &quot;max&quot;: 2000,
                    &quot;step&quot;: 1
                },
                {
                    &quot;type&quot;: &quot;hslider&quot;,
                    &quot;label&quot;: &quot;volume&quot;,
                    &quot;shortname&quot;: &quot;volume&quot;,
                    &quot;address&quot;: &quot;/Oscillator/volume&quot;,
                    &quot;meta&quot;: [
                        { &quot;unit&quot;: &quot;dB&quot; }
                    ],
                    &quot;init&quot;: 0,
                    &quot;min&quot;: -96,
                    &quot;max&quot;: 0,
                    &quot;step&quot;: 0.1
                }
            ]
        }
    ]
}
</code></pre>
<p>The JSON file can be generated with <code>faust -json foo.dsp</code> command, or programmatically using the <code>JSONUI</code> UI architecture (see next <a href="#some-useful-ui-classes-and-tools-for-developers">Some Useful UI Classes and Tools for Developers</a> section).</p>
<p>Here is the description of ready-to-use UI classes, followed by classes to be used in developer code:</p>
<h4 id="gui-builders">GUI Builders</h4>
<p>Here is the description of the main GUI classes:</p>
<ul>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/GTKUI.h">GTKUI</a> class uses the <a href="https://www.gtk.org">GTK</a> toolkit to create a Graphical User Interface with a proper group-based layout</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/QTUI.h">QTUI</a> class uses the <a href="https://www.qt.io">QT</a> toolkit to create a Graphical User Interface with a proper group based layout</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/JuceUI.h">JuceUI</a> class uses the <a href="https://juce.com">JUCE</a> framework to create a Graphical User Interface with a proper group based layout</li>
</ul>
<h4 id="non-gui-controllers">Non-GUI Controllers</h4>
<p>Here is the description of the main non-GUI controller classes:</p>
<ul>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/OSCUI.h">OSCUI</a> class implements OSC remote control in both directions</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/httpdUI.h">httpdUI</a> class implements HTTP remote control using the <a href="https://www.gnu.org/software/libmicrohttpd/">libmicrohttpd</a> library to embed a HTTP server inside the application. Then by opening a browser on a specific URL, the GUI will appear and allow to control the distant application or plugin. The connection works in both directions</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/MIDIUI.h">MIDIUI</a> class implements MIDI control in both directions, and it explained more deeply later on</li>
</ul>
<h4 id="some-useful-ui-classes-and-tools-for-developers">Some Useful UI Classes and Tools for Developers</h4>
<p>Some useful UI classes and tools can possibly be reused in developer code:</p>
<ul>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/MapUI.h">MapUI</a> class establishes a mapping beween UI items and their <em>labels</em>, <em>shortname</em> or <em>paths</em>, and offers a <code>setParamValue/getParamValue</code> API to set and get their values. It uses an helper <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/PathBuilder.h">PathBuilder</a> class to create complete shortnames and pathnames to the leaves in the UI hierarchy. Note that the item path encodes the UI hierarchy in the form of a <em>/group1/group2/.../label</em> string and is the way to distinguish control that may have the same label, but different localisation in the UI tree. Using shortnames (built so that they never collide) is an alternative way to access items. The<code>setParamValue/getParamValue</code> API takes either <em>labels</em>, <em>shortname</em> or <em>paths</em> as the way to describe the control, but using shortnames or paths is the safer way to use it</li>
<li>the extended <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/APIUI.h">APIUI</a> offers <code>setParamValue/getParamValue</code> API similar to <code>MapUI</code>, with additional methods to deal with accelerometer/gyroscope kind of metadata</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/MetaDataUI.h">MetaDataUI</a> class decodes all currently supported metadata and can be used to retrieve their values </li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/JSONUI.h">JSONUI</a> class allows us to generate the JSON description of a given DSP </li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/JSONUIDecoder.h">JSONUIDecoder</a> class is used to decode the DSP JSON description and implement its <code>buildUserInterface</code> and  <code>metadata</code> methods</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/FUI.h">FUI</a> class allows us to save and restore the parameters state as a text file</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/SoundUI.h">SoundUI</a> class with the associated <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/Soundfile.h">Soundfile</a> class is used to implement the <code>soundfile</code> primitive, and load the described audio resources (typically audio files), by using different concrete implementations, either using <a href="http://www.mega-nerd.com/libsndfile/">libsndfile</a> (with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/LibsndfileReader.h">LibsndfileReader.h</a> file), or <a href="https://juce.com">JUCE</a> (with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/JuceReader.h">JuceReader</a> file). Paths to sound files can be absolute, but it should be noted that a relative path mechanism can be set up when creating an instance of <code>SoundUI</code>, in order to load sound files with a more flexible strategy.</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/ControlSequenceUI.h">ControlSequenceUI</a> class with the associated <code>OSCSequenceReader</code> class allow to control parameters change in time, using the OSC time tag format. Changing the control values will have to be mixed with audio rendering. Look at the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/sndfile.cpp">sndfile.cpp</a> use-case.</li>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/ValueConverter.h">ValueConverter</a> file contains several mapping classes used to map user interface values (for example a gui slider delivering values between 0 and 1) to Faust values (for example a <code>vslider</code> between 20 and 2000) using linear/log/exp scales. It also provides classes to handle the <code>[acc:a b c d e]</code> and <code>[gyr:a b c d e]</code> <a href="http://localhost:8000/manual/syntax/#sensors-control-metadatas">Sensors Control Metadatas</a>.</li>
</ul>
<h4 id="multi-controller-and-synchronization">Multi-Controller and Synchronization</h4>
<p>A given DSP can perfectly be controlled by  several UI classes at the same time, and they will all read and write the same DSP control memory zones. Here is an example of code using a GUI using <code>GTKUI</code> architecture, as well as OSC control using <code>OSCUI</code>:</p>
<pre><code class="language-c++">...
GTKUI gtk_interface(name, &amp;argc, &amp;argv);
DSP-&gt;buildUserInterface(&amp;gtk_interface);
OSCUI osc_interface(name, argc, argv);
DSP-&gt;buildUserInterface(&amp;osc_interface);
...
</code></pre>
<p>Since several controller <em>access</em> the same values, you may have to synchronize them, in order for instance to have the GUI sliders or buttons <em>reflect the state</em> that would have been changed by the <code>OSCUI</code> controller at reception time, of have OSC messages <em>been sent</em> each time UI items like sliders or buttons are moved.   </p>
<p>This synchronization mecanism is implemented in a generic way in the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/GUI.h">GUI</a> class. First the<code>uiItemBase</code> class is defined as the basic synchronizable memory zone, then grouped in a list controlling the same zone from different GUI instances. The <code>uiItemBase::modifyZone</code> method is used to change the <code>uiItemBase</code> state at reception time, and <code>uiItemBase::reflectZone</code>will be called to reflect a new value, and can change the Widget layout for instance, or send a message (OSC, MIDI...). </p>
<p>All classes needing to use this synchronization mechanism will have to subclass the <code>GUI</code> class, which keeps all of them at runtime in a static class <code>GUI::fGuiList</code> variable. This is the case for the previously used <code>GTKUI</code> and <code>OSCUI</code> classes. Note that when using the <code>GUI</code> class, <strong>the 2 following static class variables have to be defined in the code,</strong> (once in one <code>.cpp</code> file in the project) like in this code example:</p>
<pre><code class="language-c++">// Globals
std::list&lt;GUI*&gt; GUI::fGuiList;
ztimedmap GUI::gTimedZoneMap;
</code></pre>
<p>Finally the static <code>GUI::updateAllGuis()</code> synchronization method will have to be called regularly, in the application or plugin event management loop, or in a periodic timer for instance. This is typically implemented in the <code>GUI::run</code> method which has to be called to start event or messages processing. </p>
<p>In the following code, the  <code>OSCUI::run</code>  method is called first to start processing OSC messages, then the blocking <code>GTKUI::run</code> method, which opens the GUI window, to be closed to finally finish the application:</p>
<pre><code class="language-c++">...
// Start OSC messages processing
osc_interface.run();
// Start GTK GUI as the last one, since it blocks until the opened window is closed
gtk_interface.run()
...
</code></pre>
<h2 id="dsp-architecture-modules">DSP Architecture Modules</h2>
<p>The Faust compiler produces a DSP module whose format will depend of the chosen backend: a C++ class with the <code>-lang cpp</code> option, a data structure with associated functions with the <code>-lang c</code> option, an LLVM IR module  with the <code>-lang llvm</code> option, a WebAssembly binary module with the <code>-lang wasm</code> option, a bytecode stream with the <code>-lang interp</code> option... and so on.</p>
<h3 id="the-base-dsp-class">The Base <code>dsp</code> Class</h3>
<p>In C++, the generated class derives from a base <code>dsp</code> class:</p>
<pre><code class="language-c++">class dsp {

public:

    dsp() {}
    virtual ~dsp() {}

    /* Return instance number of audio inputs */
    virtual int getNumInputs() = 0;

    /* Return instance number of audio outputs */
    virtual int getNumOutputs() = 0;

    /**
     * Trigger the ui_interface parameter with instance specific calls
     * to 'openTabBox', 'addButton', 'addVerticalSlider'... in order to build the UI.
     *
     * @param ui_interface - the user interface builder
     */
    virtual void buildUserInterface(UI* ui_interface) = 0;

    /* Return the sample rate currently used by the instance */
    virtual int getSampleRate() = 0;

    /**
     * Global init, calls the following methods:
     * - static class 'classInit': static tables initialization
     * - 'instanceInit': constants and instance state initialization
     *
     * @param sample_rate - the sampling rate in Hz
     */
    virtual void init(int sample_rate) = 0;

    /**
     * Init instance state
     *
     * @param sample_rate - the sampling rate in Hz
     */
    virtual void instanceInit(int sample_rate) = 0;

    /**
     * Init instance constant state
     *
     * @param sample_rate - the sampling rate in HZ
     */
    virtual void instanceConstants(int sample_rate) = 0;

    /* Init default control parameters values */
    virtual void instanceResetUserInterface() = 0;

    /* Init instance state (like delay lines..) but keep the control parameter values */
    virtual void instanceClear() = 0;

    /**
     * Return a clone of the instance.
     *
     * @return a copy of the instance on success, otherwise a null pointer.
     */
    virtual dsp* clone() = 0;

    /**
     * Trigger the Meta* parameter with instance specific calls to 'declare' 
     * (key, value) metadata.
     *
     * @param m - the Meta* meta user
     */
    virtual void metadata(Meta* m) = 0;

    /**
     * DSP instance computation, to be called with successive in/out audio buffers.
     *
     * @param count - the number of frames to compute
     * @param inputs - the input audio buffers as an array of non-interleaved 
     * FAUSTFLOAT samples (eiher float, double or quad)
     * @param outputs - the output audio buffers as an array of non-interleaved 
     * FAUSTFLOAT samples (eiher float, double or quad)
     *
     */
    virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) = 0;

    /**
     * Alternative DSP instance computation method for use by subclasses, incorporating an additional `date_usec` parameter,
     * which specifies the timestamp of the first sample in the audio buffers.
     *
     * @param date_usec - the timestamp in microsec given by audio driver. By convention timestamp of -1 means 'no timestamp conversion',
     * events already have a timestamp expressed in frames.
     * @param count - the number of frames to compute
     * @param inputs - the input audio buffers as an array of non-interleaved 
     * FAUSTFLOAT samples (either float, double or quad)
     * @param outputs - the output audio buffers as an array of non-interleaved 
     * FAUSTFLOAT samples (either float, double or quad)
     *
     */
    virtual void compute(double date_usec, int count, 
                         FAUSTFLOAT** inputs, 
                         FAUSTFLOAT** outputs) = 0;
};
</code></pre>
<p>The dsp class is central to the Faust architecture design:</p>
<ul>
<li>the <code>getNumInputs</code>, <code>getNumOutputs</code> methods provides information about the signal processor</li>
<li>the<code>buildUserInterface</code> method creates the user interface using a given UI class object (see later)</li>
<li>the<code>init</code> method (and some more specialized methods like <code>instanceInit</code>, <code>instanceConstants</code>, etc.) is called to initialize the dsp object with a given sampling rate, typically obtained from the audio architecture</li>
<li>the<code>compute</code> method is called by the audio architecture to execute the actual audio processing. It takes a <code>count</code> number of samples to process, and <code>inputs</code> and <code>outputs</code> arrays of non-interleaved float/double samples, to be allocated and handled by the audio driver with the required dsp input and outputs channels (as given by  <code>getNumInputs</code> and <code>getNumOutputs</code>)</li>
<li>the <code>clone</code> method can be used to duplicate the instance</li>
<li>the<code>metadata(Meta* m)</code>method can be called with a <code>Meta</code> object to decode the instance global metadata (see next section)</li>
</ul>
<p>(note that <code>FAUSTFLOAT</code> label is typically defined to be the actual type of sample: either <code>float</code> or <code>double</code> using <code>#define FAUSTFLOAT float</code> in the code for instance).</p>
<p>For a given compiled DSP program, the compiler will generate a <code>mydsp</code> subclass of <code>dsp</code> and fill the different methods. For dynamic code producing backends like the LLVM IR, Cmajor or the Interpreter ones, the actual code (an LLVM module, a Cmajor module or a bytecode stream) is actually wrapped by some additional C++ code glue, to finally produces an <code>llvm_dsp</code> typed object (defined in the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/llvm-dsp.h">llvm-dsp.h</a> file), a <code>cmajorpatch_dsp</code> typed object (defined in the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/cmajorpatch-dsp.h">cmajorpatch-dsp.h</a> file) or an <code>interpreter_dsp</code> typed object (defined in <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/interpreter-dsp.h">interpreter-dsp.h</a> file), ready to be used  with the <code>UI</code> and <code>audio</code> C++ classes (like the C++ generated class). See the following class diagram:</p>
<p><img src="img/DSPHierarchy.png" class="mx-auto d-block" width="85%"></p>
<h3 id="changing-the-generated-class-name">Changing the generated class name</h3>
<p>By default, the generated class is <code>mydsp</code>, but can be changed using the <code>-cn new_name</code> option. Note that any <code>mydsp</code> string used in the architecture class will be automatically replaced by the <code>new_name</code> string. Thus other sections of the architecture file can possibly adapt using the <code>-cn new_name</code> renaming feature.</p>
<h3 id="global-dsp-metadata">Global DSP metadata</h3>
<p>All global metadata declaration in Faust start with <code>declare</code>, followed by a key and a string. For example:</p>
<pre><code>declare name &quot;Noise&quot;;
</code></pre>
<p>allows us to specify the name of a Faust program in its whole. </p>
<p>Unlike regular comments, metadata declarations will appear in the C++ code generated by the Faust compiler, for instance the Faust program:</p>
<pre><code>declare name &quot;NoiseProgram&quot;;
declare author &quot;MySelf&quot;;
declare copyright &quot;MyCompany&quot;;
declare version &quot;1.00&quot;;
declare license &quot;BSD&quot;; 

import(&quot;stdfaust.lib&quot;);

process = no.noise;
</code></pre>
<p>will generate the following C++ <code>metadata(Meta* m)</code> method in the dsp class:</p>
<pre><code class="language-c++">void metadata(Meta* m) 
{ 
    m-&gt;declare(&quot;author&quot;, &quot;MySelf&quot;);
    m-&gt;declare(&quot;compile_options&quot;, &quot;-lang cpp -es 1 -scal -ftz 0&quot;);
    m-&gt;declare(&quot;copyright&quot;, &quot;MyCompany&quot;);
    m-&gt;declare(&quot;filename&quot;, &quot;metadata.dsp&quot;);
    m-&gt;declare(&quot;license&quot;, &quot;BSD&quot;);
    m-&gt;declare(&quot;name&quot;, &quot;NoiseProgram&quot;);
    m-&gt;declare(&quot;noises.lib/name&quot;, &quot;Faust Noise Generator Library&quot;);
    m-&gt;declare(&quot;noises.lib/version&quot;, &quot;0.0&quot;);
    m-&gt;declare(&quot;version&quot;, &quot;1.00&quot;);
}
</code></pre>
<p>which interacts with an instance of an implementation class of the following virtual <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/meta.h">Meta</a> class:</p>
<pre><code class="language-c++">struct Meta
{
    virtual ~Meta() {};
    virtual void declare(const char* key, const char* value) = 0;
};
</code></pre>
<p>and are part of three different types of global metadata:</p>
<ul>
<li>metadata like<code>compile_options</code> or <code>filename</code> are automatically generated </li>
<li>metadata like <code>author</code> of <code>copyright</code>are part of the <a href="../syntax/#global-metadata">Global Medata</a></li>
<li>metadata like<code>noises.lib/name</code>are part of the <a href="../syntax/#function-metadata">Function Metadata</a></li>
</ul>
<p>Specialized subclasses of the<code>Meta</code> class can be implemented to decode the needed key/value pairs for a given use-case. </p>
<h3 id="macro-construction-of-dsp-components">Macro Construction of DSP Components</h3>
<p>The Faust program specification is usually entirely done in the language itself. But in some specific cases it may be useful to develop <em>separated DSP components</em> and <em>combine</em> them in a more complex setup.</p>
<p>Since taking advantage of the huge number of already available UI and audio architecture files is important, keeping the same <code>dsp</code> API is preferable, so that more complex DSP can be controlled and audio rendered the usual way. Extended DSP classes will typically subclass the <code>dsp</code> base class and override or complete part of its API. </p>
<h4 id="dsp-decorator-pattern">DSP Decorator Pattern</h4>
<p>A <code>dsp_decorator</code> class, subclass of the root <code>dsp</code> class has first been defined. Following the decorator design pattern, it allows behavior to be added to an individual object, either statically or dynamically.</p>
<p>As an example of the decorator pattern, the <code>timed_dsp</code> class allows to decorate a given DSP with sample accurate control capability or the <code>mydsp_poly</code> class for polyphonic DSPs, explained in the next sections.</p>
<h4 id="combining-dsp-components">Combining DSP Components</h4>
<p>A few additional macro construction classes, subclasses of the root dsp class have been defined in the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/dsp-combiner.h">dsp-combiner.h</a>  header file with a five operators construction API:</p>
<ul>
<li>the <code>dsp_sequencer</code> class combines two DSP in sequence, assuming that the number of outputs of the first DSP equals the number of input of the second one. It somewhat mimics the  <em>sequence</em> (that is<code>:</code> ) operator of the language by combining two separated C++ objects. Its <code>buildUserInterface</code> method is overloaded to group the two DSP in a tabgroup, so that control parameters of both DSPs can be individually controlled. Its <code>compute</code> method is overloaded to call each DSP <code>compute</code> in sequence, using an intermediate output buffer produced by first DSP as the input one given to the second DSP.</li>
<li>the <code>dsp_parallelizer</code>  class combines two DSP in parallel. It somewhat mimics the  <em>parallel</em> (that is<code>,</code> ) operator of the language by combining two separated C++ objects. Its <code>getNumInputs/getNumOutputs</code> methods are overloaded by correctly reflecting the input/output of the resulting DSP as the sum of the two combined ones. Its <code>buildUserInterface</code> method is overloaded to group the two DSP in a tabgroup, so that control parameters of both DSP can be individually controlled. Its <code>compute</code> method is overloaded to call each DSP compute, where each DSP consuming and producing its own number of input/output audio buffers taken from the method parameters.</li>
</ul>
<p>This methology is followed to implement the three remaining composition operators (<em>split</em>, <em>merge</em>, <em>recursion</em>), which ends up with a C++ API to combine DSPs with the usual five operators: <code>createDSPSequencer</code>, <code>createDSPParallelizer</code>, <code>createDSPSplitter</code>, <code>createDSPMerger</code>, <code>createDSPRecursiver</code> to be used at C++ level to dynamically combine DSPs.</p>
<p>And finally the <code>createDSPCrossfader</code> tool allows you to crossfade between two DSP modules. The crossfade parameter (as a slider) controls the mix between the two modules outputs. When <em>Crossfade = 1</em>, the first DSP only is computed, when <em>Crossfade = 0</em>, the second DSP only is computed, otherwise both DSPs are computed and mixed.</p>
<p>Note that this idea of decorating or combining several C++ <code>dsp</code> objects can perfectly be extended in specific projects, to meet other needs: like muting some part of a graph of several DSPs for instance. But keep in mind that keeping the <code>dsp</code> API then allows to take profit of all already available <code>UI</code> and <code>audio</code> based classes.</p>
<h3 id="sample-accurate-control">Sample Accurate Control</h3>
<p>DSP audio languages usually deal with several timing dimensions when treating control events and generating audio samples. For performance reasons, systems maintain separated audio rate for samples generation and control rate for asynchronous messages handling.</p>
<p>The audio stream is most often computed by blocks, and control is updated between blocks. To smooth control parameter changes, some languages chose to interpolate parameter values between blocks.</p>
<p>In some cases control may be more finely interleaved with audio rendering, and some languages simply choose to interleave control and sample computation at sample level.</p>
<p>Although the Faust language permits the description of sample level algorithms (i.e., like recursive filters, etc.), Faust generated DSP are usually computed by blocks. Underlying audio architectures give a fixed size buffer over and over to the DSP <code>compute</code> method which consumes and produces audio samples.</p>
<h4 id="control-to-dsp-link">Control to DSP Link</h4>
<p>In the current version of the Faust generated code, the primary connection point between the control interface and the DSP code is simply a memory zone. For control inputs, the architecture layer continuously write values in this zone, which is then <em>sampled</em> by the DSP code at the beginning of the <code>compute</code> method, and used with the same values throughout the call. Because of this simple control/DSP connexion mechanism, the <em>most recent value</em> is used by the DSP code.</p>
<p>Similarly for control outputs , the DSP code inside the <code>compute</code> method possibly writes several values at the same memory zone, and the <em>last value</em> only will be seen by the control architecture layer when the method finishes.</p>
<p>Although this behaviour is satisfactory for most use-cases, some specific usages need to handle the complete stream of control values with sample accurate timing. For instance keeping all control messages and handling them at their exact position in time is critical for proper MIDI clock synchronisation.</p>
<h4 id="timestamped-control">Timestamped Control</h4>
<p>The first step consists in extending the architecture control mechanism to deal with <em>timestamped</em> control events. Note that this requires the underlying event control layer to support this capability. The native MIDI API for instance is usually able to deliver timestamped MIDI messages.</p>
<p>The next step is to keep all timestamped events in a <em>time ordered</em> data structure to be continuously written by the control side, and read by the audio side.</p>
<p>Finally the sample computation has to take account of all queued control events, and correctly change the DSP control state at successive points in time.</p>
<h4 id="slices-based-dsp-computation">Slices Based DSP Computation</h4>
<p>With timestamped control messages, changing control values at precise sample indexes on the audio stream becomes possible. A generic <em>slices based</em> DSP rendering strategy has been implemented in the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/timed-dsp.h">timed_dsp</a> class.</p>
<p>A ring-buffer is used to transmit the stream of timestamped events from the control layer to the DSP one. In the case of MIDI control for instance, the ring-buffer is written with a pair containing the timestamp expressed in samples (or microseconds) and the actual MIDI message each time one is received. In the DSP compute method, the ring-buffer will be read to handle all messages received during the previous audio block.</p>
<p>Since control values can change several times inside the same audio block, the DSP compute cannot be called only once with the total number of frames and the complete inputs/outputs audio buffers. The following strategy has to be used:</p>
<ul>
<li>several slices are defined with control values changing between consecutive slices</li>
<li>all control values having the same timestamp are handled together, and change the DSP control internal state. The slice is computed up to the next control parameters timestamp until the end of the given audio block is reached</li>
<li>in the next figure, four slices with the sequence of c1, c2, c3, c4 frames are successively given to the DSP compute method, with the appropriate part of the audio input/output buffers. Control values (appearing here as <em>[v1,v2,v3]</em>, then <em>[v1,v3]</em>, then <em>[v1]</em>, then <em>[v1,v2,v3]</em> sets) are changed between slices</li>
</ul>
<p><img src="img/compute_slices.png" class="mx-auto d-block" width="60%"></p>
<p>Since timestamped control messages from the previous audio block are used in the current block, control messages are aways handled with one audio buffer latency.</p>
<p>Note that this slices based computation model can always be directly implemented on top of the underlying audio layer, without relying on the <code>timed_dsp</code> wrapper class. </p>
<h4 id="audio-driver-timestamping">Audio driver timestamping</h4>
<p>Some audio drivers can get the timestamp of the first sample in the audio buffers, and will typically call the DSP alternative <code>compute(double date_usec, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)</code> function with the correct timestamp. By convention timestamp of -1 means <em>'no timestamp conversion', events already have a timestamp expressed in frames</em> (see <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/audio/jack-dsp.h">jackaudio_midi</a> for an example driver using timestamp expressed in frames). The <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/timed-dsp.h">timed_dsp</a> wrapper class is an example of a DSP class actually using the timestamp information.</p>
<h4 id="typical-use-case">Typical Use-Case</h4>
<p>A typical Faust program can use the <em>MIDI clock</em> command signal to possibly compute the Beat Per Minutes (BPM) information for any synchronization need it may have. </p>
<p>Here is a simple example of a sinusoid generated which a frequency controlled by the MIDI clock stream, and starting/stopping when receiving the MIDI start/stop messages:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);

// square signal (1/0), changing state
// at each received clock
clocker = checkbox(&quot;MIDI clock[midi:clock]&quot;);

// ON/OFF button controlled
// with MIDI start/stop messages
play = checkbox(&quot;On/Off [midi:start][midi:stop]&quot;);

// detect front
front(x) = (x-x’) != 0.0;

// count number of peaks during one second
freq(x) = (x-x@ma.SR) : + ~ _;

process = os.osc(8*freq(front(clocker))) * play;
</code></pre>
<p>Each received group of 24 clocks will move the time position by exactly one beat. Then it is <em>absolutely mandatory to never loose any MIDI clock message</em> and the standard memory zone based model with the <em>use the last received control value semantic</em> is not adapted. </p>
<p>The DSP object that needs to be controlled using the sample-accurate machinery can then simply be decorated using the<code>timed_dsp</code> class with the following kind of code:</p>
<pre><code class="language-c++">dsp* sample_accurate_dsp = new timed_dsp(DSP);
</code></pre>
<p>Note that the described sample accurate MIDI clock synchronization model can currently only be used at input level. Because of the simple memory zone based connection point between the control interface and the DSP code, output controls (like bargraph) cannot generate a stream of control values. <em>Thus a reliable MIDI clock generator cannot be implemented with the current approach.</em></p>
<h3 id="polyphonic-instruments">Polyphonic Instruments</h3>
<p>Directly programing polyphonic instruments in Faust is perfectly possible. It is also needed if very complex signal interaction between the different voices have to be described.</p>
<p>But since all voices would always be computed, this approach could be too CPU costly for simpler or more limited needs. In this case describing a single voice in a Faust DSP program and externally combining several of them with a special polyphonic instrument aware architecture file is a better solution. Moreover, this special architecture file takes care of dynamic voice allocations and control MIDI messages decoding and mapping.</p>
<h4 id="polyphonic-ready-dsp-code">Polyphonic ready DSP Code</h4>
<p>By convention Faust architecture files with polyphonic capabilities expect to find control parameters named <code>freq</code>, <code>gain</code>, and <code>gate</code>. The metadata <code>declare nvoices "8";</code> kind of line with a desired value of voices can be added in the source code.</p>
<p>In the case of MIDI control, the freq parameter (which should be a frequency) will be automatically computed from MIDI note numbers, gain (which should be a value between 0 and 1) from velocity and gate from keyon/keyoff events. Thus, gate can be used as a trigger signal for any envelope generator, etc.</p>
<h4 id="using-the-mydsp_poly-class">Using the mydsp_poly Class</h4>
<p>The single voice has to be described by a Faust DSP program, the <code>mydsp_poly</code> class is then used to combine several voices and create a polyphonic ready DSP:</p>
<ul>
<li>the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/poly-dsp.h">poly-dsp.h</a> file contains the definition of the <code>mydsp_poly</code> class used to wrap the DSP voice into the polyphonic architecture. This class maintains an array of <code>dsp*</code>objects, manage dynamic voice allocation, control MIDI messages decoding and mapping, mixing of all running voices, and stopping a voice when its output level decreases below a given threshold</li>
<li>as a subclass of DSP, the <code>mydsp_poly</code> class redefines the <code>buildUserInterface</code> method. By convention all allocated voices are grouped in a global  <em>Polyphonic</em> tabgroup. The first tab contains a <em>Voices</em> group, a master like component used to change parameters on all voices at the same time, with a <em>Panic</em> button to be used to stop running voices, followed by one tab for each voice. Graphical User Interface components will then reflect the multi-voices structure of the new polyphonic DSP </li>
</ul>
<p><img src="img/poly_ui.png" class="mx-auto d-block" width="35%"></p>
<p>The resulting polyphonic DSP object can be used as usual, connected with the needed audio driver, and possibly other <code>UI</code> control objects like <code>OSCUI</code>, <code>httpdUI</code>, etc. Having this new UI hierarchical view allows complete OSC control of each single voice and their control parameters, but also all voices using the master component.</p>
<p>The following OSC messages reflect the same DSP code either compiled normally, or in polyphonic mode (only part of the OSC hierarchies are displayed here):</p>
<pre><code>// Mono mode

/Organ/vol f -10.0
/Organ/pan f 0.0
</code></pre>
<pre><code>// Polyphonic mode

/Polyphonic/Voices/Organ/pan f 0.0
/Polyphonic/Voices/Organ/vol f -10.0
...
/Polyphonic/Voice1/Organ/vol f -10.0
/Polyphonic/Voice1/Organ/pan f 0.0
...
/Polyphonic/Voice2/Organ/vol f -10.0
/Polyphonic/Voice2/Organ/pan f 0.0
</code></pre>
<p>Note that to save space on the screen, the<code>/Polyphonic/VoiceX/xxx</code> syntax is used when the number of allocated voices is less than 8, then the<code>/Polyphonic/VX/xxx</code> syntax is used when more voices are used.</p>
<p>The polyphonic instrument allocation takes the DSP to be used for one voice, the desired number of voices, the dynamic voice allocation state, and the group state which controls if separated voices are displayed or not:</p>
<pre><code class="language-c++">dsp* poly = new mydsp_poly(dsp, 2, true, true);
</code></pre>
<p>With the following code, note that a polyphonic instrument may be used outside of a MIDI control context, so that all voices will be always running and possibly controlled with OSC messages for instance:</p>
<pre><code class="language-c++">dsp* poly = new mydsp_poly(dsp, 8, false, true);
</code></pre>
<h4 id="polyphonic-instrument-with-a-global-output-effect">Polyphonic Instrument With a Global Output Effect</h4>
<p>Polyphonic instruments may be used with an output effect. Putting that effect in the main Faust code is generally not a good idea since it would be instantiated for each voice which would be very inefficient. </p>
<p>A convention has been defined to use the <code>effect = some effect;</code> line in the DSP source code. The actual effect definition has to be extracted from the DSP code, compiled separately, and then combined using the <code>dsp_sequencer</code> class previously presented to connect the polyphonic DSP in sequence with a unique global effect, with something like:</p>
<pre><code class="language-c++">dsp* poly = new dsp_sequencer(new mydsp_poly(dsp, 2, true, true), new effect());
</code></pre>
<p><img src="img/poly_ui_effect1.png" class="mx-auto d-block" width="30%">| <img src="img/poly_ui_effect2.png" class="mx-auto d-block" width="30%"></p>
<p>Some helper classes like the base <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/poly-dsp.h#L897">dsp_poly_factory</a> class, and concrete implementations  <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/poly-llvm-dsp.h">llvm_dsp_poly_factory</a> when using the LLVM backend or <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/poly-interpreter-dsp.h">interpreter_dsp_poly_factory</a> when using the Interpreter backend can also be used to automatically handle the voice and effect part of the DSP.</p>
<h4 id="controlling-the-polyphonic-instrument">Controlling the Polyphonic Instrument</h4>
<p>The <code>mydsp_poly</code> class is also ready for MIDI control (as a class implementing the <code>midi</code> interface) and can react to <code>keyOn/keyOff</code> and <code>pitchWheel</code> events. Other MIDI control parameters can directly be added in the DSP source code as MIDI metadata. To receive MIDI events, the created polyphonic DSP will be automatically added to the <code>midi_handler</code> object when calling <code>buildUserInterface</code> on a <code>MidiUI</code> object.</p>
<h4 id="deploying-the-polyphonic-instrument">Deploying the Polyphonic Instrument</h4>
<p>Several architecture files and associated scripts have been updated to handle polyphonic instruments:</p>
<p>As an example on OSX, the script <code>faust2caqt foo.dsp</code> can be used to create a polyphonic CoreAudio/QT application. The desired number of voices is either declared in a <code>nvoices</code> metadata or changed with the <code>-nvoices num</code> additional parameter. MIDI control is activated using the <code>-midi</code> parameter.</p>
<p>The number of allocated voices can possibly be changed at runtime using the<code>-nvoices</code> parameter to change the default value (so using <code>./foo -nvoices 16</code> for instance). Several other scripts have been adapted using the same conventions.</p>
<pre><code>faustcaqt -midi -noices 12 inst.dsp -effect effect.dsp
</code></pre>
<p>with <code>inst.dsp</code> and <code>effect.dsp</code> in the same folder, and the number of outputs of the instrument matching the number of inputs of the effect, has to be used. </p>
<p>Polyphonic ready <code>faust2xx</code> scripts will then compile the polyphonic instrument and the effect, combine them in sequence, and create a ready-to-use DSP.</p>
<h3 id="custom-memory-manager">Custom Memory Manager</h3>
<p>In C and C++, the Faust compiler produces a class (or a struct in C), to be instantiated to create each DSP instance. The standard generation model produces a flat memory layout, where all fields (scalar and arrays) are simply consecutive in the generated code (following the compilation order). So the DSP is allocated on a single block of memory, either on the stack or the heap depending on the use-case. The following DSP program:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);

gain = hslider(&quot;gain&quot;, 0.5, 0, 1, 0.01);
feedback = hslider(&quot;feedback&quot;, 0.8, 0, 1, 0.01);

echo(del_sec, fb, g) = + ~ de.delay(50000, del_samples) * fb * g
with {
    del_samples = del_sec * ma.SR;
};

process = echo(1.6, 0.6, 0.7), echo(0.7, feedback, gain);
</code></pre>
<p>will have the flat memory layout:</p>
<pre><code class="language-c++">int IOTA0;
int fSampleRate;
int iConst1;
float fRec0[65536];
FAUSTFLOAT fHslider0;
FAUSTFLOAT fHslider1;
int iConst2;
float fRec1[65536];
</code></pre>
<p>So scalar <code>fHslider0</code> and <code>fHslider1</code> correspond to the gain and feedback controllers. The <code>iConst1</code> and <code>iConst2</code> values are typically computed once at init time using the dynamically given the <code>fSampleRate</code> value, and used in the DSP loop later on. The <code>fRec0</code> and <code>fRec1</code> arrays are used for the recursive delays and finally the shared <code>IOTA0</code> index is used to access them.</p>
<p>Here is the generated <code>compute</code> function:</p>
<pre><code class="language-c++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
    FAUSTFLOAT* input0 = inputs[0];
    FAUSTFLOAT* input1 = inputs[1];
    FAUSTFLOAT* output0 = outputs[0];
    FAUSTFLOAT* output1 = outputs[1];
    float fSlow0 = float(fHslider0) * float(fHslider1);
    for (int i0 = 0; i0 &lt; count; i0 = i0 + 1) {
        fRec0[IOTA0 &amp; 65535] 
            = float(input0[i0]) + 0.419999987f * fRec0[(IOTA0 - iConst1) &amp; 65535];
        output0[i0] = FAUSTFLOAT(fRec0[IOTA0 &amp; 65535]);
        fRec1[IOTA0 &amp; 65535] 
            = float(input1[i0]) + fSlow0 * fRec1[(IOTA0 - iConst2) &amp; 65535];
        output1[i0] = FAUSTFLOAT(fRec1[IOTA0 &amp; 65535]);
        IOTA0 = IOTA0 + 1;
    }
}
</code></pre>
<h4 id="the-mem-option">The -mem option</h4>
<p>On audio boards where the memory is separated as several blocks (like SRAM, SDRAM…) with different access time, it becomes important to refine the DSP memory model so that the DSP structure will not be allocated on a single block of memory, but possibly distributed on all available blocks. The idea is then to allocate parts of the DSP that are often accessed in fast memory and the other ones in slow memory. </p>
<p>The first remark is that scalar values will typically stay in the DSP structure, and the point is to move the big array buffers (<code>fRec0</code> and <code>fRec1</code> in the example) into separated memory blocks. The <code>-mem (--memory-manager)</code> option can be used to generate adapted code. On the previous DSP program, we now have the following generated C++ code: </p>
<pre><code class="language-c++">int IOTA0;
int fSampleRate;
int iConst1;
float* fRec0;
FAUSTFLOAT fHslider0;
FAUSTFLOAT fHslider1;
int iConst2;
float* fRec1;
</code></pre>
<p>The two <code>fRec0</code> and <code>fRec1</code> arrays are becoming pointers, and will be allocated elsewhere. </p>
<p>An external memory manager is needed to interact with the DSP code. The proposed model does the following:</p>
<ul>
<li>in a first step the generated C++ code will inform the memory allocator about its needs in terms of 1) number of separated memory zones, with 2) their size 3) access characteristics, like number of Read and Write for each frame computation. This is done be generating an additional  static <code>memoryInfo</code> method </li>
<li>with the complete information available, the memory manager can then define the best strategy to allocate all separated memory zones</li>
<li>an additional <code>memoryCreate</code> method  is generated to allocate each of the separated zones</li>
<li>an additional <code>memoryDestroy</code> method  is generated to deallocate each of the separated zones</li>
</ul>
<p>Here is the API for the memory manager:</p>
<pre><code class="language-c++">struct dsp_memory_manager {

    virtual ~dsp_memory_manager() {}

    /**
    * Inform the Memory Manager with the number of expected memory zones.
    * @param count - the number of memory zones
    */
    virtual void begin(size_t count);

    /**
    * Give the Memory Manager information on a given memory zone.
    * @param size - the size in bytes of the memory zone
    * @param reads - the number of Read access to the zone used to compute one frame
    * @param writes - the number of Write access to the zone used to compute one frame
    */
    virtual void info(size_t size, size_t reads, size_t writes) {}

    /**
    * Inform the Memory Manager that all memory zones have been described, 
    * to possibly start a 'compute the best allocation strategy' step.
    */
    virtual void end();

    /**
    * Allocate a memory zone.
    * @param size - the memory zone size in bytes
    */
    virtual void* allocate(size_t size) = 0;

    /**
    * Destroy a memory zone.
    * @param ptr - the memory zone pointer to be deallocated
    */
    virtual void destroy(void* ptr) = 0;

};
</code></pre>
<p>A class static member is added in the <code>mydsp</code> class, to be set with an concrete memory manager later on: </p>
<pre><code class="language-c++">dsp_memory_manager* mydsp::fManager = nullptr;
</code></pre>
<p>The C++ generated code now contains a new <code>memoryInfo</code> method, which interacts with the memory manager:</p>
<pre><code class="language-c++">static void memoryInfo() {
    fManager-&gt;begin(3);
    // mydsp
    fManager-&gt;info(56, 9, 1);
    // fRec0
    fManager-&gt;info(262144, 2, 1);
    // fRec1
    fManager-&gt;info(262144, 2, 1);
    fManager-&gt;end();
}
</code></pre>
<p>The <code>begin</code> method is first generated to inform that three separated memory zones will be needed. Then three consecutive calls to the <code>info</code> method are generated, one for the DSP object itself, one for each recursive delay array. The <code>end</code> method is then called to finish the memory layout description, and let the memory manager prepare the actual allocations. </p>
<p>Note that the memory layout information is also available in the JSON file generated using the <code>-json</code> option, to possibly be used statically by the architecture machinery (that is at compile time). With the previous program, the memory layout section is:</p>
<pre><code class="language-json">&quot;memory_layout&quot;: [
    { &quot;name&quot;: &quot;mydsp&quot;, &quot;type&quot;: &quot;kObj_ptr&quot;, &quot;size&quot;: 0, &quot;size_bytes&quot;: 56, &quot;read&quot;: 9, &quot;write&quot;: 1 },
    { &quot;name&quot;: &quot;IOTA0&quot;, &quot;type&quot;: &quot;kInt32&quot;, &quot;size&quot;: 1, &quot;size_bytes&quot;: 4, &quot;read&quot;: 7, &quot;write&quot;: 1 },
    { &quot;name&quot;: &quot;iConst1&quot;, &quot;type&quot;: &quot;kInt32&quot;, &quot;size&quot;: 1, &quot;size_bytes&quot;: 4, &quot;read&quot;: 1, &quot;write&quot;: 0 },
    { &quot;name&quot;: &quot;fRec0&quot;, &quot;type&quot;: &quot;kFloat_ptr&quot;, &quot;size&quot;: 65536, &quot;size_bytes&quot;: 262144, &quot;read&quot;: 2, &quot;write&quot;: 1 },
    { &quot;name&quot;: &quot;iConst2&quot;, &quot;type&quot;: &quot;kInt32&quot;, &quot;size&quot;: 1, &quot;size_bytes&quot;: 4, &quot;read&quot;: 1, &quot;write&quot;: 0 },
    { &quot;name&quot;: &quot;fRec1&quot;, &quot;type&quot;: &quot;kFloat_ptr&quot;, &quot;size&quot;: 65536, &quot;size_bytes&quot;: 262144, &quot;read&quot;: 2, &quot;write&quot;: 1 }
]
</code></pre>
<p>Finally the <code>memoryCreate</code> and <code>memoryDestroy</code> methods are generated. The <code>memoryCreate</code> method asks the memory manager to allocate the <code>fRec0</code> and <code>fRec1</code> buffers:</p>
<pre><code class="language-c++">void memoryCreate() {
    fRec0 = static_cast&lt;float*&gt;(fManager-&gt;allocate(262144));
    fRec1 = static_cast&lt;float*&gt;(fManager-&gt;allocate(262144));
}
</code></pre>
<p>And the <code>memoryDestroy</code> method asks the memory manager to destroy them:</p>
<pre><code class="language-c++">virtual memoryDestroy() {
    fManager-&gt;destroy(fRec0);
    fManager-&gt;destroy(fRec1);
}
</code></pre>
<p>Additional static <code>create/destroy</code> methods are generated:</p>
<pre><code class="language-c++">static mydsp* create() {
    mydsp* dsp = new (fManager-&gt;allocate(sizeof(mydsp))) mydsp();
    dsp-&gt;memoryCreate();
    return dsp;
}

static void destroy(dsp* dsp) {
    static_cast&lt;mydsp*&gt;(dsp)-&gt;memoryDestroy();
    fManager-&gt;destroy(dsp);
}
</code></pre>
<p>Note that the so-called <a href="https://en.wikipedia.org/wiki/Placement_syntax">C++ placement new</a> will be used to allocate the DSP object itself. </p>
<h4 id="static-tables">Static tables</h4>
<p>When <code>rdtable</code> or <code>rwtable</code> primitives are used in the source code, the C++ class will contain a table shared by all instances of the class. By default, this table is generated as a static class array, and so allocated in the application global static memory. </p>
<p>Taking the following DSP example:</p>
<pre><code>process = (waveform {10,20,30,40,50,60,70}, %(7)~+(3) : rdtable), 
          (waveform {1.1,2.2,3.3,4.4,5.5,6.6,7.7}, %(7)~+(3) : rdtable);
</code></pre>
<p>Here is the generated code in default mode:</p>
<pre><code class="language-c++">...
static int itbl0mydspSIG0[7];
static float ftbl1mydspSIG1[7];

class mydsp : public dsp {
  ...  
  public:
    ...
    static void classInit(int sample_rate) {
        mydspSIG0* sig0 = newmydspSIG0();
        sig0-&gt;instanceInitmydspSIG0(sample_rate);
        sig0-&gt;fillmydspSIG0(7, itbl0mydspSIG0);
        mydspSIG1* sig1 = newmydspSIG1();
        sig1-&gt;instanceInitmydspSIG1(sample_rate);
        sig1-&gt;fillmydspSIG1(7, ftbl1mydspSIG1);
        deletemydspSIG0(sig0);
        deletemydspSIG1(sig1);
    }

    virtual void init(int sample_rate) {
        classInit(sample_rate);
        instanceInit(sample_rate);
    }

    virtual void instanceInit(int sample_rate) {
        instanceConstants(sample_rate);
        instanceResetUserInterface();
        instanceClear();
    }
    ...
}
</code></pre>
<p>The two <code>itbl0mydspSIG0</code> and <code>ftbl1mydspSIG1</code> tables are static global arrays. They are filled in the <code>classInit</code> method. The architecture code will typically call the <code>init</code> method (which calls <code>classInit</code>) on a given DSP, to allocate class related arrays and the DSP itself. If several DSPs are going to be allocated, calling <code>classInit</code> only once then the <code>instanceInit</code> method on each allocated DSP is the way to go.</p>
<p>In the <code>-mem</code> mode, the generated C++ code is now:</p>
<pre><code class="language-c++">...
static int* itbl0mydspSIG0 = 0;
static float* ftbl1mydspSIG1 = 0;

class mydsp : public dsp {
  ...  
  public:
    ...
    static dsp_memory_manager* fManager;

    static void classInit(int sample_rate) {
        mydspSIG0* sig0 = newmydspSIG0(fManager);
        sig0-&gt;instanceInitmydspSIG0(sample_rate);
        itbl0mydspSIG0 = static_cast&lt;int*&gt;(fManager-&gt;allocate(28));
        sig0-&gt;fillmydspSIG0(7, itbl0mydspSIG0);
        mydspSIG1* sig1 = newmydspSIG1(fManager);
        sig1-&gt;instanceInitmydspSIG1(sample_rate);
        ftbl1mydspSIG1 = static_cast&lt;float*&gt;(fManager-&gt;allocate(28));
        sig1-&gt;fillmydspSIG1(7, ftbl1mydspSIG1);
        deletemydspSIG0(sig0, fManager);
        deletemydspSIG1(sig1, fManager);
    }

    static void classDestroy() {
        fManager-&gt;destroy(itbl0mydspSIG0);
        fManager-&gt;destroy(ftbl1mydspSIG1);
    }

    virtual void init(int sample_rate) {}

    virtual void instanceInit(int sample_rate) {
        instanceConstants(sample_rate);
        instanceResetUserInterface();
        instanceClear();
    }
    ...
}
</code></pre>
<p>The two <code>itbl0mydspSIG0</code> and <code>ftbl1mydspSIG1</code> tables are generated as static global pointers. The <code>classInit</code> method uses the <code>fManager</code> object used to allocate tables. A new <code>classDestroy</code> method is generated to deallocate the tables. Finally the <code>init</code> method is now empty, since the architecture file is supposed to use the <code>classInit/classDestroy</code> method once to allocate and deallocate static tables, and the <code>instanceInit</code> method on each allocated DSP.</p>
<p>The <code>memoryInfo</code> method now has the following shape, with the two <code>itbl0mydspSIG0</code> and <code>ftbl1mydspSIG1</code> tables:</p>
<pre><code class="language-c++">static void memoryInfo() {
    fManager-&gt;begin(6);
    // mydspSIG0
    fManager-&gt;info(4, 0, 0);
    // itbl0mydspSIG0
    fManager-&gt;info(28, 1, 0);
    // mydspSIG1
    fManager-&gt;info(4, 0, 0);
    // ftbl1mydspSIG1
    fManager-&gt;info(28, 1, 0);
    // mydsp
    fManager-&gt;info(28, 0, 0);
    // iRec0
    fManager-&gt;info(8, 3, 2);
    fManager-&gt;end();
}
</code></pre>
<h4 id="defining-and-using-a-custom-memory-manager">Defining and using a custom memory manager</h4>
<p>When compiled with the <code>-mem</code> option, the client code has to define an adapted <code>memory_manager</code> class for its specific needs. A cutom memory manager is implemented by subclassing the <code>dsp_memory_manager</code> abstract base class, and defining the <code>begin</code>, <code>end</code>, <code>ìnfo</code>, <code>allocate</code> and <code>destroy</code> methods. Here is an example of a simple heap allocating manager (implemented in the  <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/dummy-mem.cpp">dummy-mem.cpp</a> architecture file):</p>
<pre><code class="language-c++">struct malloc_memory_manager : public dsp_memory_manager {

    virtual void begin(size_t count)
    {
        // TODO: use ‘count’
    }

    virtual void end()
    {
        // TODO: start sorting the list of memory zones, to prepare 
        // for the future allocations done in memoryCreate()
    }

    virtual void info(size_t size, size_t reads, size_t writes)
    {
        // TODO: use 'size', ‘reads’ and ‘writes’
        // to prepare memory layout for allocation
    }

    virtual void* allocate(size_t size)
    {
        // TODO: refine the allocation scheme to take
        // in account what was collected in info
        return calloc(1, size);
    }

    virtual void destroy(void* ptr)
    {
        // TODO: refine the allocation scheme to take
        // in account what was collected in info
        free(ptr);
    }

};
</code></pre>
<p>The specialized <code>malloc_memory_manager</code> class can now be used the following way:</p>
<pre><code class="language-c++">// Allocate a global static custom memory manager
static malloc_memory_manager gManager;

// Setup the global custom memory manager on the DSP class
mydsp::fManager = &amp;gManager;

// Make the memory manager get information on all subcontainers,
// static tables, DSP and arrays and prepare memory allocation
mydsp::memoryInfo();

// Done once before allocating any DSP, to allocate static tables
mydsp::classInit(44100);

// ‘Placement new’ and 'memoryCreate' are used inside the ‘create’ method 
dsp* DSP = mydsp::create();

// Init the DSP instance
DSP-&gt;instanceInit(44100);

...
... // use the DSP
...

// 'memoryDestroy' and memory manager 'destroy' are used to deallocate memory
mydsp::destroy();

// Done once after the last DSP has been destroyed
mydsp::classDestroy();
</code></pre>
<p>Note that the client code can still choose to allocate/deallocate the DSP instance using the regular C++ <code>new/delete</code> operators:</p>
<pre><code class="language-c++">// Allocate a global static custom memory manager
static malloc_memory_manager gManager;

// Setup the global custom memory manager on the DSP class
mydsp::fManager = &amp;gManager;

// Make the memory manager get information on all subcontainers,
// static tables, DSP and arrays and prepare memory allocation
mydsp::memoryInfo();

// Done once before allocating any DSP, to allocate static tables
mydsp::classInit(44100);

// Use regular C++ new
dsp* DSP = new mydsp();

/// Allocate internal buffers
DSP-&gt;memoryCreate();

// Init the DSP instance
DSP-&gt;instanceInit(44100);

...
... // use the DSP
...

// Deallocate internal buffers
DSP-&gt;memoryDestroy();

// Use regular C++ delete
delete DSP;

// Done once after the last DSP has been destroyed
mydsp::classDestroy();
</code></pre>
<p>Or even on the stack with:</p>
<pre><code class="language-c++">...

// Allocation on the stack
mydsp DSP;

// Allocate internal buffers
DSP.memoryCreate();

// Init the DSP instance
DSP.instanceInit(44100);

...
... // use the DSP
...

// Deallocate internal buffers
DSP.memoryDestroy();

...
</code></pre>
<p>More complex custom memory allocators can be developed by refining this <code>malloc_memory_manager</code> example, possibly defining real-time memory allocators...etc... The <a href="https://www.rebeltech.org">OWL</a> architecture file uses a custom <a href="https://github.com/RebelTechnology/OwlProgram/blob/feature/faust-mem-priority/FaustSource/owl.cpp">OwlMemoryManager</a>.</p>
<h4 id="allocating-several-dsp-instances">Allocating several DSP instances</h4>
<p>In a multiple instances scheme, static data structures shared by all instances have to be allocated once at beginning using <code>mydsp::classInit</code>, and deallocated at the end using <code>mydsp::classDestroy</code>. Individual instances are then allocated with <code>mydsp::create()</code> and deallocated with <code>mydsp::destroy()</code>, possibly directly using regular <code>new/delete</code>, or using stack allocation as explained before.</p>
<h3 id="measuring-the-dsp-cpu">Measuring the DSP CPU</h3>
<p>The <code>measure_dsp</code> class defined in the <code>faust/dsp/dsp-bench.h</code> file allows to decorate a given DSP object and measure its <code>compute</code> method CPU consumption. Results are given in Megabytes/seconds (higher is better) and DSP CPU at 44,1 kHz. Here is a C++ code example of its use: </p>
<pre><code class="language-c++">static void bench(dsp* dsp, const string&amp; name)
{
    // Init the DSP
    dsp-&gt;init(48000);
    // Wraps it with a 'measure_dsp' decorator
    measure_dsp mes(dsp, 1024, 5);
    // Measure the CPU use
    mes.measure();
    // Returns the Megabytes/seconds and relative standard deviation values
    std::pair&lt;double, double&gt; res = mes.getStats(); 
    // Print the stats
    cout &lt;&lt; name &lt;&lt; &quot; MBytes/sec : &quot; &lt;&lt; res.first 
         &lt;&lt; &quot; &quot; &lt;&lt; &quot;(DSP CPU % : &quot; &lt;&lt; (mes.getCPULoad() * 100) &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
</code></pre>
<p>Defined in the <code>faust/dsp/dsp-optimizer.h</code> file, the <code>dsp_optimizer</code> class uses the libfaust library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU. Here is a C++ code example of its use: </p>
<pre><code class="language-c++">static void dynamic_bench(const string&amp; in_filename)
{
    // Init the DSP optimizer with the in_filename to compile 
    dsp_optimizer optimizer(in_filename, 0, nullptr, &quot;&quot;, 1024);
    // Discover the best set of parameters
    tuple&lt;double, double, double, TOption&gt; res = optimizer.findOptimizedParameters();
    cout &lt;&lt; &quot;Best value for '&quot; &lt;&lt; in_filename &lt;&lt; &quot;' is : &quot; 
         &lt;&lt; get&lt;0&gt;(res) &lt;&lt; &quot; MBytes/sec with &quot;;
    for (size_t i = 0; i &lt; get&lt;3&gt;(res).size(); i++) {
        cout &lt;&lt; get&lt;3&gt;(res)[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p>This class can typically be used in tools that help developers discover the best Faust compilation parameters for a given DSP program, like the <a href="../optimizing/#faustbench">faustbench</a> and <a href="../optimizing/#faustbench-llvm">faustbench-llvm</a> tools.</p>
<h3 id="the-proxy-dsp-class">The Proxy DSP Class</h3>
<p>In some cases, a DSP may run outside of the application or plugin context, like on another machine. The <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/proxy-dsp.h">proxy_dsp</a> class allows to create a proxy DSP that will be finally connected to the real one (using an OSC or HTTP based machinery for instance), and will reflect its behaviour. It uses the previously described  <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/JSONUIDecoder.h">JSONUIDecoder</a> class. Then the <code>proxy_dsp</code> can be used in place of the real DSP, and connected with <code>UI</code> controllers using the standard <code>buildUserInterface</code> to control it.  </p>
<p>The <a href="https://github.com/grame-cncm/faust/tree/master-dev/tools/benchmark">faust-osc-controller</a> tool demonstrates this capability using an OSC connection between the real DSP and its proxy. The <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/proxy-osc-dsp.h">proxy_osc_dsp</a> class implements a specialized <code>proxy_dsp</code> using the <a href="http://liblo.sourceforge.net">liblo</a> OSC library to connect to a OSC controllable DSP (which is using the <code>OSCUI</code> class and running in another context or machine). Then the <code>faust-osc-controller</code> program <a href="https://github.com/grame-cncm/faust/blob/master-dev/tools/benchmark/faust-osc-controller.cpp">creates a real GUI</a> (using <code>GTKUI</code> in this example) and have it control the remote DSP and reflect its dynamic state (like vumeter values coming back from the real DSP). </p>
<h2 id="embedded-platforms">Embedded Platforms</h2>
<p>Faust has been targeting an increasing number of embedded platforms for real-time audio signal processing applications in recent years. It can now be used to program microcontrollers (i.e., <a href="https://www.espressif.com/en">ESP32</a>, <a href="https://www.pjrc.com/teensy/">Teensy</a>, <a href="https://www.crowdsupply.com/ohmic/pico-dsp">Pico DSP</a> and <a href="https://www.electro-smith.com/daisy">Daisy</a>), mobile platforms, embedded Linux systems (i.e., <a href="https://bela.io">Bela</a> and <a href="elk audio dsp">Elk</a>),  Digital Signal Processors (DSPs), and more. Specialized <a href="https://ifc20.sciencesconf.org/321070">architecture files and faust2xx scripts</a> have been developed. </p>
<h4 id="metadata-naming-convention">Metadata Naming Convention</h4>
<p>A specific question arises when dealing with devices without or limited screen to display any GUI, and a set of physical knobs or buttons to be connected to control parameters. The standard way is then to use metadata in control labels. Since beeing able to <em>use the same DSP file on all devices</em> is always desirable, a common set of metadata has been defined:</p>
<ul>
<li><strong>[switch:N]</strong> is used to connect to switch buttons </li>
<li><strong>[knob:N]</strong> is used to connect to knobs </li>
</ul>
<p>A extended set of metadata will probably have to be progressively defined and standardized.</p>
<h4 id="using-the-uim-compiler-option">Using the <code>-uim</code> Compiler Option</h4>
<p>On embedded platforms with limited capabilities, using the <code>-uim</code> option can be helpful. The C/C++ generated code then contains a static description of several caracteristics of the DSP, like the number of <em>audio inputs/outputs</em>, the number of <em>controls inputs/outputs</em>, and <em>macros feed with the controls parameters (label, DSP field name, init, min, max, step)</em> that can be implemented in the architecture file for various needs. </p>
<p>For example the following DSP program:</p>
<pre><code>process = _*hslider(&quot;Gain&quot;, 0, 0, 1, 0.01) : hbargraph(&quot;Vol&quot;, 0, 1);
</code></pre>
<p>compiled with <code>faust -uim foo.dsp</code> gives this additional section:</p>
<pre><code>#ifdef FAUST_UIMACROS

#define FAUST_FILE_NAME "foo.dsp"
#define FAUST_CLASS_NAME "mydsp"
#define FAUST_INPUTS 1
#define FAUST_OUTPUTS 1
#define FAUST_ACTIVES 1
#define FAUST_PASSIVES 1

FAUST_ADDHORIZONTALSLIDER("Gain", fHslider0, 0.0f, 0.0f, 1.0f, 0.01f);
FAUST_ADDHORIZONTALBARGRAPH("Vol", fHbargraph0, 0.0f, 1.0f);

#define FAUST_LIST_ACTIVES(p) \
    p(HORIZONTALSLIDER, Gain, "Gain", fHslider0, 0.0f, 0.0f, 1.0f, 0.01f) \

#define FAUST_LIST_PASSIVES(p) \
    p(HORIZONTALBARGRAPH, Vol, "Vol", fHbargraph0, 0.0, 0.0f, 1.0f, 0.0) \

#endif
</code></pre>
<p>The <code>FAUST_ADDHORIZONTALSLIDER</code> or <code>FAUST_ADDHORIZONTALBARGRAPH</code> macros can then be implemented to do whatever is needed with the <code>Gain", fHslider0, 0.0f, 0.0f, 1.0f, 0.01f</code> and <code>"Vol", fHbargraph0, 0.0f, 1.0f</code> parameters respectively. </p>
<p>The more sophisticated <code>FAUST_LIST_ACTIVES</code> and <code>FAUST_LIST_PASSIVES</code> macros can possibly be used to call any <code>p</code> function (defined elsewhere in the architecture file) on each item. The <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/minimal-static.cpp">minimal-static.cpp</a> file demonstrates this feature.</p>
<h2 id="developing-a-new-architecture-file">Developing a New Architecture File</h2>
<p>Developing a new architecture file typically means writing a generic file, that will be populated with the actual output of the Faust compiler, in order to produce a complete file, ready-to-be-compiled as a standalone application or plugin.</p>
<p>The architecture to be used is specified at compile time with the <code>-a</code> option. It must contain the <code>&lt;&lt;includeIntrinsic&gt;&gt;</code> and <code>&lt;&lt;includeclass&gt;&gt;</code> lines that will be recognized by the Faust compiler, and replaced by the generated code. Here is an example in C++, but the same logic can be used with other languages producing textual outputs, like C, Cmajor, Rust or Dlang.</p>
<p>Look at the <code>minimal.cpp</code> example located in the architecture folder:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

#include &quot;faust/gui/PrintUI.h&quot;
#include &quot;faust/gui/meta.h&quot;
#include &quot;faust/audio/dummy-audio.h&quot;
#include &quot;faust/dsp/one-sample-dsp.h&quot;

// To be replaced by the compiler generated C++ class 

&lt;&lt;includeIntrinsic&gt;&gt;

&lt;&lt;includeclass&gt;&gt;

int main(int argc, char* argv[])
{
    mydsp DSP;
    std::cout &lt;&lt; &quot;DSP size: &quot; &lt;&lt; sizeof(DSP) &lt;&lt; &quot; bytes\n&quot;;

    // Activate the UI, here that only print the control paths
    PrintUI ui;
    DSP.buildUserInterface(&amp;ui);

    // Allocate the audio driver to render 5 buffers of 512 frames
    dummyaudio audio(5);
    audio.init(&quot;Test&quot;, static_cast&lt;dsp*&gt;(&amp;DSP));

    // Render buffers...
    audio.start();
    audio.stop();
}
</code></pre>
<p>Calling <code>faust -a minimal.cpp noise.dsp -o noise.cpp</code> will produce a ready to compile <code>noise.cpp</code> file:</p>
<pre><code class="language-c++">/* ------------------------------------------------------------
name: &quot;noise&quot;
Code generated with Faust 2.28.0 (https://faust.grame.fr)
Compilation options: -lang cpp -scal -ftz 0
------------------------------------------------------------ */

#ifndef  __mydsp_H__
#define  __mydsp_H__

#include &lt;iostream&gt;

#include &quot;faust/gui/PrintUI.h&quot;
#include &quot;faust/gui/meta.h&quot;
#include &quot;faust/audio/dummy-audio.h&quot;

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include &lt;algorithm&gt;
#include &lt;cmath&gt;

#ifndef FAUSTCLASS 
#define FAUSTCLASS mydsp
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

class mydsp : public dsp {

    private:

        FAUSTFLOAT fHslider0;
        int iRec0[2];
        int fSampleRate;

    public:

        void metadata(Meta* m) { 
            m-&gt;declare(&quot;filename&quot;, &quot;noise.dsp&quot;);
            m-&gt;declare(&quot;name&quot;, &quot;noise&quot;);
            m-&gt;declare(&quot;noises.lib/name&quot;, &quot;Faust Noise Generator Library&quot;);
            m-&gt;declare(&quot;noises.lib/version&quot;, &quot;0.0&quot;);
        }

        virtual int getNumInputs() {
            return 0;
        }
        virtual int getNumOutputs() {
            return 1;
        }

        static void classInit(int sample_rate) {
        }

        virtual void instanceConstants(int sample_rate) {
            fSampleRate = sample_rate;
        }

        virtual void instanceResetUserInterface() {
            fHslider0 = FAUSTFLOAT(0.5f);
        }

        virtual void instanceClear() {
            for (int l0 = 0; (l0 &lt; 2); l0 = (l0 + 1)) {
                iRec0[l0] = 0;
            }
        }

        virtual void init(int sample_rate) {
            classInit(sample_rate);
            instanceInit(sample_rate);
        }
        virtual void instanceInit(int sample_rate) {
            instanceConstants(sample_rate);
            instanceResetUserInterface();
            instanceClear();
        }

        virtual mydsp* clone() {
            return new mydsp();
        }

        virtual int getSampleRate() {
            return fSampleRate;
        }

        virtual void buildUserInterface(UI* ui_interface) {
            ui_interface-&gt;openVerticalBox(&quot;noise&quot;);
            ui_interface-&gt;addHorizontalSlider(&quot;Volume&quot;, &amp;fHslider0, 0.5, 0.0, 1.0, 0.001);
            ui_interface-&gt;closeBox();
        }

        virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
            FAUSTFLOAT* output0 = outputs[0];
            float fSlow0 = (4.65661287e-10f * float(fHslider0));
            for (int i = 0; (i &lt; count); i = (i + 1)) {
                iRec0[0] = ((1103515245 * iRec0[1]) + 12345);
                output0[i] = FAUSTFLOAT((fSlow0 * float(iRec0[0])));
                iRec0[1] = iRec0[0];
            }
        }

};

int main(int argc, char* argv[])
{
    mydsp DSP;
    std::cout &lt;&lt; &quot;DSP size: &quot; &lt;&lt; sizeof(DSP) &lt;&lt; &quot; bytes\n&quot;;

    // Activate the UI, here that only print the control paths
    PrintUI ui;
    DSP.buildUserInterface(&amp;ui);

    // Allocate the audio driver to render 5 buffers of 512 frames
    dummyaudio audio(5);
    audio.init(&quot;Test&quot;, &amp;DSP);

    // Render buffers...
    audio.start();
    audio.stop();
}

</code></pre>
<p>Generally, several files to connect to the audio layer, controller layer, and possibly other (MIDI, OSC...) have to be used. One of them is the main file and include the others. The <code>-i</code> option can be added to actually inline all <code>#include "faust/xxx/yyy"</code> headers (all files starting with <code>faust</code>) to produce a single self-contained unique file. Then a <code>faust2xxx</code> script has to be written to chain the Faust compilation step and the C++ compilation one (and possibly others). Look at the <a href="#developing-a-faust2xx-script">Developing a faust2xx Script</a> section.</p>
<h4 id="adapting-the-generated-dsp">Adapting the Generated DSP</h4>
<p>Developing the adapted C++ file may require <em>aggregating</em> the generated <code>mydsp</code> class (subclass of the <code>dsp</code> base class defined in <code>faust/dsp/dsp.h</code> header) in the specific class, so something like the following would have to be written:</p>
<pre><code class="language-c++">class my_class : public base_interface {

    private:

        mydsp fDSP;

    public:

        my_class()
        {
            // Do something specific
        }

        virtual ~my_class()
        {
            // Do something specific
        }

        // Do something specific

        void my_compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            // Do something specific

            // Call the fDSP 'compute'
            fDSP.compute(count, inputs, outputs);
        }

        // Do something specific
};
</code></pre>
<p>or <em>subclassing</em> and <em>extending it</em>, so writing something like:</p>
<pre><code class="language-c++">class my_class : public mydsp {

    private:

        // Do something specific

    public:

        my_class()
        {
            // Do something specific
        }

        virtual ~my_class()
        {
            // Do something specific
        }

        // Override the 'compute' method
        void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            // Do something specific

            // Call the inherited 'compute' 
            mydsp::compute(count, inputs, outputs);
        }

        // Do something specific
};
</code></pre>
<p>or <em>decorating</em> a DSP object using the <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>, which is already implemented in <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/dsp.h">this file</a>, and can possibly be sub-classed like:  </p>
<pre><code class="language-c++">class my_decorator : public decorator_dsp {

    private:

        // Do something specific

    public:

        my_decorator(dsp* dsp):decorator_dsp(dsp)
        {
            // Do something specific
        }


        virtual ~my_class()
        {
            // Do something specific
        }

        // Implementation of some of the methods

        // Override the 'instanceClear' method
        void instanceClear()
        {
            // Do something specific

            // Call the inherited 'instanceClear' 
            decorator_dsp::instanceClear();
        }

        // Override the 'compute' method
        void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs)
        {
            // Do something specific

            // Call the inherited 'compute' 
            decorator_dsp::compute(count, inputs, outputs);
        }

        // Do something specific
};

// Decorates a concrete instance
my_decorator DSP = new my_decorator(new mydsp());
...

</code></pre>
<h4 id="developing-new-ui-architectures">Developing New UI Architectures</h4>
<p>For really new architectures, the <code>UI</code> base class,  the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/DecoratorUI.h">GenericUI</a> helper class or the <code>GUI</code> class (described before), have to be subclassed. Note that a lot of classes presented in the <a href="#some-useful-ui-classes-and-tools-for-developers">Some useful UI classes for developers</a> section can also be subclassed or possibly enriched with additional code. </p>
<h4 id="developing-new-audio-architectures">Developing New Audio Architectures</h4>
<p>The <code>audio</code> base class has to be subclassed and each method implemented for the given audio hardware. In some cases the audio driver can adapt to the required number of DSP inputs/outputs (like the <a href="https://jackaudio.org">JACK</a> audio system for instance which can open any number of virtual audio ports). But in general, the number of hardware audio inputs/outputs may not exactly match the DSP ones. This is the responsability of the audio driver to adapt to this situation. The <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/dsp-adapter.h">dsp_adapter</a> <code>dsp</code> decorator can help in this case.</p>
<h4 id="developing-a-new-soundfile-loader">Developing a New Soundfile Loader</h4>
<p>Soundfiles are defined in the DSP program using the <a href="../syntax/#soundfile-primitive">soundfile primitive</a>. Here is a simple DSP program which uses a single <em>tango.wav</em> audio file and play it until its end:</p>
<pre><code>process = 0,_~+(1):soundfile(&quot;sound[url:{'tango.wav'}]&quot;,2):!,!,
</code></pre>
<p>The compiled C++ class has the following structure:</p>
<pre><code class="language-c++">class mydsp : public dsp {

    private:

    Soundfile* fSoundfile0;
    int iRec0[2];
    int fSampleRate;
....
</code></pre>
<p>with the <code>Soundfile* fSoundfile0;</code> field and <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/Soundfile.h">its definition</a>:</p>
<pre><code class="language-c++">struct Soundfile {
    void* fBuffers; // will correspond to a double** or float** pointer chosen at runtime
    int* fLength;   // length of each part (so fLength[P] contains the length in frames of part P)
    int* fSR;       // sample rate of each part (so fSR[P] contains the SR of part P)
    int* fOffset;   // offset of each part in the global buffer (so fOffset[P] contains the offset in frames of part P)
    int fChannels;  // max number of channels of all concatenated files
    int fParts;     // the total number of loaded parts
    bool fIsDouble; // keep the sample format (float or double)
};
</code></pre>
<p>The following <code>buildUserInterface</code> method in generated, containing a <code>addSoundfile</code> method called with the appropriate parameters extracted from the <code>soundfile("sound[url:{'tango.wav'}]",2)</code> piece of DSP code, to be used to load the <em>tango.wav</em> audio file and prepare the <code>fSoundfile0</code> field:</p>
<pre><code class="language-c++">virtual void buildUserInterface(UI* ui_interface) 
{
    ui_interface-&gt;openVerticalBox(&quot;tp0&quot;);
    ui_interface-&gt;addSoundfile(&quot;sound&quot;, &quot;{'tango.wav'}&quot;, &amp;fSoundfile0);
    ui_interface-&gt;closeBox();
}
</code></pre>
<p>The specialized <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/SoundUI.h">SoundUI</a> architecture file is then used to load the required soundfiles at DSP init time, by using a <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/Soundfile.h">SoundfileReader</a> object. It only implements the <code>addSoundfile</code> method which will load all needed audio files, create and fill the <code>fSoundfile0</code> object.</p>
<p>Different concrete implementations are already written, either using <a href="http://www.mega-nerd.com/libsndfile/">libsndfile</a> (with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/LibsndfileReader.h">LibsndfileReader.h</a> file), or <a href="https://juce.com">JUCE</a> (with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/JuceReader.h">JuceReader</a> file).</p>
<p>A new audio file loader can be written by subclassing the <code>SoundfileReader</code> class. A pure memory reader could be implemented for instance to load wavetables to be used as the<code>soundfile</code> URL list. Look at the template <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/MemoryReader.h">MemoryReader</a> class, as an example to be completed, with the following methods to be implemented:</p>
<pre><code class="language-c++">/**
* Check the availability of a sound resource.
*
* @param path_name - the name of the file, or sound resource identified this way
*
* @return true if the sound resource is available, false otherwise.
*/
virtual bool checkFile(const std::string&amp; path_name);

/**
* Get the channels and length values of the given sound resource.
*
* @param path_name - the name of the file, or sound resource identified this way
* @param channels - the channels value to be filled with the sound resource 
* number of channels
* @param length - the length value to be filled with the sound resource length in frames
*
*/
virtual void getParamsFile(const std::string&amp; path_name, int&amp; channels, int&amp; length);

/**
* Read one sound resource and fill the 'soundfile' structure accordingly
*
* @param path_name - the name of the file, or sound resource identified this way
* @param part - the part number to be filled in the soundfile
* @param offset - the offset value to be incremented with the actual 
* sound resource length in frames
* @param max_chan - the maximum number of mono channels to fill
*
*/
virtual void readFile(Soundfile* soundfile, 
                      const std::string&amp; path_name, 
                      int part, 
                      int&amp; offset, 
                      int max_chan);
</code></pre>
<p>Another example to look at is <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/WaveReader.h">WaveReader</a>.</p>
<p>The <code>SoundUI</code> architecture is then used the following way:</p>
<pre><code class="language-c++"> mydsp DSP;
 // Here using a compiled time chosen SoundfileReader 
 SoundUI* sound_interface = new SoundUI(); 
 DSP.buildUserInterface(sound_interface);
 ...
 run the DSP
 ...
 // Finally deallocate the sound_interface and associated Soundfile resources
 delete sound_interface;
</code></pre>
<p>The <code>SoundfileReader</code> object can be dynamically choosen by using an alternate version of the <code>SoundUI</code> constructor, possibly choosing the sample format to be <em>double</em> when the DSP code is compiled with the <code>-double</code> option:</p>
<pre><code class="language-c++"> mydsp DSP;
 // Here using a dynamically chosen custom MyMemoryReader 
 SoundfileReader* sound_reader = new MyMemoryReader(...);
 SoundUI* sound_interface = new SoundUI(&quot;&quot;, false, sound_reader, true);
 DSP.buildUserInterface(sound_interface);
 ...
 run the DSP
 ...
 // Finally deallocate the sound_interface and associated Soundfile resources
 delete sound_interface;
</code></pre>
<h2 id="other-languages-than-c">Other Languages Than C++</h2>
<p>Most of the architecture files have been developed in C++ over the years. Thus they are ready to be used with the C++ backend and the one that generate C++ wrapped modules (like the LLVM, Cmajor and Interpreter backends). For other languages, specific architecture files have to be written. Here is the current situation for other backends:</p>
<ul>
<li>the C backend needs additional <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/CGlue.h">CGlue.h</a> and <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/gui/CInterface.h">CInterface.h</a> files, with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/minimal.c">minimal-c</a> file as a simple console mode example using them</li>
<li>the Rust backend can be used with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/minimal.rs">minimal-rs</a> architecture, the more complex JACK <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/jack.rs">jack.rs</a> used in <code>faust2jackrust</code> script, or the PortAudio <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/portaudio.rs">portaudio.rs</a> used in <code>faust2portaudiorust</code> script</li>
<li>the experimental Dlang backend can be used with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/minimal.d">minimal.d</a> or the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/dplug.d">dplug.d</a> to generate <a href="https://dplug.org">DPlug</a> plugins with the <code>faust2dplug</code> script.</li>
<li>the <a href="https://julialang.org">Julia</a> backend can be used with the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/julia/minimal.jl">minimal.jl</a> architecture or the <a href="https://github.com/grame-cncm/faust/tree/master-dev/architecture/julia/audio">portaudio.jl</a> used in <code>faust2portaudiojulia</code> script.</li>
</ul>
<h2 id="the-faust2xx-scripts">The faust2xx Scripts</h2>
<h3 id="using-faust2xx-scripts">Using faust2xx Scripts</h3>
<p>The <code>faust2xx</code> scripts finally combine different architecture files to generate a ready-to-use application or plugin, etc... from a Faust DSP program. They typically combine the <em>generated DSP</em> with an <em>UI architecture</em> file and an <em>audio architecture</em> file. Most of the also have addition options like <code>-midi</code>, <code>-nvoices &lt;num&gt;</code>, <code>-effect &lt;auto|effect.dsp&gt;</code> or <code>-soundfile</code> to generate polyphonic instruments with or without effects, or audio file support. Look at the <a href="../tools/">following page</a> for a more complete description.  </p>
<h3 id="developing-a-faust2xx-script">Developing a faust2xx Script</h3>
<p>The <code>faust2xx</code> script are mostly written in <a href="https://fr.wikipedia.org/wiki/Bourne-Again_shell">bash</a> (but any scripting language can be used) and aims to produce a ready-to-use application, plugin, etc... from a DSP program. A <a href="https://github.com/grame-cncm/faust/blob/master-dev/tools/faust2appls/faust2minimal">faust2minimal</a> template script using the C++ backend, can be used to start the process.</p>
<p>The  helper scripts, <a href="https://github.com/grame-cncm/faust/blob/master-dev/tools/faust2appls/faustpath">faustpath</a>,  <a href="https://github.com/grame-cncm/faust/blob/master-dev/tools/faust2appls/faustoptflags">faustoptflags</a>, and <a href="https://github.com/grame-cncm/faust/blob/master-dev/tools/faust2appls/usage.sh">usage.sh</a> can be used to setup common variables: </p>
<pre><code class="language-bash"># Define some common paths
. faustpath

# Define compilation flags
. faustoptflags

# Helper file to build the 'help' option
. usage.sh

CXXFLAGS+=&quot; $MYGCCFLAGS&quot;  # So that additional CXXFLAGS can be used

# The architecture file name
ARCHFILE=$FAUSTARCH/minimal.cpp

# Global variables
OPTIONS=&quot;&quot;
FILES=&quot;&quot;
</code></pre>
<p>The script arguments then have to be analysed, compiler options are kept in the <code>OPTIONS</code> variable and all DSP files in the <code>FILES</code> one:</p>
<pre><code class="language-bash">#-------------------------------------------------------------------
# dispatch command arguments
#-------------------------------------------------------------------

while [ $1 ]
do
  p=$1

  if [ $p = &quot;-help&quot; ] || [ $p = &quot;-h&quot; ]; then
     usage faust2minimal &quot;[options] [Faust options] &lt;file.dsp&gt;&quot;
     exit
  fi

  echo &quot;dispatch command arguments&quot;

  if [ ${p:0:1} = &quot;-&quot; ]; then
       OPTIONS=&quot;$OPTIONS $p&quot;
    elif [[ -f &quot;$p&quot; ]] &amp;&amp; [ ${p: -4} == &quot;.dsp&quot; ]; then
       FILES=&quot;$FILES $p&quot;
    else
       OPTIONS=&quot;$OPTIONS $p&quot;        
    fi

shift

done
</code></pre>
<p>Each DSP file is first compiled to C++ using the  <code>faust -a</code> command and the appropriate architecture file, then to the final executable program, here using the C++ compiler:</p>
<pre><code class="language-bash">#-------------------------------------------------------------------
# compile the *.dsp files 
#-------------------------------------------------------------------

for f in $FILES; do

    # compile the DSP to c++ using the architecture file
    echo &quot;compile the DSP to c++ using the architecture file&quot;
  faust -i -a $ARCHFILE $OPTIONS &quot;$f&quot; -o &quot;${f%.dsp}.cpp&quot;|| exit

    # compile c++ to binary
    echo &quot;compile c++ to binary&quot;
    (
        $CXX $CXXFLAGS &quot;${f%.dsp}.cpp&quot; -o &quot;${f%.dsp}&quot;
    ) &gt; /dev/null || exit

  # remove tempory files
    rm -f &quot;${f%.dsp}.cpp&quot;

    # collect binary file name for FaustWorks
    BINARIES=&quot;$BINARIES${f%.dsp};&quot;
done

echo $BINARIES
</code></pre>
<p>The existing <a href="https://github.com/grame-cncm/faust/tree/master-dev/tools/faust2appls">faust2xx scripts</a> can be used as examples.</p>
<h2 id="the-faust2api-model">The faust2api Model</h2>
<p>This model combining the generated DSP the audio and UI architecture components is very convenient to automatically produce ready-to-use standalone application or plugins, since the controller part (GUI,  MIDI or OSC...) is directly compiled and deployed. </p>
<p>In some cases, developers prefer to control the DSP by creating a completely new GUI (using a toolkit not supported in the standard architecture files), or even without any GUI and using another control layer. </p>
<p>A model that only combines the <em>generated DSP</em> with an <em>audio architecture</em> file to produce an <em>audio engine</em> has been developed (thus gluing the  <em>blue</em> and  <em>red</em> parts of the three color model explained at the beginning).  A generic template class <code>DspFaust</code> has been written in the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/api/DspFaust.h">DspFaust.h</a> and <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/api/DspFaust.cpp">DspFaust.cpp</a> files. This code contains conditional compilation sections to add and initialize the appropriate audio driver (written as a subclass of the previously described base <code>audio</code> class), and can produce <em>audio generators</em>, <em>effects</em>, of fully MIDI and sensor controllable <em>pophyphonic instruments</em>. </p>
<p>The resulting audio engine contains <code>start</code> and <code>stop</code> methods to control audio processing. It also provides a set of functions like <code>getParamsCount, setParamValue, getParamValue</code> etc. to access all parameters (or the additional<code>setVoiceParamValue</code> method function to access a single voice in a polyphonic case), and let the developer adds his own GUI or any kind of controller. </p>
<p>Look at the <a href="https://github.com/grame-cncm/faust/tree/master-dev/architecture/api">faust2api</a> script, which uses the previously described architecture files, and provide a tool to easily generate custom APIs based on one or several Faust objects. </p>
<p><img src="img/FaustArchitecture5.jpg" class="mx-auto d-block" width="40%"></p>
<h2 id="using-the-inj-option-with-faust2xx-scripts">Using the -inj Option With faust2xx Scripts</h2>
<p>The compiler <code>-inj &lt;f&gt;</code>  option allows to inject a pre-existing C++ file (instead of compiling a dsp file) into the architecture files machinery. Assuming that the C++ file implements a subclass of the base <code>dsp</code> class,  the <code>faust2xx</code> scripts can possibly be used to produce a ready-to-use application or plugin that can take profit of all already existing UI and audio architectures. Two examples of use are presented next.</p>
<h3 id="using-the-template-llvmcpp-architecture">Using the template-llvm.cpp architecture</h3>
<p>The first one demonstrates how <code>faust2xx</code> scripts can become more dynamic by loading and compiling an arbitrary DSP at runtime. This is done using the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/template-llvm.cpp">template-llvm.cpp</a> architecture file which uses the libfaust library and the LLVM backend to dynamically compile a <code>foo.dsp</code> file. So instead of producing a static binary based on a given DSP, the resulting program will be able to load  and compile a DSP at runtime. </p>
<p>This template-llvm.cpp can be used with the <code>-inj</code> option in <code>faust2xx</code>  tools like:</p>
<p><code>faust2cagtk -inj template-llvm.cpp faust2cagtk-llvm.dsp (a dummy DSP)</code></p>
<p>to generate a monophonic <code>faust2cagtk-llvm</code> application, ready to be used to load and compile a DSP, and run it with the CoreAudio audio layer and GTK as the GUI freamework.</p>
<p>Then <code>faust2cagtk-llvm</code> will ask for a DSP to compile:</p>
<p><code>./faust2cagtk-llvm
&lt;Enter a foo.dsp file&gt;</code></p>
<p>A generic polyphonic (8 voices) and MIDI controllable version can be compiled using:</p>
<p><code>faust2cagtk -inj template-llvm.cpp -midi -nvoices 8 faust2cagtk-llvm.dsp (a dummy DSP)</code></p>
<p>Note that the resulting binary keeps its own control options, like:</p>
<p><code>./faust2cagtk-llvm -h
 ./faust2cagtk-llvm [--frequency &lt;val&gt;] [--buffer &lt;val&gt;] [--nvoices &lt;val&gt;] [--control &lt;0/1&gt;] 
 [--group &lt;0/1&gt;] [--virtual-midi &lt;0/1&gt;]</code></p>
<p>So now  <code>./faust2cagtk-llvm --nvoices 16</code> starts the program with 16 voices.</p>
<p>The technique has currently be tested with the <code>faust2cagtk</code>, <code>faust2jack</code> , <code>faust2csvplot</code>,  and <code>faust2plot</code> tools.</p>
<h3 id="second-use-case-computing-the-spectrogram-of-a-set-of-audio-files">Second use-case computing the spectrogram of a set of audio files</h3>
<p>Here is a second use case where some external C++ code is used to compute the <em>spectrogram of a set of audio files</em> (which is something that cannot be simply done with the current version fo the Faust language) and output the spectrogram as an audio signal. A <code>nentry</code> controller will be used to select the currently playing spectrogram. The Faust compiler will be used to generate a C++ class which is going to be manually edited and enriched with additional code. </p>
<h4 id="writting-the-dsp-code">Writting the DSP code</h4>
<p>First a fake DSP program <code>spectral.dsp</code>  using the <code>soundfile</code> primitive loading two audio files and a <code>nentry</code> control is written: </p>
<pre><code>sf = soundfile(&quot;sound[url:{'sound1.wav';'sound2.wav'}]&quot;,2);
process = (hslider(&quot;Spectro&quot;, 0, 0, 1, 1),0) : sf : !,!,_,_;
</code></pre>
<p>The point of explicitly using <code>soundfile</code> primitive and a <code>nentry</code> control is to generate a C++ file with a prefilled DSP structure (containing the <code>fSoundfile0</code> and <code>fHslider0</code> fields) and code inside the <code>buildUserInterface</code> method. Compiling it manually with the following command: </p>
<pre><code>faust spectral.dsp -cn spectral -o spectral.cpp
</code></pre>
<p>produces the following C++ code containing the <code>spectral</code> class:</p>
<pre><code class="language-c++">class spectral : public dsp {

 private:

  Soundfile* fSoundfile0;
  FAUSTFLOAT fHslider0;
  int fSampleRate;

 public:

  ...   

  virtual int getNumInputs() {
    return 0;
  }
  virtual int getNumOutputs() {
    return 2;
  }

  ...

  virtual void buildUserInterface(UI* ui_interface) {
    ui_interface-&gt;openVerticalBox(&quot;spectral&quot;);
    ui_interface-&gt;addHorizontalSlider(&quot;Spectrogram&quot;, &amp;fHslider0, 0.0f, 0.0f, 1.0f, 1.0f);
    ui_interface-&gt;addSoundfile(&quot;sound&quot;, &quot;{'sound1.wav';'sound2.wav';}&quot;, &amp;fSoundfile0);
    ui_interface-&gt;closeBox();
  }

  virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
    int iSlow0 = int(float(fHslider0));
    ....
  }

};
</code></pre>
<h4 id="customizing-the-c-code">Customizing the C++ code</h4>
<p>Now the <code>spectral</code> class can be manually edited and completed with additional code, to compute the two audio files spectrograms in <code>buildUserInterface</code>, and play them in <code>compute</code>. </p>
<ul>
<li>a new line <code>Spectrogram fSpectro[2];</code> is added in the DSP structure</li>
<li>a <code>createSpectrogram(fSoundfile0, fSpectro);</code> function is added in <code>buildUserInterface</code> and used to compute and fill the two spectrograms, by reading the two loaded audio files in <code>fSoundfile0</code></li>
<li>part of the generated code in <code>compute</code> is removed and replaced by new code to play one of spectrograms (selected with the <code>fHslider0</code> control in the GUI) using a <code>playSpectrogram(fSpectro, count, iSlow0, outputs);</code> function:</li>
</ul>
<pre><code class="language-c++">class spectral : public dsp {

  private:

    Soundfile* fSoundfile0;
    FAUSTFLOAT fHslider0;
    int fSampleRate;
    Spectrogram fSpectro[2];

  public:

    ...

    virtual int getNumInputs() {
      return 0;
    }
    virtual int getNumOutputs() {
      return 2;
    }

    ...

    virtual void buildUserInterface(UI* ui_interface) {
      ui_interface-&gt;openVerticalBox(&quot;spectral&quot;);
      ui_interface-&gt;addHorizontalSlider(&quot;Spectro&quot;, &amp;fHslider0, 0.0f, 0.0f, 1.0f, 1.0f);
      ui_interface-&gt;addSoundfile(&quot;sound&quot;, &quot;{'sound1.wav';'sound2.wav';}&quot;, &amp;fSoundfile0);
      // Read 'fSoundfile0' and fill 'fSpectro'
      createSpectrogram(fSoundfile0, fSpectro);
      ui_interface-&gt;closeBox();
    }

    virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
      int iSlow0 = int(float(fHslider0));
      // Play 'fSpectro' indexed by 'iSlow0' by writting 'count' samples in 'outputs'
      playSpectrogram(fSpectro, count, iSlow0, outputs);
    }

};
</code></pre>
<p>Here we assume that <code>createSpectrogram</code> and <code>playSpectrogram</code> functions are defined elsewhere and ready to be compiled.</p>
<h4 id="deploying-it-as-a-maxmsp-external-using-the-faust2max6-script">Deploying it as a Max/MSP External Using the faust2max6 Script</h4>
<p>The completed <code>spectral.cpp</code> file is now ready to be deployed as a Max/MSP external using the <code>faust2max6</code> script and the <code>-inj</code> option with the following line:</p>
<pre><code>faust2max6 -inj spectral.cpp -soundfile spectral.dsp
</code></pre>
<p>The two needed <code>sound1.wav</code> and <code>sound2.wav</code> audio files are embedded in the generated external, loaded at init time (since the<code>buildUserInterface</code> method is automatically called), and the manually added C++ code will be executed to compute the spectrograms and play them. Finally by respecting the naming coherency for the fake <code>spectral.dsp</code> DSP program, the generated <code>spectral.cpp</code> C++ file, the automatically generated <code>spectral.maxpat</code> Max/MSP patch will be able to build the GUI with a ready-to-use slider.</p>
<h2 id="additional-ressources">Additional Ressources</h2>
<p>Several external projects are providing tools to arrange the way Faust source code is generated or used, in different languages.</p>
<h3 id="preprocessing-tools">Preprocessing tools</h3>
<h4 id="fpp"><a href="https://github.com/oleg-nesterov/fpp">fpp</a></h4>
<p>fpp is a standalone Perl script with no dependencies which allows ANY C/C++ code in a Faust .dsp file as long as you are targeting C/C++ in scalar mode.</p>
<h3 id="c-tools">C++ tools</h3>
<p>Using and adapting the <code>dsp/UI/audio</code> model in a more sophisticated way, or integrating Faust generated C++ classes in others frameworks (like JUCE).</p>
<h4 id="faust2hpp"><a href="https://github.com/resonantdsp/faust2hpp">faust2hpp</a></h4>
<p>Convert Faust code to a header-only standalone C++ library. A collection of header files is generated as the output. A class is provided from which a DSP object can be built with methods in the style of <a href="https://juce.com/">JUCE</a> DSP objects. </p>
<h4 id="faustpp"><a href="https://github.com/jpcima/faustpp">faustpp</a></h4>
<p>A post-processor for Faust, which allows to generate with more flexibility. This is a source transformation tool based on the Faust compiler. It permits to arrange the way how Faust source is generated with greater flexibility.</p>
<h4 id="faustdoctor"><a href="https://github.com/SpotlightKid/faustdoctor">faustdoctor</a></h4>
<p>A fork of <a href="https://github.com/jpcima/faustpp">faustpp</a> with greater flexibility.</p>
<h4 id="dpf-faust-project-template"><a href="https://github.com/SpotlightKid/dpf-faust-project-template">dpf-faust-project-template</a></h4>
<p>A <a href="https://github.com/copier-org/copier">copier</a> project template for DISTRHO Plugin Framework (<a href="https://github.com/DISTRHO/DPF">DPF</a>) audio effect plugins using <a href="https://faust.grame.fr">FAUST</a> for the implementation of the DSP pipeline.</p>
<h4 id="faustmd"><a href="https://github.com/jpcima/faustmd">faustmd</a></h4>
<p>Static metadata generator for Faust/C++. This program builds the metadata for a Faust DSP ahead of time, rather than dynamically. The result is a block of C++ code which can be appended to the code generation.</p>
<h4 id="faustcppconverter"><a href="https://github.com/eyalamirmusic/FaustCPPConverter">FaustCPPConverter</a></h4>
<p><a href="https://github.com/eyalamirmusic">Eyal Amir</a> tool to facilitate the use of Faust generated  C++ code in JUCE projects. </p>
<h4 id="josmodules-and-josm_faust"><a href="https://github.com/josmithiii/JOSModules">JOSModules</a> and <a href="https://github.com/josmithiii/josm_faust#josm_faust">josm_faust</a></h4>
<p><a href="https://ccrma.stanford.edu/~jos/">Julius Smith</a> projects to facilitate the use of Faust generated  C++ code in JUCE projects. </p>
<h4 id="arduino-tools"><a href="https://www.pschatzmann.ch/home/2022/04/22/using-faust-dsp-with-my-arduino-audio-tools/">Arduino tools</a></h4>
<p>An alternative way to use the ESP32 board with Faust, possibly easier and more versatile than the examples mentioned on the <a href="../../tutorials/esp32/">esp32 tutorial</a>.</p>
<h3 id="cmajor-tools">Cmajor tools</h3>
<h4 id="using-faust-in-cmajor"><a href="../../tutorials/cmajor/">Using Faust in Cmajor</a></h4>
<p>A tutorial to show how Faust can be used with <a href="https://cmajor.dev">Cmajor</a>, a C like procedural high-performance language especially designed for audio processing, and with dynamic JIT based compilation. </p>
<h3 id="rnbo-tools">RNBO tools</h3>
<h4 id="using-faust-in-rnbo-with-codebox"><a href="../../tutorials/rnbo/">Using Faust in RNBO with codebox~</a></h4>
<p>A tutorial to show how Faust can be used with <a href="https://rnbo.cycling74.com">RNBO</a>, a library and toolchain that can take Max-like patches, export them as portable code, and directly compile that code to targets like a VST, a Max External, or a Raspberry Pi.</p>
<h3 id="dlang-tools">DLang tools</h3>
<h4 id="faust-2-dplug-guide"><a href="https://github.com/Tonton-Blax/dplugfausttest">Faust 2 Dplug Guide</a></h4>
<p>Explains how to use Faust in a <a href="https://dplug.org/">Dplug</a> project.</p>
<h4 id="dplug-faust-example"><a href="https://github.com/ctrecordings/dplug-faust-example">Dplug Faust Example</a></h4>
<p>This is an example plugin using Dplug with a Faust backend. It is a stereo reverb plugin using the Freeverb demo from the Faust library.</p>
<h3 id="julia-tools">Julia tools</h3>
<h4 id="faustjl"><a href="https://github.com/corajr/Faust.jl">Faust.jl</a></h4>
<p>Julia wrapper for the Faust compiler. Uses the Faust LLVM C API.</p>
<h4 id="using-faust-in-julia"><a href="../../tutorials/julia/">Using Faust in Julia</a></h4>
<p>A tutorial to show how Faust can be used with <a href="https://julialang.org">Julia</a>, a high-level, general-purpose dynamic programming language with features well suited for numerical analysis and computational science.</p>
<h3 id="python-tools">Python tools</h3>
<h4 id="faustpy"><a href="https://github.com/marcecj/faust_python">FAUSTPy</a></h4>
<p>FAUSTPy is a Python wrapper for the FAUST DSP language. It is implemented using the CFFI and hence creates the wrapper dynamically at run-time. A updated version of the project is available on <a href="https://github.com/hrtlacek/faust_python">this fork</a>.</p>
<h4 id="faust-ctypes"><a href="https://gitlab.com/adud2/faust-ctypes">Faust Ctypes</a></h4>
<p>A port of Marc Joliet's FaustPy from CFFI to Ctypes. Faust-Ctypes documentation is <a href="https://adud2.gitlab.io/faust-ctypes">available online</a>.</p>
<h4 id="an-scons-tool-for-faust"><a href="https://github.com/marcecj/scons_faust">An SCons Tool for FAUST</a></h4>
<p>This is an SCons tool for compiling FAUST programs. It adds various builders to your construction environment: Faust, FaustXML, FaustSVG, FaustSC, and FaustHaskell. Their behaviour can be modified by changing various construction variables (see "Usage" below).</p>
<h4 id="faustwatch"><a href="https://github.com/hrtlacek/faustTools">Faustwatch</a></h4>
<p>At the moment there is one tool present, faustwatch.py. Faustwatch is a tool that observes a .dsp file used by the dsp language Faust. </p>
<h4 id="faustwidgets"><a href="https://github.com/hrtlacek/faustWidgets">faustWidgets</a></h4>
<p>Creates interactive widgets inside jupyter notebooks from Faust dsp files and produces a (customizable) plot. </p>
<h4 id="faust-synth"><a href="https://github.com/anwaldt/py2faust_synth">Faust Synth</a></h4>
<p>This is an example project for controlling a synth, programmed and compiled with Faust, through a Python script. The synth runs as a JACK client on Linux systems and the output is automatically recorded by jack_capture.</p>
<h4 id="dawdreamer"><a href="https://github.com/DBraun/DawDreamer">DawDreamer</a></h4>
<p>DawDreamer is an audio-processing Python framework supporting Faust and Faust's Box API.</p>
<h4 id="ode2dsp"><a href="https://git.sr.ht/~kdsch/ode2dsp">ode2dsp</a></h4>
<p>ode2dsp is a Python library for generating ordinary differential equation (ODE) solvers in digital signal processing (DSP) languages. It automates the tedious and error-prone symbolic calculations involved in creating a DSP model of an ODE. Finite difference equations (FDEs) are rendered to Faust code.</p>
<h4 id="faustlab"><a href="https://github.com/shakfu/faustlab">faustlab</a></h4>
<p>A exploratory project to wrap the Faust <em>interpreter</em> for use by python via the following wrapping frameworks using the RtAudio cross-platform audio driver:</p>
<ul>
<li>cyfaust:     cython         (faust c++ interface)</li>
<li>cfaustt:     cython         (faust c   interface)</li>
<li>pyfaust:     pybind11     (faust c++ interface)</li>
<li>nanobind: nanobind     (faust c++ interface)</li>
</ul>
<h4 id="cyfaust"><a href="https://github.com/shakfu/cyfaust">cyfaust</a></h4>
<p>A cython wrapper of the Faust interpreter and the RtAudio cross-platform audio driver, derived from the <a href="#faustlab">faustlab</a> project. The objective is to end up with a minimal, modular, self-contained, cross-platform python3 extension.</p>
<h3 id="rust-tools">Rust tools</h3>
<h4 id="rust-faust"><a href="https://github.com/Frando/rust-faust">rust-faust</a></h4>
<p>A better integration of Faust for Rust. It allows to build the DSPs via build.rs and has some abstractions to make it much easier to work with params and meta of the DSPs.</p>
<h4 id="faust-egui"><a href="https://github.com/plule/faust-egui">Faust egui</a></h4>
<p>Proof of concept of drawing a UI with egui and <a href="https://github.com/Frando/rust-faust">rust-faust</a>.</p>
<h4 id="rustfaustexperiments"><a href="https://github.com/bluenote10/RustFaustExperiments/tree/master/Benchmarks">RustFaustExperiments</a></h4>
<p>Tools to compare C++ and Rust code generated from Faust. </p>
<h4 id="fl-tui"><a href="https://gitlab.com/raoulhc/fl-tui">fl-tui</a></h4>
<p>Rust wrapper for the Faust compiler. It uses the libfaust LLVM C API.</p>
<h4 id="faustlive-jack-rs"><a href="https://codeberg.org/obsoleszenz/faustlive-jack-rs">faustlive-jack-rs</a></h4>
<p>Another Rust wrapper for the Faust compiler, using <a href="https://jackaudio.org">JACK</a> server for audio. It uses the libfaust LLVM C API.</p>
<h4 id="lowpass-lr4-faust-nih-plug"><a href="https://codeberg.org/obsoleszenz/lowpass-lr4-faust-nih-plug">lowpass-lr4-faust-nih-plug</a></h4>
<p>A work-in-progress project to integrate Faust generated Rust code with <a href="https://github.com/robbert-vdh/nih-plug">NIH-plug</a>.</p>
<h4 id="nih-faust-jit"><a href="https://github.com/YPares/nih-faust-jit">nih-faust-jit</a></h4>
<p>A plugin to load Faust dsp files and JIT-compile them with LLVM. A simple GUI is provided to select which script to load and where to look for the Faust libraries that this script may import. The selected DSP script is saved as part of the plugin state and therefore is saved with your DAW project.</p>
<h3 id="webassembly-tools">WebAssembly tools</h3>
<h4 id="deploying-faust-dsp-on-the-web"><a href="../deploying/">Deploying Faust DSP on the Web</a></h4>
<p>A description of different solutions to use Faust on the Web platform.</p>
<h4 id="faust-loader"><a href="https://github.com/Smona/faust-loader">faust-loader</a></h4>
<p>Import Faust .dsp files, and get back an AudioWorklet or ScriptProcessor node.</p>
<h4 id="faust2cpp2wasm"><a href="https://github.com/nuchi/faust2cpp2wasm">faust2cpp2wasm</a></h4>
<p>A drop in replacement for the wasm file generated by <code>faust2wasm</code>, but with Faust's C++ backend instead of its wasm backend.</p>
<h4 id="faust-compiler-microservice"><a href="https://github.com/Ameobea/web-synth/tree/master/faust-compiler#faust-compiler-microservice">Faust Compiler Microservice</a></h4>
<p>This is a microservice that serves a single purpose: compiling Faust code that is sent to it into WebAssembly that can then be loaded and run natively from within the web synth application. It is written in go because go is supposed to be good for this sort of thing.</p>
<h4 id="mosfez-faust"><a href="https://github.com/dxinteractive/mosfez-faust">mosfez-faust</a></h4>
<p>Makes dynamic compilation of Faust on the web a little easier, and has a dev project to run values through dsp offline, and preview dsp live. It's an opinionated version of some parts of <a href="https://github.com/grame-cncm/faust/tree/master-dev/architecture/webaudio">Faust for webaudio</a>, mostly just the Web Assembly Faust compiler, wrapped up in a library with additional features. </p>
<h4 id="faust-wap2-playground"><a href="https://github.com/Nek/faust-wap2-playground">faust-wap2-playground</a></h4>
<p>Playground and template for Faust-based web audio experiments.</p>
<h4 id="vite-plugin-faust"><a href="https://www.npmjs.com/package/vite-plugin-faust">vite-plugin-faust</a></h4>
<p>Vite plugin to transform Faust DSP files into importable JavaScript (+ WASM) modules. Uses <a href="https://www.npmjs.com/package/@grame/faustwasm">faustwasm</a> under the hood.</p>
<h3 id="dart-tools">Dart tools</h3>
<h4 id="flutter_faust_ffi"><a href="https://github.com/t2techno/flutter_faust_ffi">flutter_faust_ffi</a></h4>
<p>A basic flutter app as a proof of concept utilizing Faust's C API export with Dart's ffi methods to create cross-platform plug-ins.</p></div>
        </div>
    </div>

    <footer class="col-md-12">
        <hr>
        <p>Copyright &copy; 2020-2025 <a href="https://www.grame.fr">Grame-CNCM</a></p>
    </footer>
    <script>
        var base_url = "../..",
        shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
    </script>
    <script src="../../js/base.js" defer></script>
    <script src="/js/faust-web-component.js" defer></script>
    <script src="../../search/main.js" defer></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
