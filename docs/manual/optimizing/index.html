<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Optimizing the Code - Faust Documentation</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="/css/quickref.css" rel="stylesheet">
        <link href="/rail/railroad-diagrams.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../.."><img src="../../img/faustText.svg" width="150px"> </a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Faust Manual <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../introduction/" class="dropdown-item">Introduction</a>
</li>
                                    
<li>
    <a href="../overview/" class="dropdown-item">Overview of the Faust Universe</a>
</li>
                                    
<li>
    <a href="../quick-start/" class="dropdown-item">Quick start</a>
</li>
                                    
<li>
    <a href="../syntax/" class="dropdown-item">Faust Syntax</a>
</li>
                                    
<li>
    <a href="../compiler/" class="dropdown-item">Using the Compiler</a>
</li>
                                    
<li>
    <a href="../options/" class="dropdown-item">Compiler Options</a>
</li>
                                    
<li>
    <a href="../tools/" class="dropdown-item">faust2[...] Tools</a>
</li>
                                    
<li>
    <a href="../architectures/" class="dropdown-item">Architecture Files</a>
</li>
                                    
<li>
    <a href="../embedding/" class="dropdown-item">Embedding the Compiler</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Optimizing the Code</a>
</li>
                                    
<li>
    <a href="../deploying/" class="dropdown-item">Deploying on the Web</a>
</li>
                                    
<li>
    <a href="../remote/" class="dropdown-item">Remote compilation</a>
</li>
                                    
<li>
    <a href="../mathdoc/" class="dropdown-item">Mathematical Documentation</a>
</li>
                                    
<li>
    <a href="../osc/" class="dropdown-item">OSC Support</a>
</li>
                                    
<li>
    <a href="../http/" class="dropdown-item">HTTP Support</a>
</li>
                                    
<li>
    <a href="../midi/" class="dropdown-item">MIDI Support</a>
</li>
                                    
<li>
    <a href="../soundfiles/" class="dropdown-item">Soundfiles Support</a>
</li>
                                    
<li>
    <a href="../community/" class="dropdown-item">Community</a>
</li>
                                    
<li>
    <a href="../faq/" class="dropdown-item">Frequently Asked Questions</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Examples <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../examples/ambisonics/" class="dropdown-item"> ambisonics </a>
</li>
                                    
<li>
    <a href="../../examples/analysis/" class="dropdown-item"> analysis </a>
</li>
                                    
<li>
    <a href="../../examples/bela/" class="dropdown-item"> bela </a>
</li>
                                    
<li>
    <a href="../../examples/delayEcho/" class="dropdown-item"> delayEcho </a>
</li>
                                    
<li>
    <a href="../../examples/dynamic/" class="dropdown-item"> dynamic </a>
</li>
                                    
<li>
    <a href="../../examples/filtering/" class="dropdown-item"> filtering </a>
</li>
                                    
<li>
    <a href="../../examples/gameaudio/" class="dropdown-item"> gameaudio </a>
</li>
                                    
<li>
    <a href="../../examples/generator/" class="dropdown-item"> generator </a>
</li>
                                    
<li>
    <a href="../../examples/misc/" class="dropdown-item"> misc </a>
</li>
                                    
<li>
    <a href="../../examples/phasing/" class="dropdown-item"> phasing </a>
</li>
                                    
<li>
    <a href="../../examples/physicalModeling/" class="dropdown-item"> physicalModeling </a>
</li>
                                    
<li>
    <a href="../../examples/pitchShifting/" class="dropdown-item"> pitchShifting </a>
</li>
                                    
<li>
    <a href="../../examples/psychoacoustic/" class="dropdown-item"> psychoacoustic </a>
</li>
                                    
<li>
    <a href="../../examples/reverb/" class="dropdown-item"> reverb </a>
</li>
                                    
<li>
    <a href="../../examples/SAM/" class="dropdown-item"> SAM </a>
</li>
                                    
<li>
    <a href="../../examples/smartKeyboard/" class="dropdown-item"> smartKeyboard </a>
</li>
                                    
<li>
    <a href="../../examples/spat/" class="dropdown-item"> spat </a>
</li>
                                    
<li>
    <a href="../../rsrc/examples.zip" class="dropdown-item"> Download examples </a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tutorials <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item">Faust & JUCE</a>
</li>
                                    
<li>
    <a href="../../tutorials/teensy/" class="dropdown-item">DSP on the Teensy With Faust</a>
</li>
                                    
<li>
    <a href="../../tutorials/esp32/" class="dropdown-item">DSP on the ESP-32 With Faust</a>
</li>
                                    
<li>
    <a href="../../tutorials/basic-osc/" class="dropdown-item">Making a Sine Oscillator From Scratch</a>
</li>
                                    
<li>
    <a href="../../tutorials/summation/" class="dropdown-item">RMS and Summation in Faust</a>
</li>
                                    
<li>
    <a href="../../tutorials/julia/" class="dropdown-item">Using Faust in Julia</a>
</li>
                                    
<li>
    <a href="../../tutorials/signal-api/" class="dropdown-item">Using the signal API</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Workshops <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../workshops/2018-12-01-paw/" class="dropdown-item"> 2018-12-01 PAW </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-03-24-faust-citi/" class="dropdown-item"> 2020-03-24 CITI </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-101/" class="dropdown-item"> 2020-04-10 Faust 101 </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item"> 2020-04-10 Faust & JUCE </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-11-21-faust-vcvrack/" class="dropdown-item"> 2020-11-21 Faust & VCV Rack </a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        
        

        <div class="container">
            <div class="row"><div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#optimize-and-debug-the-code" class="nav-link">Optimize and Debug the Code</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#optimizing-the-dsp-code" class="nav-link">Optimizing the DSP Code</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#computations-done-at-compilationspecialisation-time" class="nav-link">Computations Done at Compilation/Specialisation Time</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#using-pattern-matching" class="nav-link">Using Pattern Matching</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#specializing-the-dsp-code" class="nav-link">Specializing the DSP Code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#computations-done-at-init-time" class="nav-link">Computations Done at Init time</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#using-rdtable-or-rwtable" class="nav-link">Using rdtable or rwtable</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#computations-done-at-control-rate" class="nav-link">Computations Done at Control Rate</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#parameter-smoothing" class="nav-link">Parameter Smoothing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#computations-done-at-sample-rate" class="nav-link">Computations Done at Sample Rate</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#using-function-tabulation" class="nav-link">Using Function Tabulation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#using-fast-math-functions" class="nav-link">Using Fast Math Functions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#managing-dsp-memory-size" class="nav-link">Managing DSP Memory Size</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#optimizing-the-c-or-llvm-code" class="nav-link">Optimizing the C++ or LLVM Code</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#faustbench" class="nav-link">faustbench</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#faustbench-llvm" class="nav-link">faustbench-llvm</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#dynamic-faust" class="nav-link">dynamic-faust</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#optimizing-with-any-faust2xx-tool" class="nav-link">Optimizing with any faust2xx tool</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#compiling-for-multiple-cpus" class="nav-link">Compiling for Multiple CPUs</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#faust2object" class="nav-link">faust2object</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#debugging-the-dsp-code" class="nav-link">Debugging the DSP Code</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#interp-tracer" class="nav-link">interp-tracer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#debugging-at-runtime" class="nav-link">Debugging at Runtime</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#additional-resources" class="nav-link">Additional Resources</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9 main-container" role="main">

<h1 id="optimize-and-debug-the-code">Optimize and Debug the Code</h1>
<h2 id="optimizing-the-dsp-code">Optimizing the DSP Code</h2>
<p>Faust is a Domain Specific Language helping the programmer to write very high-level and concise DSP code, while letting the compiler do the hard work of producing the best and most efficient implementation of the specification. When processing the DSP source, the compiler typing system is able to discover how the described computations are effectively separated in four main categories: </p>
<ul>
<li>computations done <em>at compilation/specialisation time</em>: this is the place for algorithmic signal processors definition heavily based on the lambda-calculus constitute of the language, together with its pattern-matching capabilities</li>
<li>computations done <em>at init time</em>: for instance all the code that depends of the actual sample-rate, or filling of some internal tables (coded with the <code>rdtable</code> or <code>rwtable</code> language primitives) </li>
<li>computations done <em>at control rate</em>: typically all code that read the current values of controllers (buttons, sliders, nentries) and update the DSP internal state which depends of them</li>
<li>computations done <em>at sample rate</em>: all remaining code that process and produce the samples </li>
</ul>
<p>One can think of these four categories as <em>different computation rates</em>. The programmer can possibly split its DSP algorithm to distribute the needed computation in the most appropriate domain (<em>slower rate</em> domain better than <em>faster rate</em> domain) and possibly rewrite some parts of its DSP algorithm from one domain to a slower rate one to finally obtain the most efficient code.</p>
<h3 id="computations-done-at-compilationspecialisation-time">Computations Done <em>at Compilation/Specialisation Time</em></h3>
<h4 id="using-pattern-matching">Using Pattern Matching</h4>
<p><strong>TODO</strong>: explain how pattern-matching can be used to algorithmically describe signal processors, explain the principle of defining a new DSL inside the Faust DSL (with <a href="https://faustlibraries.grame.fr/libs/fds/">fds.lib</a>, <a href="https://faustlibraries.grame.fr/libs/physmodels/">physmodels.lib</a>, <a href="https://faustlibraries.grame.fr/libs/wavedigitalfilters/">wdmodels.lib</a> as examples).</p>
<h4 id="specializing-the-dsp-code">Specializing the DSP Code</h4>
<p>The Faust compiler can possibly do a lot of optimizations at compile time. The DSP code can for instance be compiled for a fixed sample rate, thus doing at compile time all computation that depends of it. Since the Faust compiler will look for librairies starting from the local folder, a simple way is to locally copy the <code>libraries/platform.lib</code> file (which contains the <code>SR</code> definition), and change its definition for a fixed value like 48000 Hz. Then the DSP code has to be recompiled for the specialisation to take effect. Note that <code>libraries/platform.lib</code> also contains the definition of  the <code>tablesize</code> constant which is used in various places to allocate tables for oscillators. Thus decreasing this value can save memory, for instance when compiling for embedded devices. This is the technique used in some Faust services scripts which add the <code>-I /usr/local/share/faust/embedded/</code> parameter to the Faust command line to use a special version of the platform.lib file.</p>
<h3 id="computations-done-at-init-time">Computations Done <em>at Init time</em></h3>
<p>If not specialized with a constant value at compilation time, all computations that use the sample rate (which is accessed with the <code>ma.SR</code> in the DSP source code and given as parameter in the DSP <code>init</code> function) will be done at init time, and possibly again each time the same DSP is initialized with another sample rate.  </p>
<h4 id="using-rdtable-or-rwtable">Using rdtable or rwtable</h4>
<p><strong>TODO</strong>: explain how computations can be done at init time and how to use rdtable or rwtable to store pre-computed values.</p>
<h3 id="computations-done-at-control-rate">Computations Done <em>at Control Rate</em></h3>
<h4 id="parameter-smoothing">Parameter Smoothing</h4>
<p>Control parameters are sampled once per block, their values are considered constant during the block, and the internal state depending of them is updated and appears at the beginning of the <code>compute</code> method, before the sample rate DSP loop. </p>
<p>If a control parameter needs to be smoothed (like to avoid clicks or too abrupt changes), with the <code>control : si.smoo</code> kind of code, the computation rate moves from <em>control rate</em> to <em>sample rate</em>, and will be more costly. It means that the need for parameter smoothing <em>should be carefully studied</em>. </p>
<p>Another point to consider is the <em>order of computation</em> when smoothing control. Here slider value is <em>first</em> converted first to a dB value, <em>then</em> smoothed:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
smoother_vol = hslider(&quot;Volume&quot;, 0.5, 0, 1, 0.01) : ba.linear2db : si.smoo;
process = *(smoother_vol);
</code></pre>
<p>And the generated C++ code for <code>compute</code> has the costly <code>log10</code> math function used in <code>ba.linear2db</code> evaluted at control rate, so once before the DSP loop:</p>
<pre><code class="language-c++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
  FAUSTFLOAT* input0 = inputs[0];
  FAUSTFLOAT* output0 = outputs[0];
  float fSlow0 = (0.0199999996f * std::log10(float(fHslider0)));
  for (int i = 0; (i &lt; count); i = (i + 1)) {
    fRec0[0] = (fSlow0 + (0.999000013f * fRec0[1]));
    output0[i] = FAUSTFLOAT((float(input0[i]) * fRec0[0]));
    fRec0[1] = fRec0[0];
  }
}
</code></pre>
<p>But if the order between <code>ba.linear2db</code> and  <code>si.smoo</code> is reversed like in the following code:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
smoother_vol = hslider(&quot;Volume&quot;, 0.5, 0, 1, 0.01) : si.smoo: ba.linear2db;
process = *(smoother_vol);
</code></pre>
<p>The generated C++ code for <code>compute</code> now has the <code>log10</code> math function used in <code>ba.linear2db</code> evaluted at sample rate in the DSP loop, which is obviously much more costly:</p>
<pre><code class="language-c++">virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
  FAUSTFLOAT* input0 = inputs[0];
  FAUSTFLOAT* output0 = outputs[0];
  float fSlow0 = (0.00100000005f * float(fHslider0));
  for (int i = 0; (i &lt; count); i = (i + 1)) {
    fRec0[0] = (fSlow0 + (0.999000013f * fRec0[1]));
    output0[i] = FAUSTFLOAT((20.0f * (float(input0[i]) * std::log10(fRec0[0]))));
    fRec0[1] = fRec0[0];
  }
}
</code></pre>
<p>So to obtain the best performances in the generated code, all costly computations have to be done on the control value (as much as possible, this may not always be the desirable behaviour), and <code>si.smoo</code> (or any function that moves the computation from control rate to sample rate) as the last operation. </p>
<h3 id="computations-done-at-sample-rate">Computations Done <em>at Sample Rate</em></h3>
<h4 id="using-function-tabulation">Using Function Tabulation</h4>
<p>The use of <code>rdtable</code> kind of compilation done at init time can be simplified using the <a href="https://faustlibraries.grame.fr/libs/basics/#batabulate">ba.tabulate</a> function to <em>tabulate</em> a given unary function <code>fun</code> on a given range. A table is created and filled with precomputed values, and can be used to compute <code>fun(x)</code> in a more efficient way (at the cost of additional  static memory needed for the table).</p>
<h4 id="using-fast-math-functions">Using Fast Math Functions</h4>
<p>When costly math functions still appear in the sample rate code, the <code>-fm</code> <a href="https://faustdoc.grame.fr/manual/options/">compilation option</a> can possibly be used to replace the standard versions provided by the underlying OS (like <code>std::cos</code>, <code>std::tan</code>... in C++ for instance) with user defined ones (hopefully faster, but possibly less precise).</p>
<h3 id="managing-dsp-memory-size">Managing DSP Memory Size</h3>
<p>The Faust compiler automatically allocates memory for delay-lines, represented as buffers with <em>wrapping</em> read/write indexes that continously loop inside the buffer. Several strategies can be used to implement the wrapping indexes:  </p>
<ul>
<li>arrays of power-of-two sizes can be accessed using mask based index computation which is the fastest method, but consumes more memory since a delay-line of a given size will be extended to the next power-of-two size</li>
<li>otherwise the <em>wrapping</em> index can be implemented with a <em>if</em> based method where the increasing index is compared to the delay-line size, and wrapped to zero when reaching it </li>
</ul>
<p>The <code>-dlt &lt;n&gt;</code>  (<code>--delay-line-threshold</code>) option allows to choose between the two available stategies. By default its value is INT_MAX thus all delay-lines are allocated using the first method. By choising a given value (in frames) for <code>-dlt</code>, all delay-lines with size bellow this value will be allocated using the first method (faster but consuming more memory), and other ones with the second method (slower but consuming less memory). Thus by gradually changing this <code>-dlt</code>  value in this continuum <em>faster/more memory up to slower/less memory</em>, the optimal choice can be done. <strong>This option can be especially useful in embedded devices context.</strong></p>
<h2 id="optimizing-the-c-or-llvm-code">Optimizing the C++ or LLVM Code</h2>
<p>From a given DSP program, the Faust compiler tries to generate the most efficient implementation. Optimizations can be done at DSP writing time, or later on when the target langage is generated (like  C++ or LLVM IR).
The generated code can have different <em>shapes</em> depending of compilation options, and can run faster of slower. Several programs and tools are available to help Faust programmers to test (for possible numerical or precision issues), optimize their programs by discovering the best set of options for a given DSP code, and finally compile them into native code for the target CPUs. </p>
<p>By default the Faust compiler produces a big scalar loop in the generated <code>mydsp::compute</code> method. Compiler options allow to generate other code <em>shapes</em>, like for instance separated simpler loops connected with buffers in the so-called vectorized mode (obtained using  the <code>-vec</code> option). The assumption is that auto-vectorizer passes in modern compilers will be able to better generate efficient SIMD code for them. In this vec option, the size of the internal buffer can be changed using the <code>-vs value</code> option. Moreover the computation graph can be organized in deep-first order using <code>-dfs</code>.  A lot of other compilation choices are fully controllable with options. Note that the C/C++ and LLVM backends are the one with the maximum of possible compilation options. </p>
<p>Manually testing each of them and their combination is out of reach. So several tools have been developed to automatize that process and help search the configuration space to discover the best set of compilation options: </p>
<h3 id="faustbench">faustbench</h3>
<p>The <strong>faustbench</strong> tool uses the C++ backend to generate a set of C++ files produced with different Faust compiler options. All files are then compiled in a unique binary that will measure DSP CPU of all versions of the compiled DSP. The tool is supposed to be launched in a terminal, but it can be used to generate an iOS project, ready to be launched and tested in Xcode. A more complete documentation is available on the <a href="https://github.com/grame-cncm/faust/tree/master-dev/tools/benchmark#faustbench">this page</a>.</p>
<h3 id="faustbench-llvm">faustbench-llvm</h3>
<p>The <strong>faustbench-llvm</strong> tool uses the <code>libfaust</code> library and its LLVM backend to dynamically compile DSP objects produced with different Faust compiler options, and then measure their DSP CPU usage. Additional Faust compiler options can be given beside the ones that will be automatically explored by the tool. A more complete documentation is available on the <a href="https://github.com/grame-cncm/faust/tree/master-dev/tools/benchmark#faustbench-llvm">this page</a>.</p>
<h3 id="dynamic-faust">dynamic-faust</h3>
<p>The <strong>dynamic-faust</strong> tool uses the dynamic compilation chain (based on the LLVM backend), and compiles a Faust DSP source to a LLVM IR (.ll), bicode (.bc), machine code (.mc) or object code (.o) output file. A more complete documentation is available on the <a href="https://github.com/grame-cncm/faust/tree/master-dev/tools/benchmark#dynamic-faust">this page</a>.</p>
<h3 id="optimizing-with-any-faust2xx-tool">Optimizing with any faust2xx tool</h3>
<p>All <code>faust2xx</code> tools compile in scalar mode by default, but can take any combination of optimal options (like <code>-vec -fun -vs 32 -dfs -mcd 32</code> for instance) the previously described tools will automatically find. So by chaining the use of <strong>faustbench</strong> of <strong>faustbench-llvm</strong> to discover the best compilation options for a given DSP, then use them in the desired <strong>faust2xx</strong> tool, a CPU optimized standalone or plugin can be obtained. </p>
<p>Note that some <strong>faust2xx</strong> tools like <a href="https://github.com/grame-cncm/faust/tree/master-dev/architecture/max-msp"><code>faust2max6</code></a> or <code>faust2caqt</code> can internally call the <code>faustbench-llvm</code> tool to discover and later on use the best possible compilation options. </p>
<h2 id="compiling-for-multiple-cpus">Compiling for Multiple CPUs</h2>
<p>On modern CPUs, compiling native code dedicated to the target processor is critical to obtain the best possible performances. When using the C++ backend, the same C++ file can be compiled with <code>gcc</code> of <code>clang</code> for each possible target CPU using the appropriate <code>-march=cpu</code> option. When using the LLVM backend, the same LLVM IR code can be compiled into CPU specific machine code using the <code>dynamic-faust</code> tool. This step will typically be done using the best compilation options automatically found with the <code>faustbench</code> tool or <code>faustbench-llvm</code> tools. A specialized tool has been developed to combine all the possible options.</p>
<h3 id="faust2object">faust2object</h3>
<p>The <code>faust2object</code> tool  either uses the standard C++ compiler or the LLVM dynamic compilation chain (the <code>dynamic-faust</code> tool) to compile a Faust DSP to object code files (.o) and wrapper C++ header files for different CPUs. The DSP name is used in the generated C++ and object code files, thus allowing to generate distinct versions of the code that can finally be linked together in a single binary. A more complete documentation is available on the <a href="https://github.com/grame-cncm/faust/tree/master-dev/tools/benchmark#faust2object">this page</a>.</p>
<h2 id="debugging-the-dsp-code">Debugging the DSP Code</h2>
<p>The Faust compiler gives error messages when the written code is not syntactically or semantically correct. When a correct program is finally generated, it may still have numerical or precision issues only appearing at runtime <strong>(Note</strong>: this is mainly due the the non powerful enough signal interval computation of the compiler). This typically happens when using mathematical functions outside of their definition domain, like calling <code>log(0)</code> or <code>sqrt(-1)</code> at some point in the signal path. Those errors have to be then fixed by carefully checking signal range, like verifying the min/max values in <code>vslider/hslider/nentry</code> user-interface items. One way to detect and understand them is by running the code in a controlled and instrumented environment. A special version of the <code>interpreter</code> backend can be used for that purpose and is embedded in a dedicated testing tool. </p>
<p>Look at the <a href="https://faustdoc.grame.fr/manual/faq/#produced-nan-or-infinity-values-and-table-access">Produced NaN or INFINITY values and table access</a> section in the <a href="https://faustdoc.grame.fr/manual/faq/#frequently-asked-questions">FAQ</a>.</p>
<h3 id="interp-tracer">interp-tracer</h3>
<p>The <code>interp-tracer</code> tool runs and instruments the compiled program using the Interpreter backend. Various statistics on the code are collected and displayed while running and/or when closing the application, typically <code>FP_SUBNORMAL</code>, <code>FP_INFINITE</code> and <code>FP_NAN</code> values, or <code>INTEGER_OVERFLOW</code>, <code>CAST_INT_OVERFLOW</code>  and <code>DIV_BY_ZERO</code> operations, or <code>LOAD/STORE</code> errors. A more complete documentation is available on the <a href="https://github.com/grame-cncm/faust/tree/master-dev/tools/benchmark#interp-tracer">this page</a>.</p>
<h3 id="debugging-at-runtime">Debugging at Runtime</h3>
<p>On macOS, the <a href="https://faustdoc.grame.fr/manual/tools/#faust2caqt">faust2caqt</a> script has a <code>-me</code> option to catch math computation exceptions (floating point exceptions and integer div-by-zero or overflow) at runtime. Developers can possibly use the <a href="https://github.com/grame-cncm/faust/blob/master-dev/architecture/faust/dsp/dsp-checker.h#L42">dsp_me_checker</a> class to decorate a given DSP object with the math computation exception handling code. </p>
<h3 id="additional-resources">Additional Resources</h3>
<p>Handling infinity and not-a-number (NaN) the right way still remains a tricky problem that is not completely handled in the current version of the compiler. Dario Sanfilippo <a href="https://www.dariosanfilippo.com/blog/2020/handling_inf_nan_values_in_faust_and_cpp/">blog post</a> is a very helpful summary of the situation with a lot of practical solutions to <a href="https://github.com/dariosanfilippo/realfaust/blob/main/realfaust.lib">write safer DSP code</a>.  </p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2020-2021 <a href="https://www.grame.fr">Grame-CNCM</a></p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
