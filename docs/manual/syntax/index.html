<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Faust Syntax - Faust Documentation</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="/css/quickref.css" rel="stylesheet">
        <link href="/rail/railroad-diagrams.css" rel="stylesheet">

        <script src="../../js/jquery-3.6.0.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../.."><img src="../../img/faustText.svg" width="150px"> </a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Manual <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../introduction/" class="dropdown-item">Introduction</a>
</li>
                                    
<li>
    <a href="../overview/" class="dropdown-item">Overview of the Faust Universe</a>
</li>
                                    
<li>
    <a href="../quick-start/" class="dropdown-item">Quick Start</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Faust Syntax</a>
</li>
                                    
<li>
    <a href="../errors/" class="dropdown-item">Error Messages</a>
</li>
                                    
<li>
    <a href="../compiler/" class="dropdown-item">Using the Compiler</a>
</li>
                                    
<li>
    <a href="../options/" class="dropdown-item">Compiler Options</a>
</li>
                                    
<li>
    <a href="../tools/" class="dropdown-item">faust2[...] Tools</a>
</li>
                                    
<li>
    <a href="../architectures/" class="dropdown-item">Architecture Files</a>
</li>
                                    
<li>
    <a href="../embedding/" class="dropdown-item">Embedding the Compiler</a>
</li>
                                    
<li>
    <a href="../optimizing/" class="dropdown-item">Optimizing the Code</a>
</li>
                                    
<li>
    <a href="../debugging/" class="dropdown-item">Debugging the Code</a>
</li>
                                    
<li>
    <a href="../deploying/" class="dropdown-item">Deploying on the Web</a>
</li>
                                    
<li>
    <a href="../remote/" class="dropdown-item">Remote Compilation</a>
</li>
                                    
<li>
    <a href="../mathdoc/" class="dropdown-item">Mathematical Documentation</a>
</li>
                                    
<li>
    <a href="../osc/" class="dropdown-item">OSC Support</a>
</li>
                                    
<li>
    <a href="../http/" class="dropdown-item">HTTP Support</a>
</li>
                                    
<li>
    <a href="../midi/" class="dropdown-item">MIDI Support</a>
</li>
                                    
<li>
    <a href="../soundfiles/" class="dropdown-item">Soundfiles Support</a>
</li>
                                    
<li>
    <a href="../community/" class="dropdown-item">Community</a>
</li>
                                    
<li>
    <a href="../faq/" class="dropdown-item">Frequently Asked Questions</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Examples <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../examples/ambisonics/" class="dropdown-item"> ambisonics </a>
</li>
                                    
<li>
    <a href="../../examples/analysis/" class="dropdown-item"> analysis </a>
</li>
                                    
<li>
    <a href="../../examples/bela/" class="dropdown-item"> bela </a>
</li>
                                    
<li>
    <a href="../../examples/delayEcho/" class="dropdown-item"> delayEcho </a>
</li>
                                    
<li>
    <a href="../../examples/dynamic/" class="dropdown-item"> dynamic </a>
</li>
                                    
<li>
    <a href="../../examples/filtering/" class="dropdown-item"> filtering </a>
</li>
                                    
<li>
    <a href="../../examples/gameaudio/" class="dropdown-item"> gameaudio </a>
</li>
                                    
<li>
    <a href="../../examples/generator/" class="dropdown-item"> generator </a>
</li>
                                    
<li>
    <a href="../../examples/misc/" class="dropdown-item"> misc </a>
</li>
                                    
<li>
    <a href="../../examples/phasing/" class="dropdown-item"> phasing </a>
</li>
                                    
<li>
    <a href="../../examples/physicalModeling/" class="dropdown-item"> physicalModeling </a>
</li>
                                    
<li>
    <a href="../../examples/pitchShifting/" class="dropdown-item"> pitchShifting </a>
</li>
                                    
<li>
    <a href="../../examples/psychoacoustic/" class="dropdown-item"> psychoacoustic </a>
</li>
                                    
<li>
    <a href="../../examples/reverb/" class="dropdown-item"> reverb </a>
</li>
                                    
<li>
    <a href="../../examples/SAM/" class="dropdown-item"> SAM </a>
</li>
                                    
<li>
    <a href="../../examples/smartKeyboard/" class="dropdown-item"> smartKeyboard </a>
</li>
                                    
<li>
    <a href="../../examples/spat/" class="dropdown-item"> spat </a>
</li>
                                    
<li>
    <a href="../../rsrc/examples.zip" class="dropdown-item"> Download examples </a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tutorials <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item">Faust & JUCE</a>
</li>
                                    
<li>
    <a href="../../tutorials/teensy/" class="dropdown-item">DSP on the Teensy With Faust</a>
</li>
                                    
<li>
    <a href="../../tutorials/esp32/" class="dropdown-item">DSP on the ESP-32 With Faust</a>
</li>
                                    
<li>
    <a href="../../tutorials/basic-osc/" class="dropdown-item">Making a Sine Oscillator From Scratch</a>
</li>
                                    
<li>
    <a href="../../tutorials/summation/" class="dropdown-item">RMS and Summation in Faust</a>
</li>
                                    
<li>
    <a href="../../tutorials/box-api/" class="dropdown-item">Using the box API</a>
</li>
                                    
<li>
    <a href="../../tutorials/signal-api/" class="dropdown-item">Using the signal API</a>
</li>
                                    
<li>
    <a href="../../tutorials/julia/" class="dropdown-item">Using Faust in Julia</a>
</li>
                                    
<li>
    <a href="../../tutorials/cmajor/" class="dropdown-item">Using Faust in Cmajor</a>
</li>
                                    
<li>
    <a href="../../tutorials/jsfx/" class="dropdown-item">Using Faust in JSFX</a>
</li>
                                    
<li>
    <a href="../../tutorials/rnbo/" class="dropdown-item">Using Faust in RNBO with codebox~</a>
</li>
                                    
<li>
    <a href="../../tutorials/debugging/" class="dropdown-item">Advanced debugging with interp-tracer</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Workshops <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../workshops/2018-12-01-paw/" class="dropdown-item"> 2018-12-01 PAW </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-03-24-faust-citi/" class="dropdown-item"> 2020-03-24 CITI </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-101/" class="dropdown-item"> 2020-04-10 Faust 101 </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item"> 2020-04-10 Faust & JUCE </a>
</li>
                                    
<li>
    <a href="../../workshops/2020-11-21-faust-vcvrack/" class="dropdown-item"> 2020-11-21 Faust & VCV Rack </a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        
        

        <div class="container">
            <div class="row"><div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#faust-syntax" class="nav-link">Faust Syntax</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#faust-program" class="nav-link">Faust Program</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#variants" class="nav-link">Variants</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#a-simple-program" class="nav-link">A Simple Program</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#statements" class="nav-link">Statements</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#metadata" class="nav-link">Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#global-metadata" class="nav-link">Global Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#function-metadata" class="nav-link">Function Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#standard-metadata" class="nav-link">Standard Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#imports" class="nav-link">Imports</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#documentation-tags" class="nav-link">Documentation Tags</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#definitions" class="nav-link">Definitions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#simple-definitions" class="nav-link">Simple Definitions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#function-definitions" class="nav-link">Function Definitions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#definitions-with-pattern-matching" class="nav-link">Definitions With Pattern Matching</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#expressions" class="nav-link">Expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#constant-numerical-expressions" class="nav-link">Constant Numerical Expressions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#diagram-expressions" class="nav-link">Diagram Expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#diagram-composition-operations" class="nav-link">Diagram Composition Operations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#parallel-composition" class="nav-link">Parallel Composition</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#sequential-composition" class="nav-link">Sequential Composition</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#split-composition" class="nav-link">Split Composition</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#merge-composition" class="nav-link">Merge Composition</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#recursive-composition" class="nav-link">Recursive Composition</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#inputs-and-outputs-of-an-expression" class="nav-link">Inputs and Outputs of an Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#iterations" class="nav-link">Iterations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#par-iteration" class="nav-link">par Iteration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#seq-iteration" class="nav-link">seq Iteration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#sum-iteration" class="nav-link">sum Iteration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#prod-iteration" class="nav-link">prod Iteration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#infix-notation-and-other-syntax-extensions" class="nav-link">Infix Notation and Other Syntax Extensions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#infix-operators" class="nav-link">Infix Operators</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#prefix-notation" class="nav-link">Prefix Notation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#partial-application" class="nav-link">Partial Application</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#time-expression" class="nav-link">' Time Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#time-expression_1" class="nav-link">@ Time Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#environment-expressions" class="nav-link">Environment Expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#with-expression" class="nav-link">with Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#letrec-expression" class="nav-link">letrec Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#environment-expression" class="nav-link">environment Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#access-expression" class="nav-link">Access Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#library-expression" class="nav-link">library Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#component-expression" class="nav-link">component Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#explicit-substitution" class="nav-link">Explicit Substitution</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#foreign-expressions" class="nav-link">Foreign Expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#foreign-function-declaration" class="nav-link">Foreign function declaration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#signature" class="nav-link">Signature</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#types" class="nav-link">Types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#foreign-variables-and-constants" class="nav-link">Foreign Variables and Constants</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#include-file" class="nav-link">Include File</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#library-file" class="nav-link">Library File</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#applications-and-abstractions" class="nav-link">Applications and Abstractions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#abstractions" class="nav-link">Abstractions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#applications" class="nav-link">Applications</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#unapplied-abstractions" class="nav-link">Unapplied abstractions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#pattern-matching" class="nav-link">Pattern Matching</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#primitives" class="nav-link">Primitives</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#numbers" class="nav-link">Numbers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#route-primitive" class="nav-link">route Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#waveform-primitive" class="nav-link">waveform Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#soundfile-primitive" class="nav-link">soundfile Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#c-equivalent-primitives" class="nav-link">C-Equivalent Primitives</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#integer-number" class="nav-link">Integer Number</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#floating-point-number" class="nav-link">Floating Point Number</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#identity-function" class="nav-link">Identity Function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#cut-primitive" class="nav-link">Cut Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#int-primitive" class="nav-link">int Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#float-primitive" class="nav-link">float Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#add-primitive" class="nav-link">Add Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#subtract-primitive" class="nav-link">Subtract Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#multiply-primitive" class="nav-link">Multiply Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#divide-primitive" class="nav-link">Divide Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#power-primitive" class="nav-link">Power Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#modulo-primitive" class="nav-link">Modulo Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#and-primitive" class="nav-link">AND Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#or-primitive" class="nav-link">OR Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#xor-primitive" class="nav-link">XOR Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#left-shift-primitive" class="nav-link">Left Shift Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#right-shift-primitive" class="nav-link">Right Shift Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#smaller-than-primitive" class="nav-link">Smaller Than Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#smaller-or-equal-than-primitive" class="nav-link">Smaller or Equal Than Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#greater-than-primitive" class="nav-link">Greater Than Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#greater-or-equal-than-primitive" class="nav-link">Greater or Equal Than Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#equal-to-primitive" class="nav-link">Equal to Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#different-than-primitive" class="nav-link">Different Than Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#mathh-equivalent-primitives" class="nav-link">math.h-Equivalent Primitives</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#acos-primitive" class="nav-link">acos Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#asin-primitive" class="nav-link">asin Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#atan-primitive" class="nav-link">atan Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#atan2-primitive" class="nav-link">atan2 Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#cos-primitive" class="nav-link">cos Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#sin-primitive" class="nav-link">sin Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#tan-primitive" class="nav-link">tan Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#exp-primitive" class="nav-link">exp Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#log-primitive" class="nav-link">log Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#log10-primitive" class="nav-link">log10 Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#pow-primitive" class="nav-link">pow Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#sqrt-primitive" class="nav-link">sqrt Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#abs-primitive" class="nav-link">abs Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#min-primitive" class="nav-link">min Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#max-primitive" class="nav-link">max Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#fmod-primitive" class="nav-link">fmod Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#remainder-primitive" class="nav-link">remainder Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#floor-primitive" class="nav-link">floor Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#ceil-primitive" class="nav-link">ceil Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#rint-primitive" class="nav-link">rint Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#round-primitive" class="nav-link">round Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#delay-primitives-and-modifiers" class="nav-link">Delay Primitives and Modifiers</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#mem-primitive" class="nav-link">mem Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#modifier" class="nav-link">' Modifier</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#primitive" class="nav-link">@ Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#table-primitives" class="nav-link">Table Primitives</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#rdtable-primitive" class="nav-link">rdtable Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#rwtable-primitive" class="nav-link">rwtable Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#selector-primitives" class="nav-link">Selector Primitives</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#select2-primitive" class="nav-link">select2 Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#select3-primitive" class="nav-link">select3 Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#user-interface-primitives-and-configuration" class="nav-link">User Interface Primitives and Configuration</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#button-primitive" class="nav-link">button Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#checkbox-primitive" class="nav-link">checkbox Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#hslider-primitive" class="nav-link">hslider Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#vslider-primitive" class="nav-link">vslider Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#nentry-primitive" class="nav-link">nentry Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#hgroup-primitive" class="nav-link">hgroup Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#vgroup-primitive" class="nav-link">vgroup Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#tgroup-primitive" class="nav-link">tgroup Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#vbargraph-primitive" class="nav-link">vbargraph Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#hbargraph-primitive" class="nav-link">hbargraph Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#attach-primitive" class="nav-link">attach Primitive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#variable-parts-of-a-label" class="nav-link">Variable Parts of a Label</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#labels-as-pathnames" class="nav-link">Labels as Pathnames</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#smoothing" class="nav-link">Smoothing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#links-to-generated-code" class="nav-link">Links to Generated Code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#ui-label-metadata" class="nav-link">UI Label Metadata</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#ordering-ui-elements" class="nav-link">Ordering UI Elements</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#global-ui-metadata" class="nav-link">Global UI Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#styleknob-metadata" class="nav-link">[style:knob] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#stylemenu-metadata" class="nav-link">[style:menu] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#styleradio-metadata" class="nav-link">[style:radio] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#styleled-metadata" class="nav-link">[style:led] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#stylenumerical-metadata" class="nav-link">[style:numerical] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#unitdb-metadata" class="nav-link">[unit:dB] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#unitxx-metadata" class="nav-link">[unit:xx] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#scalexx-metadata" class="nav-link">[scale:xx] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#tooltipxx-metadata" class="nav-link">[tooltip:xx] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#hidden01-metadata" class="nav-link">[hidden:0|1] Metadata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#sensors-control-metadatas" class="nav-link">Sensors Control Metadatas</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#widget-modulation" class="nav-link">Widget Modulation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#target-widgets" class="nav-link">Target Widgets</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#modulators" class="nav-link">Modulators</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9 main-container" role="main">

<h1 id="faust-syntax">Faust Syntax</h1>
<!-- TODO we should make a new introductory figure here and add some comments
about it. It'd be nice to make it interactive so that when people click on it,
they are brought to the right section. -->

<h2 id="faust-program">Faust Program</h2>
<p>A Faust program is essentially a list of <em>statements</em>. These statements can be <em>metadata declarations</em> (either <a href="#global-metadata">global metadata</a> or <a href="#function-metadata">function metadata</a>), <a href="#imports"><em>imports</em></a>, <a href="#definitions"><em>definitions</em></a>, and <a href="#documentation-tags"><em>documentation tags</em></a>, with optional C++ style (<code>//...</code> and <code>/*...*/</code>) comments.</p>
<h3 id="variants">Variants</h3>
<p>Some statements (<a href="#imports"><em>imports</em></a>, <a href="#definitions"><em>definitions</em></a>) can be preceded by a <em>variantlist</em>, composed of <em>variants</em> which can be <code>singleprecision</code>, <code>doubleprecision</code>, <code>quadprecision</code> or <code>fixedpointprecision</code>. This allows some <code>imports</code> and <code>definitions</code> to be effective only for a (or several) specific float precision option in the compiler (that is either <code>-single</code>, <code>-double</code>, <code>-quad</code> or <code>-fx</code> respectively). A typical use-case is the definition of floating point constants in the <code>maths.lib</code> library with the following lines:</p>
<pre><code>singleprecision MAX = 3.402823466e+38;
doubleprecision MAX = 1.7976931348623158e+308;
</code></pre>
<h3 id="a-simple-program">A Simple Program</h3>
<p>Here is a short Faust program that implements of a simple noise generator (called from the <code>noises.lib</code> Faust library). It exhibits various kind of statements: two <a href="#global-metadata"><em>global metadata</em></a> declarations, an <a href="#imports"><em>imports</em></a>, a <em>comment</em>, and a <a href="#definitions"><em>definition</em></a>. We will study later how <a href="#documentation-tags"><em>documentation statements</em></a> work:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust0/exfaust0.svg" class="mx-auto d-block">
<faust-editor><!--

declare name "Noise";
declare copyright "(c)GRAME 2018";

import("stdfaust.lib");

// noise level controlled by a slider
process = no.noise * hslider("gain",0,0,1,0.1);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>The keyword <code>process</code> is the equivalent of <code>main</code> in C/C++. Any Faust program, to be valid, must at least define <code>process</code>.</p>
<h2 id="statements">Statements</h2>
<p>The <em>statements</em> of a Faust program are of four kinds: </p>
<ul>
<li><em>metadata declarations</em>, </li>
<li><em>file imports</em>, </li>
<li><em>definitions</em>,</li>
<li><em>documentation</em>. </li>
</ul>
<p>All statements but <em>documentation</em> end with a semicolon <code>;</code>. </p>
<h3 id="metadata">Metadata</h3>
<p>Metadata allow us to add elements which are not part of the language to Faust code. These can range to the name of a Faust program, its author, to potential compilation options or user interface element customizations.</p>
<p>There are three different types of metadata in Faust:</p>
<ul>
<li><a href="#global-metadata">Global Metadata</a>: metadata global to a Faust code</li>
<li><a href="#function-metadata">Function Metadata</a>: metadata specific to a function</li>
<li><a href="#ui-label-metadata">UI Metadata</a>: metadata specific to a UI element</li>
</ul>
<p>Note that some <a href="#global-metadata">Global Metadata</a> have standard names and can be used for specific tasks. Their role is described in the <a href="#standard-metadata">Standard Metadata</a> section.</p>
<h3 id="global-metadata">Global Metadata</h3>
<p>All global metadata declaration in Faust start with <code>declare</code>, followed by a key and a string. For example:</p>
<pre><code>declare name &quot;Noise&quot;;
</code></pre>
<p>allows us to specify the name of a Faust program in its whole. </p>
<p>Unlike regular comments, metadata declarations will appear in the C++ code generated by the Faust compiler. A good practice is to start a Faust program with some standard declarations:</p>
<pre><code>declare name &quot;MyProgram&quot;;
declare author &quot;MySelf&quot;;
declare copyright &quot;MyCompany&quot;;
declare version &quot;1.00&quot;;
declare license &quot;BSD&quot;; 
</code></pre>
<h3 id="function-metadata">Function Metadata</h3>
<p>Metadata can be associated to a specific function. In that case, <code>declare</code> is followed by the name of the function, a key, and a string. For example:</p>
<pre><code>declare add author &quot;John Doe&quot;
add = +;
</code></pre>
<p>This is very useful when a library has several contributors and that functions potentially have different license terms, etc. </p>
<h3 id="standard-metadata">Standard Metadata</h3>
<p>There exists a series of standard <a href="#global-metadata">global metadata</a> in Faust whose role role is described in the following table:</p>
<table>
<thead>
<tr>
<th align="center">Metadata</th>
<th>Role</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>declare options "[key0:value][key1:value]"</code></td>
<td>This metadata can be used to specify various options associated to a Faust code such as the fact its polyphonic, if it should have OSC, MIDI support, etc. Specific <code>keys</code> usable with this metadata are described throughout this documentation.</td>
</tr>
<tr>
<td align="center"><code>declare interface "xxx"</code></td>
<td>Specifies an interface replacing the standard Faust UI.</td>
</tr>
</tbody>
</table>
<!-- TODO: some are missing here: incomplete -->

<h3 id="imports">Imports</h3>
<p>File imports allow us to import definitions from other source files.  </p>
<p>For example <code>import("maths.lib");</code> imports the definitions of the <a href="https://faustlibraries.grame.fr/libs/maths/"><code>maths.lib</code></a> library.</p>
<p>The most common file to be imported is the <code>stdfaust.lib</code> library which gives access to all the standard Faust libraries from a single point:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust1/exfaust1.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = os.osc(440); // the "hello world" of computer music

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h3 id="documentation-tags">Documentation Tags</h3>
<p>Documentation statements are optional and typically used to control the generation of the mathematical documentation of a Faust program. This documentation system is detailed in the <a href="../mathdoc">Mathematical Documentation</a> chapter. In this section we essentially describe the documentation statements syntax.</p>
<p>A documentation statement starts with an opening <code>&lt;mdoc&gt;</code> tag and ends with a closing <code>&lt;/mdoc&gt;</code> tag. Free text content, typically in Latex format, can be placed in between these two tags. <!-- Why not markdown? --></p>
<p><img src="img/documentation.svg" class="mx-auto d-block"></p>
<p>Moreover, optional sub-tags can be inserted in the text content itself to require the generation, at the insertion point, of mathematical <em>equations</em>, graphical <em>block-diagrams</em>, Faust source code <em>listing</em> and explanation <em>notice</em>.</p>
<p><img src="img/equation.svg" class="mx-auto d-block"></p>
<p>The generation of the mathematical equations of a Faust expression can be requested by placing this expression between an opening <code>&lt;equation&gt;</code> and a closing <code>&lt;/equation&gt;</code> tag. The expression is evaluated within the lexical context of the Faust program.</p>
<p><img src="img/diagram.svg" class="mx-auto d-block"></p>
<p>Similarly, the generation of the graphical block-diagram of a Faust expression can be requested by placing this expression between an opening <code>&lt;diagram&gt;</code> and a closing <code>&lt;/diagram&gt;</code> tag. The expression is evaluated within the lexical context of the Faust program.</p>
<p><img src="img/metadata.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;metadata&gt;</code> tags allow to reference Faust <a href="#global-metadata">global metadatas</a>, calling the corresponding keyword.</p>
<p><img src="img/notice.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;notice/&gt;</code> empty-element tag is used to generate the conventions used in the mathematical equations.</p>
<p><img src="img/listing.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;listing/&gt;</code> empty-element tag is used to generate the listing of the Faust program. Its three attributes <code>mdoctags</code>, <code>dependencies</code>, and <code>distributed</code> enable or disable respectively <code>&lt;mdoc&gt;</code> tags, other files dependencies and distribution of interleaved Faust code between <code>&lt;mdoc&gt;</code> sections.</p>
<h2 id="definitions">Definitions</h2>
<p>A <em>definition</em> associates an identifier with an expression. Definitions are essentially a convenient shortcut avoiding to type long expressions. During compilation, more precisely during the evaluation stage, identifiers are replaced by their definitions. It is therefore always equivalent to use an identifier or directly its definition. Please note that multiple definitions of a same identifier are not allowed, unless it is a pattern matching based definition.</p>
<h3 id="simple-definitions">Simple Definitions</h3>
<p>The syntax of a simple definition is:</p>
<pre><code>identifier = expression;
</code></pre>
<p>For example here is the definition of <code>random</code>, a simple pseudo-random number generator:</p>
<pre><code>random = +(12345) ~ *(1103515245);
</code></pre>
<h2 id="function-definitions">Function Definitions</h2>
<p>Definitions with formal parameters correspond to functions definitions.</p>
<p><img src="img/functionDefinition.jpg" class="mx-auto d-block" width="60%"></p>
<p>For example the definition of <code>linear2db</code>, a function that converts linear values to decibels, is:</p>
<pre><code>linear2db(x) = 20*log10(x);
</code></pre>
<p>Please note that this notation is only a convenient alternative to the direct use of <a href="#abstractions"><em>lambda-abstractions</em></a> (also called anonymous functions). The following is an equivalent definition of <code>linear2db</code> using a lambda-abstraction:</p>
<pre><code>linear2db = \(x).(20*log10(x));
</code></pre>
<h2 id="definitions-with-pattern-matching">Definitions With Pattern Matching</h2>
<p>Moreover, formal parameters can also be full expressions representing patterns: </p>
<p><img src="img/patternMatching.jpg" class="mx-auto d-block" width="60%"></p>
<p>This powerful mechanism allows to algorithmically create and manipulate block diagrams expressions. Let's say that you want to describe a function to duplicate an expression several times in parallel:</p>
<pre><code>duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);
</code></pre>
<p>Note that this last definition is a convenient alternative to the more verbose:</p>
<pre><code>duplicate = case { 
  (1,x) =&gt; x; 
  (n,x) =&gt; x, duplicate(n-1,x); 
};
</code></pre>
<p>A use case for <code>duplicate</code> could be to put 5 white noise generators in parallel:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust2/exfaust2.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);
process = duplicate(5,no.noise);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Here is another example to count the number of elements of a list. Please note that we simulate lists using <a href="#parallel-composition">parallel composition</a>: <code>(1,2,3,5,7,11)</code>. The main limitation of this approach is that there is no empty list. Moreover lists of only one element are represented by this element:</p>
<pre><code>count((x,xs)) = 1+count(xs);
count(x) = 1;
</code></pre>
<p>If we now write <code>count(duplicate(10,666))</code>, the expression will be evaluated as <code>10</code>.</p>
<p>Note that the order of pattern matching rules matters. The more specific rules must precede the more general rules. When this order is not respected, as in:</p>
<pre><code>count(x) = 1;
count((x,xs)) = 1+count(xs);
</code></pre>
<p>the first rule will always match and the second rule will never be called.</p>
<p>Please note that number arguments in pattern matching rules are typically <a href="#constant-numerical-expressions">constant numerical expressions</a>, so can be the result of more complex expressions involving computations done at compile-time.</p>
<h2 id="expressions">Expressions</h2>
<p>Despite its textual syntax, Faust is conceptually a block-diagram language. Faust expressions represent DSP block-diagrams and are assembled from primitive ones using various <em>composition</em> operations. More traditional <em>numerical</em> expressions in infix notation are also possible. Additionally Faust provides time based expressions, like delays, expressions related to lexical environments, expressions to interface with foreign function and lambda expressions.</p>
<p><img src="img/expression.svg" class="mx-auto d-block"></p>
<h3 id="constant-numerical-expressions">Constant Numerical Expressions</h3>
<p>Some language primitives (like <code>rdtable</code>, <code>rwtable</code>, <code>hslider</code> etc.) take constant numbers as some of their parameters. This is the case also for expressions using pattern matching techniques. Those numbers can be directly given in the code, but can also be computed by more complex expressions <em>which have to produce numbers at compile time</em>. We will refer to them as <a href="#constant-numerical-expressions">constant numerical expressions</a> in the documentation.</p>
<h3 id="diagram-expressions">Diagram Expressions</h3>
<p>Diagram expressions are assembled from primitive ones using either binary composition operations or high level iterative constructions.</p>
<p><img src="img/diagramexp.svg" class="mx-auto d-block"></p>
<h4 id="diagram-composition-operations">Diagram Composition Operations</h4>
<p>Five binary <em>composition operations</em> are available to combine block-diagrams: </p>
<ul>
<li><a href="#recursive-composition"><em>recursion</em></a> (<code>~</code>),</li>
<li><a href="#parallel-composition"><em>parallel</em></a> (<code>,</code>),</li>
<li><a href="#sequential-composition"><em>sequential</em></a> (<code>:</code>),</li>
<li><a href="#split-composition"><em>split</em></a> (<code>&lt;:</code>),</li>
<li><a href="#merge-composition"><em>merge</em></a> (<code>:&gt;</code>).</li>
</ul>
<p>One can think of each of these composition operations as a particular way to connect two block diagrams. </p>
<p><img src="img/diagcomposition.svg" class="mx-auto d-block"></p>
<p>To describe precisely how these connections are done, we have to introduce some notation. The number of inputs and outputs of a block-diagram <script type="math/tex">A</script> are expressed as <script type="math/tex">\mathrm{inputs}(A)</script> and <script type="math/tex">\mathrm{outputs}(A)</script>. The inputs and outputs themselves are respectively expressed as: <script type="math/tex">[0]A</script>, <script type="math/tex">[1]A</script>, <script type="math/tex">[2]A</script>, <script type="math/tex">\ldots</script> and
<script type="math/tex">A[0]</script>, <script type="math/tex">A[1]</script>, <script type="math/tex">A[2]</script>, etc. </p>
<p>For each composition operation between two block-diagrams <script type="math/tex">A</script> and <script type="math/tex">B</script> we will describe the connections <script type="math/tex">A[i]\rightarrow [j]B</script> that are created and the constraints on their relative numbers of inputs and outputs.</p>
<p>The priority and associativity of this five operations are:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Priority</th>
<th>Association</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expression ~ expression</code></td>
<td>4</td>
<td>left</td>
<td>Recursive Composition</td>
</tr>
<tr>
<td><code>expression , expression</code></td>
<td>3</td>
<td>right</td>
<td>Parallel Composition</td>
</tr>
<tr>
<td><code>expression : expression</code></td>
<td>2</td>
<td>right</td>
<td>Sequential Composition</td>
</tr>
<tr>
<td><code>expression &lt;: expression</code></td>
<td>1</td>
<td>right</td>
<td>Split Composition</td>
</tr>
<tr>
<td><code>expression :&gt; expression</code></td>
<td>1</td>
<td>right</td>
<td>Merge Composition</td>
</tr>
</tbody>
</table>
<p>Please note that a higher priority value means a higher priority in the evaluation order. There is a companion table that gives the associativity of each numerical operator in infix expressions.</p>
<h4 id="parallel-composition">Parallel Composition</h4>
<p>The <em>parallel composition</em> (e.g., <code>(A,B)</code>) is probably the simplest one. It places the two block-diagrams one on top of the other, without connections. The inputs of the resulting block-diagram are the inputs of <code>A</code> and <code>B</code>. The outputs of the resulting block-diagram are the outputs of <code>A</code> and <code>B</code>. </p>
<p><em>Parallel composition</em> is an associative operation: <code>(A,(B,C))</code> and <code>((A,B),C)</code> are equivalents. When no parenthesis are used (e.g., <code>A,B,C,D</code>), Faust uses right associativity and therefore builds internally the expression <code>(A,(B,(C,D)))</code>. This organization is important to know when using pattern matching techniques on parallel compositions. </p>
<p><strong>Example: Oscillators in Parallel</strong></p>
<p><em>Parallel composition</em> can be used to put 3 oscillators of different kinds and frequencies in parallel, which will result in a Faust program with 3 outputs:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust3/exfaust3.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = os.osc(440),os.sawtooth(550),os.triangle(660);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><strong>Example: Stereo Effect</strong></p>
<p><em>Parallel composition</em> can be used to easily turn a mono effect into a stereo one which will result in a Faust program with 2 inputs and 2 outputs:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust4/exfaust4.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
level = 1;
process = ve.autowah(level),ve.autowah(level);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that there's a better to write this last example using the <a href="#par-iteration"><code>par</code> iteration</a>: </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust5/exfaust5.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
level = 1;
process = par(i,2,ve.autowah(level));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="sequential-composition">Sequential Composition</h4>
<p>The <em>sequential composition</em>  (e.g., <code>A:B</code>) expects:</p>
<p>
<script type="math/tex; mode=display">\mathrm{outputs}(A)=\mathrm{inputs}(B)</script>
</p>
<p>It connects each output of <script type="math/tex">A</script> to the corresponding input of <script type="math/tex">B</script>: </p>
<p>
<script type="math/tex; mode=display">A[i]\rightarrow[i]B</script>
</p>
<p><em>Sequential composition</em> is an associative operation: <code>(A:(B:C))</code> and <code>((A:B):C)</code> are equivalents. When no parenthesis are used, like in <code>A:B:C:D</code>, Faust uses right associativity and therefore builds internally the expression <code>(A:(B:(C:D)))</code>.</p>
<p><strong>Example: Sine Oscillator</strong></p>
<p>Since everything is considered as a signal generator in Faust, <em>sequential composition</em> can be simply used to pass an argument to a function:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust6/exfaust6.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = 440 : os.osc;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><strong>Example: Effect Chain</strong></p>
<p><em>Sequential composition</em> can be used to create an audio effect chain. Here we're plugging a guitar distortion to an autowah:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust7/exfaust7.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
drive = 0.6;
offset = 0;
autoWahLevel = 1;
process = ef.cubicnl(drive,offset) : ve.autowah(autoWahLevel);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="split-composition">Split Composition</h4>
<p>The <em>split composition</em> (e.g., <code>A&lt;:B</code>) operator is used to distribute the outputs of <script type="math/tex">A</script> to the inputs of <script type="math/tex">B</script>.</p>
<p>For the operation to be valid, the number of inputs of <script type="math/tex">B</script> must be a multiple of the number of outputs of <script type="math/tex">A</script>: </p>
<p>
<script type="math/tex; mode=display">\mathrm{outputs}(A).k=\mathrm{inputs}(B)</script>
</p>
<p>Each input <script type="math/tex">i</script> of <script type="math/tex">B</script> is connected to the output <script type="math/tex">i \bmod k</script> of <script type="math/tex">A</script>: </p>
<p>
<script type="math/tex; mode=display">A[i \bmod k]\rightarrow[i]B</script>
</p>
<p><strong>Example: Duplicating the Output of an Oscillator</strong></p>
<p><em>Split composition</em> can be used to duplicate signals. For example, the output of the following sawtooth oscillator is duplicated 3 times in parallel.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust8/exfaust8.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = os.sawtooth(440) <: _,_,_;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that this can be written in a more effective way by replacing <code>_,_,_</code> with <code>par(i,3,_)</code> using the <a href="#par-iteration"><code>par</code> iteration</a>.</p>
<p><strong>Example: Connecting a Mono Effect to a Stereo One</strong></p>
<p>More generally, the <em>split composition</em> can be used to connect a block with a certain number of output to a block with a greater number of inputs: </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust9/exfaust9.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
drive = 0.6;
offset = 0;
process = ef.cubicnl(drive,offset) <: dm.zita_light;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that an arbitrary number of signals can be split, for example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust10/exfaust10.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
drive = 0.6;
offset = 0;
process = par(i,2,ef.cubicnl(drive,offset)) <: par(i,2,dm.zita_light);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Once again, the only rule with this is that in the expression <code>A&lt;:B</code> the number of inputs of <code>B</code> has to be a multiple of the number of outputs of <code>A</code>.</p>
<!-- TODO: make sure that signal distribution rules are explained somewhere
else in the doc -->

<h4 id="merge-composition">Merge Composition</h4>
<p>The <em>merge composition</em> (e.g., <code>A:&gt;B</code>) is the dual of the <a href="#split-composition"><em>split composition</em></a>. The number of outputs of <script type="math/tex">A</script> must be a multiple of the number of inputs of <script type="math/tex">B</script>: </p>
<p>
<script type="math/tex; mode=display">\mathrm{outputs}(A)=k.\mathrm{inputs}(B)</script>
</p>
<p>Each output <script type="math/tex">i</script> of <script type="math/tex">A</script> is connected to the input <script type="math/tex">i \bmod k</script> of <script type="math/tex">B</script> : </p>
<p>
<script type="math/tex; mode=display">A[i]\rightarrow\ [i \bmod k]B</script>
</p>
<p>The <script type="math/tex">k</script> incoming signals of an input of <script type="math/tex">B</script> are summed together.</p>
<p><strong>Example: Summing Signals Together - Additive Synthesis</strong></p>
<p><em>Merge composition</em> can be used to sum an arbitrary number of signals together. Here's an example of a simple additive synthesizer (note that the result of the sum of the signals is divided by 3 to prevent clicking):</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust11/exfaust11.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,3000,0.01);
gain = hslider("gain",1,0,1,0.01);
gate = button("gate");
envelope = gain*gate : si.smoo;
process = os.osc(freq),os.osc(freq*2),os.osc(freq*3) :> /(3)*envelope;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>While the resulting block diagram will look slightly different, this is mathematically equivalent to:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust12/exfaust12.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,3000,0.01);
gain = hslider("gain",1,0,1,0.01);
gate = button("gate");
envelope = gain*gate : si.smoo;
process = (os.osc(freq) + os.osc(freq*2) + os.osc(freq*3))/(3)*envelope;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><strong>Example: Connecting a Stereo Effect to a Mono One</strong></p>
<p>More generally, the <em>merge composition</em> can be used to connect a block with a certain number of output to a block with a smaller number of inputs: </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust13/exfaust13.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
drive = 0.6;
offset = 0;
process = dm.zita_light :> ef.cubicnl(drive,offset);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that an arbitrary number of signals can be split, for example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust14/exfaust14.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
drive = 0.6;
offset = 0;
process = par(i,2,dm.zita_light) :> par(i,2,ef.cubicnl(drive,offset));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Once again, the only rule with this is that in the expression <code>A:&gt;B</code> the number of outputs of <code>A</code> has to be a multiple of the number of inputs of <code>B</code>.</p>
<h4 id="recursive-composition">Recursive Composition</h4>
<p>The <em>recursive composition</em> (e.g., <code>A~B</code>) is used to create cycles in the block-diagram in order to express recursive computations. It is the most complex operation in terms of connections.</p>
<p>To be applicable, it requires that:</p>
<p>
<script type="math/tex; mode=display">\mathrm{outputs}(A) \geq \mathrm{inputs}(B) and \mathrm{inputs}(A) \geq \mathrm{outputs}(B)</script>
</p>
<p>Each input of <script type="math/tex">B</script> is connected to the corresponding output of <script type="math/tex">A</script> via an implicit 1-sample delay:</p>
<p>
<script type="math/tex; mode=display">A[i]\stackrel{Z^{-1}}{\rightarrow}[i]B</script>
</p>
<p>and each output of <script type="math/tex">B</script> is connected to the corresponding input of <script type="math/tex">A</script>:</p>
<p>
<script type="math/tex; mode=display">B[i]\rightarrow [i]A</script>
</p>
<p>The inputs of the resulting block diagram are the remaining unconnected inputs of <script type="math/tex">A</script>. The outputs are all the outputs of <script type="math/tex">A</script>.</p>
<p><strong>Example: Timer</strong></p>
<p><em>Recursive composition</em> can be used to implement a "timer" that will count each sample starting at time <script type="math/tex">n=0</script>:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust15/exfaust15.svg" class="mx-auto d-block">
<faust-editor><!--

process = _~+(1);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>The difference equation corresponding to this program is:</p>
<p>
<script type="math/tex; mode=display">y(n) = y(n-1) + 1</script>
</p>
<p>an its output signal will look like: <script type="math/tex">(1,2,3,4,5,6,\dots)</script>. </p>
<p><strong>Example: One Pole Filter</strong></p>
<p><em>Recursive composition</em> can be used to implement a one pole filter with one line of code and just a few characters:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust16/exfaust16.svg" class="mx-auto d-block">
<faust-editor><!--

a1 = 0.999; // the pole
process = +~*(a1);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>The difference equation corresponding to this program is:</p>
<p>
<script type="math/tex; mode=display">y(n) = x(n) + a_{1}y(n-1)</script>
</p>
<p>Note that the one sample delay of the filter is implicit here so it doesn't have to be declared.</p>
<h4 id="inputs-and-outputs-of-an-expression">Inputs and Outputs of an Expression</h4>
<p>The number of inputs and outputs of a Faust expression can be known at compile time simply by using <code>inputs(expression)</code> and <code>outputs(expression)</code>.</p>
<p>For example, the number of outputs of a sine wave oscillator can be known simply by writing the following program:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust17/exfaust17.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = outputs(os.osc(440));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that Faust automatically simplified the expression by generating a program that just outputs <code>1</code>.</p>
<p>This type of construction is useful to define high order functions and build algorithmically complex block-diagrams. Here is an example to automatically reverse the order of the outputs of an expression.</p>
<pre><code>Xo(expr) = expr &lt;: par(i,n,ba.selector(n-i-1,n)) 
with { 
  n = outputs(expr);
};
</code></pre>
<p>And the inputs of an expression:</p>
<pre><code>Xi(expr) = si.bus(n) &lt;: par(i,n,ba.selector(n-i-1,n)) : expr 
with { 
  n = inputs(expr); 
};
</code></pre>
<p>For example <code>Xi(-)</code> will reverse the order of the two inputs of the substraction:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust18/exfaust18.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
Xi(expr) = si.bus(n) <: par(i,n,ba.selector(n-i-1,n)) : expr 
with { 
  n = inputs(expr); 
};
process = Xi(-);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="iterations">Iterations</h4>
<p>Iterations are analogous to <code>for(...)</code> loops in other languages and provide a convenient way to automate some complex block-diagram constructions. </p>
<p><img src="img/diagiteration.svg" class="mx-auto d-block"></p>
<p>The use and role of <a href="#par-iteration"><code>par</code></a>, <a href="#seq-iteration"><code>seq</code></a>, <a href="#sum-iteration"><code>sum</code></a>, and  <a href="#prod-iteration"><code>prod</code></a> are detailed in the following sections.</p>
<h4 id="par-iteration"><code>par</code> Iteration</h4>
<p>The <code>par</code> iteration can be used to duplicate an expression in parallel. Just like other types of iterations in Faust: </p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations, as an integer <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Simple Additive Synthesizer</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust19/exfaust19.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,3000,0.01);
gain = hslider("gain",1,0,1,0.01);
gate = button("gate");
envelope = gain*gate : si.smoo;
nHarmonics = 4;
process = par(i,nHarmonics,os.osc(freq*(i+1))) :> /(nHarmonics)*envelope;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator. Also, note that this example could be re-wrtitten using <a href="#sum-iteration"><code>sum</code> iteration</a> (see example in the corresponding section).</p>
<h4 id="seq-iteration"><code>seq</code> Iteration</h4>
<p>The <code>seq</code> iteration can be used to duplicate an expression in series. Just like other types of iterations in Faust: </p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations, as an integer <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Peak Equalizer</strong></p>
<p>The <a href="TODO"><code>fi.peak_eq</code></a> function of the Faust libraries implements a second order "peak equalizer" section (gain boost or cut near some frequency). When placed in series, it can be used to implement a full peak equalizer:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust20/exfaust20.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
nBands = 8;
filterBank(N) = hgroup("Filter Bank",seq(i,N,oneBand(i)))
with {
    oneBand(j) = vgroup("[%j]Band %a",fi.peak_eq(l,f,b))
    with {
        a = j+1; // just so that band numbers don't start at 0
        l = vslider("[2]Level[unit:db]",0,-70,12,0.01) : si.smoo;
        f = nentry("[1]Freq",(80+(1000*8/N*(j+1)-80)),20,20000,0.01) : si.smoo;
        b = f/hslider("[0]Q[style:knob]",1,1,50,0.01) : si.smoo;
    };
};
process = filterBank(nBands);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that <code>i</code> is used here at each iteration to compute various elements and to format some labels. Having user interface elements with different names is a way to force their differentiation in the generated interface.  </p>
<h4 id="sum-iteration"><code>sum</code> Iteration</h4>
<p>The <code>sum</code> iteration can be used to duplicate an expression as a sum. Just like other types of iterations in Faust: </p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations, as an integer <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Simple Additive Synthesizer</strong></p>
<p>The following example is just a slightly different version from the one presented in the <a href="#par-iteration"><code>par</code> iteration</a> section. While their block diagrams look slightly different, the generated code is exactly the same.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust21/exfaust21.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,3000,0.01);
gain = hslider("gain",1,0,1,0.01);
gate = button("gate");
envelope = gain*gate : si.smoo;
nHarmonics = 4;
process = sum(i,nHarmonics,os.osc(freq*(i+1)))/(nHarmonics)*envelope;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator.</p>
<h4 id="prod-iteration"><code>prod</code> Iteration</h4>
<p>The <code>prod</code> iteration can be used to duplicate an expression as a product. Just like other types of iterations in Faust: </p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations, as an integer <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Amplitude Modulation Synthesizer</strong></p>
<p>The following example implements an amplitude modulation synthesizer using an arbitrary number of oscillators thanks to the <code>prod</code> iteration:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust22/exfaust22.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("[0]freq",440,50,3000,0.01);
gain = hslider("[1]gain",1,0,1,0.01);
shift = hslider("[2]shift",0,0,1,0.01);
gate = button("[3]gate");
envelope = gain*gate : si.smoo;
nOscs = 4;
process = prod(i,nOscs,os.osc(freq*(i+1+shift)))*envelope;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator. Note that the <code>shift</code> parameter can be used to tune the frequency drift between each oscillator.</p>
<h3 id="infix-notation-and-other-syntax-extensions">Infix Notation and Other Syntax Extensions</h3>
<blockquote>
<p>Infix notation is commonly used in mathematics. It consists in placing the operand between the arguments as in <script type="math/tex">2+3</script>
</p>
</blockquote>
<p>Besides its algebra-based core syntax, Faust provides some syntax extensions, in particular the familiar <em>infix notation</em>. For example if you want to multiply two numbers, say <code>2</code> and <code>3</code>, you can write directly <code>2*3</code> instead of the equivalent core-syntax expression <code>2,3 : *</code>.</p>
<p>The <em>infix notation</em> is not limited to numbers or numerical expressions. Arbitrary expressions <code>A</code> and <code>B</code> can be used, provided that <code>A,B</code> has exactly two outputs. For example <code>_/2</code> is equivalent to <code>_,2:/</code> which divides the incoming signal by <code>2</code>. </p>
<p>Here are a few examples of equivalences:</p>
<table>
<thead>
<tr>
<th>Infix Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>2-3</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>2,3 : -</code></td>
</tr>
<tr>
<td><code>2*3</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>2,3 : *</code></td>
</tr>
<tr>
<td><code>_@7</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,7 : @</code></td>
</tr>
<tr>
<td><code>_/2</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,2 : /</code></td>
</tr>
<tr>
<td><code>A&lt;B</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>A,B : &lt;</code></td>
</tr>
</tbody>
</table>
<p>In case of doubts on the meaning of an infix expression, for example <code>_*_</code>, it is useful to translate it to its core syntax equivalent, here <code>_,_:*</code>, which is equivalent to <code>*</code>.</p>
<h4 id="infix-operators">Infix Operators</h4>
<p>Built-in primitives that can be used in infix notation are called <em>infix operators</em> and are listed below. Please note that a more detailed description of these operators is available <a href="#primitives">section on primitives</a>. </p>
<p><img src="img/infixop.svg" class="mx-auto d-block"></p>
<h5 id="comparison-operators">Comparison Operators</h5>
<p>Comparison operators compare two signals and produce a signal that is 1 when the comparison is true and 0 when the comparison is false. The priority and associativity of the comparison operators is given here:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Pri.</th>
<th>Assoc.</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expression &lt; expression</code></td>
<td>5</td>
<td>left</td>
<td>less than</td>
</tr>
<tr>
<td><code>expression &lt;= expression</code></td>
<td>5</td>
<td>left</td>
<td>less or equal</td>
</tr>
<tr>
<td><code>expression == expression</code></td>
<td>5</td>
<td>left</td>
<td>equal</td>
</tr>
<tr>
<td><code>expression != expression</code></td>
<td>5</td>
<td>left</td>
<td>different</td>
</tr>
<tr>
<td><code>expression &gt;= expression</code></td>
<td>5</td>
<td>left</td>
<td>greater or equal</td>
</tr>
<tr>
<td><code>expression &gt; expression</code></td>
<td>5</td>
<td>left</td>
<td>greater than</td>
</tr>
</tbody>
</table>
<h5 id="math-operators">Math Operators</h5>
<p>Math operators combine two signals and produce a resulting signal by applying a numerical operation on each sample.  The priority and associativity of the comparison operators is given here:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Pri.</th>
<th>Assoc.</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expression + expression</code></td>
<td>6</td>
<td>left</td>
<td>addition</td>
</tr>
<tr>
<td><code>expression - expression</code></td>
<td>6</td>
<td>left</td>
<td>subtraction</td>
</tr>
<tr>
<td><code>expression * expression</code></td>
<td>7</td>
<td>left</td>
<td>multiplication</td>
</tr>
<tr>
<td><code>expression / expression</code></td>
<td>7</td>
<td>left</td>
<td>division</td>
</tr>
<tr>
<td><code>expression % expression</code></td>
<td>7</td>
<td>left</td>
<td>modulo</td>
</tr>
<tr>
<td><code>expression ^ expression</code></td>
<td>8</td>
<td>left</td>
<td>power</td>
</tr>
</tbody>
</table>
<h5 id="bitwise-operators">Bitwise Operators</h5>
<p>Bitwise operators combine two signals and produce a resulting signal by applying a bitwise operation on each sample. The priority and associativity of the bitwise operators is given here:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Pri.</th>
<th>Assoc.</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expression | expression</code></td>
<td>6</td>
<td>left</td>
<td>bitwise or</td>
</tr>
<tr>
<td><code>expression &amp; expression</code></td>
<td>7</td>
<td>left</td>
<td>bitwise and</td>
</tr>
<tr>
<td><code>expression xor expression</code></td>
<td>7</td>
<td>left</td>
<td>bitwise xor</td>
</tr>
<tr>
<td><code>expression &lt;&lt; expression</code></td>
<td>7</td>
<td>left</td>
<td>bitwise left shift</td>
</tr>
<tr>
<td><code>expression &gt;&gt; expression</code></td>
<td>7</td>
<td>left</td>
<td>bitwise right shift</td>
</tr>
</tbody>
</table>
<h5 id="delay-operators">Delay operators</h5>
<p>Delay operators combine two signals and produce a resulting signal by applying a bitwise operation on each sample. The delay operator <code>@</code> allows to delay left handside expression by the amount defined by the right handside expression. The unary operator <code>’</code> delays the left handside expression by one sample. </p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Pri.</th>
<th>Assoc.</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expression @ expression</code></td>
<td>9</td>
<td>left</td>
<td>variable delay</td>
</tr>
<tr>
<td><code>expression'</code></td>
<td>10</td>
<td>left</td>
<td>one-sample delay</td>
</tr>
</tbody>
</table>
<h4 id="prefix-notation">Prefix Notation</h4>
<p>Beside <em>infix notation</em>, it is also possible to use <em>prefix notation</em>. The <em>prefix notation</em> is the usual mathematical notation for functions <script type="math/tex">f(x,y,z,\ldots)</script>, but extended to <em>infix operators</em>.</p>
<p>It consists in first having the operator, for example <code>/</code>, followed by its arguments between parentheses: <code>/(2,3)</code>: </p>
<table>
<thead>
<tr>
<th>Prefix Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*(2,3)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>2,3 : *</code></td>
</tr>
<tr>
<td><code>@(_,7)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,7 : @</code></td>
</tr>
<tr>
<td><code>/(_,2)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,2 : /</code></td>
</tr>
<tr>
<td><code>&lt;(A,B)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>A,B : &lt;</code></td>
</tr>
</tbody>
</table>
<h4 id="partial-application">Partial Application</h4>
<p>The <em>partial application</em> notation is a variant of the <em>prefix notation</em> in which not all arguments are given. For instance <code>/(2)</code> (divide by 2), <code>^(3)</code> (rise to the cube), and <code>@(512)</code> (delay by 512 samples) are examples of partial applications where only one argument is given. The result of a partial application is a function that "waits" for the remaining arguments. </p>
<p>When doing partial application with an <em>infix operator</em>, it is important to note that the supplied argument is not the first argument, but always the second one:</p>
<table>
<thead>
<tr>
<th>Prefix Partial Application Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+(C)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,C : *</code></td>
</tr>
<tr>
<td><code>-(C)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,C : -</code></td>
</tr>
<tr>
<td><code>&lt;(C)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,C : &lt;</code></td>
</tr>
<tr>
<td><code>/(C)</code></td>
<td>
<script type="math/tex">\equiv</script>
</td>
<td><code>_,C : /</code></td>
</tr>
</tbody>
</table>
<p>For commutative operations that doesn't matter. But for non-commutative ones, it is more "natural" to fix the second argument.  We use divide by 2 (<code>/(2)</code>) or rise to the cube (<code>^(3)</code>) more often than the other way around.</p>
<p>Please note that this rule only applies to infix operators, not to other primitives or functions. If you partially apply a regular function to a single argument, it will correspond to the first parameter.</p>
<p><strong>Example: Gain Controller</strong></p>
<p>The following example demonstrates the use of partial application in the context of a gain controller:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust23/exfaust23.svg" class="mx-auto d-block">
<faust-editor><!--

gain = hslider("gain",0.5,0,1,0.01);
process = *(gain);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h3 id="time-expression"><code>'</code> Time Expression</h3>
<p><code>'</code> is used to express a one sample delay. For example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust24/exfaust24.svg" class="mx-auto d-block">
<faust-editor><!--

process = _';

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>will delay the incoming signal by one sample. </p>
<p><code>'</code> time expressions can be chained, so the output signal of this program:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust25/exfaust25.svg" class="mx-auto d-block">
<faust-editor><!--

process = 1'';

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>will look like: <script type="math/tex">(0,0,1,1,1,1,\dots)</script>.</p>
<p>The <code>'</code> time expression is useful when designing filters, etc. and is equivalent to <code>@(1)</code> (see the <a href="#time-expression-1"><code>@</code> Time Expression</a>).</p>
<h3 id="time-expression_1"><code>@</code> Time Expression</h3>
<p><code>@</code> is used to express a delay with an arbitrary number of samples. For example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust26/exfaust26.svg" class="mx-auto d-block">
<faust-editor><!--

process = @(10);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>will delay the incoming signal by 10 samples. </p>
<p>A delay expressed with <code>@</code> doesn't have to be fixed but it must be bounded and cannot be negative. Therefore, the values of a slider are perfectly acceptable:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust27/exfaust27.svg" class="mx-auto d-block">
<faust-editor><!--

process = @(hslider("delay",0,0,100,1));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><code>@</code> only allows for the implementation of integer delay. Thus, various fractional delay algorithms are implemented in the Faust <a href="https://faustlibraries.grame.fr/libs/delays/">delays.lib</a> library.</p>
<h3 id="environment-expressions">Environment Expressions</h3>
<p>Faust is a lexically scoped language. The meaning of a Faust expression is determined by its context of definition (its lexical environment) and not by its context of use. </p>
<p>To keep their original meaning, Faust expressions are bounded to their lexical environment in structures called <em>closures</em>. The following constructions allow to explicitly create and access such environments. Moreover they provide powerful means to reuse existing code and promote modular design.</p>
<p><img src="img/envexp.svg" class="mx-auto d-block"></p>
<h4 id="with-expression"><code>with</code> Expression</h4>
<p>The <code>with</code> construction allows to specify a <em>local environment</em>: a private list of definition that will be used to evaluate the left hand expression.</p>
<p>In the following example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust28/exfaust28.svg" class="mx-auto d-block">
<faust-editor><!--

pink = f : + ~ g 
with {
  f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x'';
  g(x) = 1.80116083982126*x - 0.80257737639225*x';
};
process = pink;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>the definitions of <code>f(x)</code> and <code>g(x)</code> are local to <code>f : + ~ g</code>.</p>
<p>Please note that <code>with</code> is left associative and has the lowest priority:</p>
<ul>
<li><code>f : + ~ g with {...}</code> is equivalent to <code>(f : + ~ g) with {...}</code>. </li>
<li><code>f : + ~ g with {...} with {...}</code> is equivalent to 
<code>((f : + ~ g) with {...}) with {...}</code>. </li>
</ul>
<h4 id="letrec-expression"><code>letrec</code> Expression</h4>
<p>The <code>letrec</code> construction is somehow similar to <a href="#with-expression"><code>with</code></a>, but for difference equations instead of regular definitions. It allows us to easily express groups of mutually recursive signals, for example:</p>
<p>
<script type="math/tex; mode=display">
x(t) = y(t-1) + 10\\
y(t) = x(t-1) - 1
</script>
</p>
<p>as <code>E letrec { 'x = y+10; 'y = x-1; }</code>  </p>
<p>The syntax is defined by the following rules:</p>
<p><img src="img/letrec.svg" class="mx-auto d-block"></p>
<p>Note the special notation <code>'x = y + 10</code> instead of <code>x = y' + 10</code>. It makes 
syntactically impossible to write non-sensical equations like <code>x=x+1</code>.</p>
<p>Here is a more involved example. Let say we want to define an envelope generator with an attack and a release time (as a number of samples), and a gate signal. A possible definition could be:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust29/exfaust29.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
ar(a,r,g) = v
letrec {
  'n = (n+1) * (g<=g');
  'v = max(0, v + (n<a)/a - (n>=a)/r) * (g<=g');
};
gate = button("gate");
process = os.osc(440)*ar(1000,1000,gate);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>With the following semantics for <script type="math/tex">n(t)</script> and <script type="math/tex">v(t)</script>:</p>
<p>
<script type="math/tex; mode=display">
n(t) = (n(t-1)+1) * (g(t) <= g(t-1))\\
v(t) = max(0, v(t-1) + (n(t-1)<a(t))/a(t) - (n(t-1)>=a(t))/r(t)) * (g(t)<=g(t-1))
</script>
</p>
<p>In order to factor some expressions common to several recursive definitions, we can use the clause <code>where</code> followed by one or more definitions. These definitions will only be visible to the recursive equations of the <code>letrec</code>, but not to the outside world, unlike the recursive definitions themselves.</p>
<p>For instance in the previous example we can factorize <code>(g&lt;=g)</code> leading to the following expression:</p>
<pre><code>ar(a,r,g) = v letrec {
    'n = (n+1) * c;
    'v = max(0, v + (n&lt;a)/a - (n&gt;=a)/r) * c; 
    where
        c = g&lt;=g'; 
    };
</code></pre>
<p>Please note that <code>letrec</code> is essentially syntactic sugar. Here is an example of ’letrec’:</p>
<pre><code>x,y letrec {
    x = defx; 
    y = defy; 
    z = defz;
    where
        f = deff;
        g = defg; 
    };
</code></pre>
<p>and its translation as done internally by the compiler:</p>
<pre><code>x,y with {
    x = BODY : _,!,!;
    y = BODY : !,_,!;
    z = BODY : !,!,_;
    BODY = \(x,y,z).((defx,defy,defz) with {f=deff; g=defg;}) ~ (_,_,_);
};
</code></pre>
<h4 id="environment-expression"><code>environment</code> Expression</h4>
<p>The <code>environment</code> construction allows to create an explicit environment. It is like a <a href="#with-expression">`with'</a>, but without the left hand expression. It is a convenient way to group together related definitions, to isolate groups of definitions and to create a name space hierarchy. </p>
<p><img src="img/environment.svg" class="mx-auto d-block"></p>
<p>In the following example an <code>environment</code> construction is used to group together some constant definitions:</p>
<pre><code>constant = environment {
  pi = 3.14159;
  e = 2.718;
  ...
};
</code></pre>
<p>The  <a href="#access-expression"><code>.</code> construction</a> allows to access the definitions of an environment (see next section).</p>
<h4 id="access-expression">Access Expression</h4>
<p>Definitions inside an environment can be accessed using the <code>.</code> construction. </p>
<p><img src="img/access.svg" class="mx-auto d-block"></p>
<p>For example <code>constant.pi</code> refers to the definition of <code>pi</code> in the <code>constant</code> environment <a href="#environment-expression">defined above</a>.</p>
<p>Note that environments don't have to be named. We could have written directly: </p>
<pre><code>environment{pi = 3.14159; e = 2.718; ... }.pi
</code></pre>
<h4 id="library-expression"><code>library</code> Expression</h4>
<p>The <code>library</code> construct allows to create an environment by reading the definitions from a file.</p>
<p><img src="img/library.svg" class="mx-auto d-block"></p>
<p>For example <code>library("filters.lib")</code> represents the <a href="#environment-expression">environment</a> obtained by reading the file <code>filters.lib</code>. It works like <code>import("filters.lib")</code> but all the read definitions are stored in a new separate lexical environment. Individual definitions can be accessed as described in the previous paragraph. For example <code>library("filters.lib").lowpass</code> denotes the function <code>lowpass</code> as defined in the file <code>filters.lib</code>.</p>
<p>To avoid name conflicts when importing libraries it is recommended to prefer 
<code>library</code> to <a href="#import"><code>import</code></a>. So instead of:</p>
<pre><code>import(&quot;filters.lib&quot;);
  ...
  ...lowpass....
  ...
};
</code></pre>
<p>the following will ensure an absence of conflicts: </p>
<pre><code>fl = library(&quot;filters.lib&quot;);
  ...
...fl.lowpass....
    ...
};
</code></pre>
<p>In practice, that's how the <code>stdfaust.lib</code>library works.</p>
<!-- TODO: import? -->

<!-- TODO: we should also show how this type of construction can be used to
define function with variables with a predefined value, etc. -->

<h4 id="component-expression"><code>component</code> Expression</h4>
<p>The <code>component</code> construction allows us to reuse a full Faust program (e.g., a <code>.dsp</code> file) as a simple expression.</p>
<p><img src="img/component.svg" class="mx-auto d-block"></p>
<p>For example <code>component("freeverb.dsp")</code> denotes the signal processor defined in file <code>freeverb.dsp</code>. </p>
<p>Components can be used within expressions like in: </p>
<pre><code>...component(&quot;karplus32.dsp&quot;) : component(&quot;freeverb.dsp&quot;)... 
</code></pre>
<p>Please note that <code>component("freeverb.dsp")</code> is equivalent to <code>library("freeverb.dsp").process</code>.</p>
<p><code>component</code> works well in tandem with <a href="#explicit-substitution">explicit substitution</a> (see next section).</p>
<h4 id="explicit-substitution">Explicit Substitution</h4>
<p>Explicit substitution can be used to customize a component or any expression with a lexical environment by replacing some of its internal definitions, without having to modify it.</p>
<p><img src="img/explicitsubst.svg" class="mx-auto d-block"></p>
<p>For example we can create a customized version of <code>component("freeverb.dsp")</code>, with a different definition of <code>foo(x)</code>, by writing:</p>
<pre><code>...component(&quot;freeverb.dsp&quot;)[foo(x) = ...;]...
};
</code></pre>
<h3 id="foreign-expressions">Foreign Expressions</h3>
<p>Reference to external C <em>functions</em>, <em>variables</em> and <em>constants</em> can be introduced using the <em>foreign expressions</em> mechanism.</p>
<p><img src="img/foreignexp.svg" class="mx-auto d-block"></p>
<!-- TODO something needs to be said about the fact that this is a C++ thing -->

<h4 id="foreign-function-declaration">Foreign function declaration</h4>
<p>An external C function is declared by indicating its name and signature as well as the required include file. The file <code>maths.lib</code> of the Faust distribution contains several foreign function definitions, for example the inverse hyperbolic sine function <a href="https://faustlibraries.grame.fr/libs/maths/#maasinh"><code>asinh</code></a> is defined as follows:</p>
<pre><code>asinh = ffunction(float asinhf|asinh|asinhl|asinfx(float), &lt;math.h&gt;, &quot;&quot;);
</code></pre>
<!-- TODO: what happens for other languages than C? -->

<p>The signature part of a foreign function, <code>float asinhf|asinh|asinhl|asinfx(float)</code> in our previous example, describes the prototype of the C function: its return type, function names and list of parameter types. Because the name of the foreign function can possibly depend on the floating point precision in use (float, double, quad or fixed-point), it is possible to give a different function name for each floating point precision using a signature with up to four function names. </p>
<p>In our example, the <code>asinh</code> function is called <code>asinhf</code> in single precision, <code>asinh</code> in double precision, <code>asinhl</code> in quad precision and <code>asinfx</code> in fixed-point precision. This is why the four names are provided in the signature.</p>
<h4 id="signature">Signature</h4>
<p><img src="img/signature.svg" class="mx-auto d-block"></p>
<h4 id="types">Types</h4>
<p>Foreign functions generally expect a precise type: <code>int</code> or <code>float</code>  for their parameters.  Note that currently only numerical functions involving simple <code>int</code> and <code>float</code> parameters are allowed currently in Faust. No vectors, tables or data structures can be passed as parameters or returned.</p>
<p>Some foreign functions are polymorphic and can accept either int or float arguments. In this case, the polymorphism can be indicated by using the type <code>any</code> instead or <code>int</code> or <code>float</code>. Here is as an example the C function <code>sizeof</code> that returns the size of its argument:</p>
<pre><code>sizeof = ffunction(int sizeof(any), &quot;&quot;,&quot;&quot;);
</code></pre>
<p>Foreign functions with input parameters are considered pure math functions. They are therefore considered free of side effects and called only when their parameters change (that is at the rate of the fastest parameter). </p>
<p>Exceptions are functions with no input parameters. A typical example is the C <code>rand()</code> function. In this case the compiler generates code to call the function at sample rate.</p>
<h4 id="foreign-variables-and-constants">Foreign Variables and Constants</h4>
<p>External variables and constants can also be declared with a similar syntax. In the same <code>maths.lib</code> file, the definition of the sampling rate constant <a href="https://faustlibraries.grame.fr/libs/maths/#masr"><code>SR</code></a> and the definition of the block-size variable <a href="https://faustlibraries.grame.fr/libs/maths/#mabs"><code>BS</code></a> can be found:</p>
<pre><code>SR = min(192000.0,max(1.0,fconstant(int fSamplingFreq, &lt;math.h&gt;)));
BS = fvariable(int count, &lt;math.h&gt;);
</code></pre>
<p>Foreign constants are not supposed to vary. Therefore expressions involving only foreign constants are computed once, during the initialization period. </p>
<p>Foreign variables are considered to vary at block speed. This means that expressions depending of external variables are computed every block.</p>
<h4 id="include-file">Include File</h4>
<p>In declaring foreign functions one has also to specify the include file. It allows the Faust compiler to add the corresponding <code>#include</code> in the generated code.</p>
<p><img src="img/includefile.svg" class="mx-auto d-block"></p>
<h4 id="library-file">Library File</h4>
<p>In declaring foreign functions one can possibly specify the library where the actual code is located. It allows the Faust compiler to (possibly) automatically link the library. Note that this feature is only used with the <a href="https://faustdoc.grame.fr/manual/embedding/#using-libfaust-with-the-llvm-backend">LLVM backend in 'libfaust' dynamic library model</a>.</p>
<!-- TODO I feel like more could be said here -->

<h3 id="applications-and-abstractions">Applications and Abstractions</h3>
<p><em>Abstractions</em> and <em>applications</em> are fundamental programming constructions directly inspired by Lambda-Calculus. These constructions provide powerful ways to describe and transform block-diagrams algorithmically.</p>
<p><img src="img/abstraction.svg" class="mx-auto d-block"></p>
<h4 id="abstractions">Abstractions</h4>
<p>Abstractions correspond to functions definitions and allow to generalize a block-diagram by <em>making variable</em> some of its parts. </p>
<p>Let's say we want to transform a stereo reverb, <a href="https://faustlibraries.grame.fr/libs/demos/#dmzita_light"><code>dm.zita_light</code></a> for instance, into a mono effect. The following expression can be written (see the sections on <a href="#split-composition">Split Composition</a> and <a href="#merge-composition">Merge Composition</a>): </p>
<pre><code>_ &lt;: dm.zita_light :&gt; _ 
</code></pre>
<p>The incoming mono signal is split to feed the two input channels of the reverb, while the two output channels of the reverb are mixed together to produce the resulting mono output.</p>
<p>Imagine now that we are interested in transforming other stereo effects. We could generalize this principle by making <code>zita_light</code> a variable: </p>
<pre><code>\(zita_light).(_ &lt;: zita_light :&gt; _)
</code></pre>
<p>The resulting abstraction can then be applied to transform other effects. Note that if <code>zita_light</code> is a perfectly valid variable name, a more neutral name would probably be easier to read like:</p>
<pre><code>\(fx).(_ &lt;: fx :&gt; _)
</code></pre>
<p>A name can be given to the abstraction and in turn use it on <code>dm.zita_light</code>:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust30/exfaust30.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
mono = \(fx).(_ <: fx :> _);
process = mono(dm.zita_light);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Or even use a more traditional, but equivalent, notation:</p>
<pre><code>mono(fx) = _ &lt;: fx :&gt; _;
</code></pre>
<h4 id="applications">Applications</h4>
<p>Applications correspond to function calls and allow to replace the variable parts of an abstraction with the specified arguments.</p>
<p><img src="img/application.svg" class="mx-auto d-block"></p>
<p>For example, the abstraction described in <a href="#abstractions">the previous section</a> can be used to transform a stereo reverb:</p>
<pre><code>mono(dm.zita_light)
</code></pre>
<p>The compiler will start by replacing <code>mono</code> by its definition:</p>
<pre><code>\(fx).(_ &lt;: fx :&gt; _)(dm.zita_light)
</code></pre>
<blockquote>
<p>Replacing the <em>variable part</em> with the argument is called beta-reduction in Lambda-Calculus</p>
</blockquote>
<p>Whenever the Faust compiler find an application of an abstraction it replaces the <em>variable part</em> with the argument. The resulting expression is as expected:</p>
<pre><code>(_ &lt;: dm.zita_light :&gt; _)
</code></pre>
<h4 id="unapplied-abstractions">Unapplied abstractions</h4>
<p>Usually, lambda abstractions are supposed to be applied on arguments, using beta-reduction in Lambda-Calculus. Functional languages generally treat them as <a href="https://en.wikipedia.org/wiki/First-class_function">first-class values</a> which give these languages high-order programming capabilities. </p>
<p>Another way of looking at abstractions in Faust is as a means of routing or placing blocks that are given as parameters. For example, the following abstraction <code>repeat(fx) = fx : fx;</code> could be used to duplicate an effect and route input signals to be successively processed by that effect:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust31/exfaust31.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
repeat(fx) = fx : fx;
process = repeat(dm.zita_light); 

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>In Faust, a proper semantic has also been given to <em>unapplied abstractions</em>: when a lambda-abstraction is not applied to parameters, it indicates <em>how to route input signals</em>. This is a convenient way to work with signals by <em>explicitly naming them</em>, to be used in the lambda abstraction body <em>with their parameter name</em>.  </p>
<p>For instance a stereo crossing block written in the core syntax:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust32/exfaust32.svg" class="mx-auto d-block">
<faust-editor><!--

process = _,_ <: !,_,_,!; 

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>can be simply defined as:  </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust33/exfaust33.svg" class="mx-auto d-block">
<faust-editor><!--

process = \(x,y).(y,x); 

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>which is actually equivalent to: </p>
<pre><code>process(x,y) = y,x; 
</code></pre>
<h4 id="pattern-matching">Pattern Matching</h4>
<p>Pattern matching rules provide an effective way to analyze and transform block-diagrams algorithmically.</p>
<p><img src="img/patternabstraction.svg" class="mx-auto d-block"></p>
<p>For example <code>case{ (x:y) =&gt; y:x; (x) =&gt; x; }</code> contains two rules. The first one will match a sequential expression and invert the two part. The second one will match all remaining expressions and leave it untouched. Therefore the application:</p>
<pre><code>case{(x:y) =&gt; y:x; (x) =&gt; x;}(reverb : harmonizer)
</code></pre>
<p>will produce:</p>
<pre><code>harmonizer : freeverb
</code></pre>
<p>Please note that patterns are evaluated before the pattern matching operation. Therefore only variables that appear free in the pattern are binding variables during pattern matching. </p>
<!-- TODO: I think we need a better example here: that's a bit weak. We should wait to see if it appears somewhere else... Also, I think there are some stuff missing here. -->

<h2 id="primitives">Primitives</h2>
<p>The primitive signal processing operations represent the built-in functionalities of Faust, that is the atomic operations on signals provided by the language. All these primitives denote <em>signal processors</em>, in other words, functions transforming <em>input signals</em> into <em>output signals</em>.</p>
<!-- TODO: Diagram was removed here since everything is listed below: may be we should put a table summarizing everything. -->

<h3 id="numbers">Numbers</h3>
<p>Faust considers two types of numbers: <em>integers</em> and <em>floats</em>. Integers are implemented as signed 32-bits integers, and floats are implemented either with a simple, double, or extended precision depending of the compiler options. Floats are available in decimal or scientific notation. </p>
<p><img src="img/numbers.svg" class="mx-auto d-block"></p>
<p>Like any other Faust expression, numbers are signal processors. For example the number 0.95 is a signal processor of type <script type="math/tex">\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}</script> that transforms an empty tuple of signals <script type="math/tex">()</script> into a 1-tuple of signals <script type="math/tex">(y)</script> such that <script type="math/tex">\forall t\in\mathbb{N}, y(t)=0.95</script>.</p>
<p>Operations on <em>integer</em> numbers follow the standard C semantic for <code>+, -, *</code> operations and can possibly overflow if the result cannot be represented as a  32-bits integer. The <code>/</code> operation is treated separately and cast both of its arguments to floats before doing the division, and thus the result takes the float type.</p>
<h3 id="route-primitive"><code>route</code> Primitive</h3>
<p>The <code>route</code> primitive facilitates the routing of signals in Faust. It has the following syntax:</p>
<pre><code>route(A,B,a,b,c,d,...)
route(A,B,(a,b),(c,d),...)
</code></pre>
<p>where:</p>
<ul>
<li><code>A</code> is the number of input signals, as an integer <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li><code>B</code> is the number of output signals, as an integer <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li><code>a,b / (a,b)</code> is an input/output pair, as integers <a href="#constant-numerical-expressions">constant numerical expressions</a>, automatically promoted to <em>int</em></li>
</ul>
<p>Inputs are numbered from 1 to <code>A</code> and outputs are numbered from 1 to <code>B</code>. There can be any number of input/output pairs after the declaration of <code>A</code> and <code>B</code>.</p>
<p>For example, crossing two signals can be carried out with:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust34/exfaust34.svg" class="mx-auto d-block">
<faust-editor><!--

process = route(2,2,1,2,2,1);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>In that case, <code>route</code> has 2 inputs and 2 outputs. The first input (1) is connected to the second output (2) and the second input (2) is connected to the first output (1).</p>
<p>Note that parenthesis can be optionally used to define a pair, so the previous example can also be written as:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust35/exfaust35.svg" class="mx-auto d-block">
<faust-editor><!--

process = route(2,2,(1,2),(2,1));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>More complex expressions can be written using algorithmic constructions, like the following one to cross N signals:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust36/exfaust36.svg" class="mx-auto d-block">
<faust-editor><!--

// cross 10 signals: 
// input 0 -> output 10, 
// input 1 -> output 9, 
// ..., 
// input 9 -> output 0

N = 10;
r = route(N,N,par(i,N,(i+1,N-i)));

process = r;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h3 id="waveform-primitive"><code>waveform</code> Primitive</h3>
<p>The <code>waveform</code> primitive was designed to facilitate the use of <a href="#rdtable-primitive"><code>rdtable</code></a> (read table). It allows us to specify a fixed periodic signal as a list of samples as literal numbers. </p>
<p><code>waveform</code> has two outputs:</p>
<ul>
<li>a constant indicating the size (as a number of samples) of the period</li>
<li>the periodic signal itself</li>
</ul>
<p><img src="img/waveform.svg" class="mx-auto d-block"></p>
<p>For example <code>waveform{0,1,2,3}</code> produces two outputs: the constant signal 4 and the periodic signal <script type="math/tex">(0,1,2,3,0,1,2,3,0,1,\dots)</script>. </p>
<p>In the following example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust37/exfaust37.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5};
triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable;
f = hslider("freq",440,50,2000,0.01);
process = triangleOsc(f);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><code>waveform</code> is used to define a triangle waveform (in its most primitive form), which is then used with a <a href="#rdtable-primitive"><code>rdtable</code></a> controlled by a phaser to implement a triangle wave oscillator. Note that the quality of this oscillator is very low because of the low resolution of the triangle waveform.</p>
<h3 id="soundfile-primitive"><code>soundfile</code> Primitive</h3>
<p>The <code>soundfile("label[url:{'path1';'path2';'path3'}]", n)</code> primitive allows access to a list of externally defined sound resources, described as a label followed by the list of their filename, or complete paths (possibly using the <code>%i</code> syntax, as in the label part). The <code>soundfile("label[url:path]", n)</code> simplified syntax, or <code>soundfile("label", n)</code> (where label is used as the soundfile path) allows to use a single file. All sound resources are concatenated in a single data structure, and each item can be accessed and used independently.</p>
<p>A <code>soundfile</code> has: </p>
<ul>
<li>two inputs: the sound number (as a integer between 0 and 255, automatically promoted to <em>int</em>), and the read index in the sound (automatically promoted to <em>int</em>, which will access the last sample of the sound if the read index is greater than the sound length)</li>
<li>two fixed outputs: the first one is the length in samples of the currently accessed sound, the second one is the nominal sample rate in Hz of the currently accessed sound</li>
<li><code>n</code> several more outputs for the sound channels themselves, as a integer <a href="#constant-numerical-expressions">constant numerical expression</a></li>
</ul>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust38/exfaust38.svg" class="mx-auto d-block">
<faust-editor><!--

reader = _~+(1);
process = 0,reader:soundfile("son[url:{'foo.wav'}]",2);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>If more outputs than the actual number of channels in the sound file are used, the audio channels will be automatically duplicated up to the wanted number of outputs (so for instance, if a stereo file is used with four output channels, the same group of two channels will be duplicated).</p>
<p>If the soundfile cannot be loaded for whatever reason, a default sound with one channel, a length of 1024 frames and null outputs (with samples of value 0) will be used. Note also that soundfiles are entirely loaded in memory by the architecture file, so that the read index signal can access any sample.</p>
<p>A minimal example to play a stereo soundfile until it's end can be written with:</p>
<pre><code>process = 0,_~+(1):soundfile(&quot;son[url:{'foo.wav'}]&quot;,2):!,!,_,_;
</code></pre>
<p>The 0 first parameter selects the first sound in the soundfile list (which only contains one file in this example), then uses an incrementing read index signal to play the soundfile, cuts the unneeded <em>sound length in frames</em> and <em>sample rate</em> ouputs, and keeps the two actual sound outputs. Having the <em>sound length in frames</em> first output allows to implement sound looping, or any kind of more sophisticated read index signal. Having the <em>sound sample rate</em> second output allows to possibly adapt or change the reading speed. </p>
<p>Specialized architecture files are responsible to load the actual soundfile. The <code>SoundUI</code> C++ class located in the <code>faust/gui/SoundUI.h</code> file in the <a href="https://github.com/grame-cncm/faust">Faust repository</a> implements the <code>void addSoundfile(label, path, sf_zone)</code> method, which loads the actual soundfiles using the <code>libsndfile</code> library, or possibly specific audio file loading code (in the case of the JUCE framework for instance), and set up the <code>sf_zone</code> sound memory pointers. Note that the complete soundfile content is preloaded in memory at initialisation time when the compiled program starts.</p>
<p>Note that a special architecture file can well decide to access and use sound resources created by another means (that is, not directly loaded from a soundfile). For instance a mapping between labels and sound resources defined in memory could be used, with some additional code in charge of actually setting up all sound memory pointers when <code>void addSoundfile(label, path, sf_zone)</code> is called by the <code>buidUserInterface</code> mechanism.</p>
<!-- TODO: we need some working example here -->

<h3 id="c-equivalent-primitives">C-Equivalent Primitives</h3>
<p>Most Faust primitives are analogous to their C counterpart but adapted to signal processing. </p>
<p>For example <code>+</code> is a function of type <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script> that transforms a pair of signals <script type="math/tex">(x_1,x_2)</script> into a 1-tuple of signals <script type="math/tex">(y)</script> such that <script type="math/tex">\forall t\in\mathbb{N}, y(t)=x_{1}(t)+x_{2}(t)</script>. <code>+</code> can be used to very simply implement a mixer: </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust39/exfaust39.svg" class="mx-auto d-block">
<faust-editor><!--

process = +;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that this is equivalent to (see <a href="#identity-function">Identity Function</a>):</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust40/exfaust40.svg" class="mx-auto d-block">
<faust-editor><!--

process = _+_;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>The function <code>-</code> has type <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script> and transforms a pair of signals <script type="math/tex">(x_1,x_2)</script> into a 1-tuple of signals <script type="math/tex">(y)</script> such that <script type="math/tex">\forall t\in\mathbb{N}, y(t)=x_{1}(t)-x_{2}(t)</script>. </p>
<p><strong>Please be aware that</strong> the unary <code>-</code> only exists in a limited form. It can be used with numbers: <code>-0.5</code> and variables: <code>-myvar</code>, but not with expressions surrounded by parenthesis, because in this case it represents a partial application.  For instance,  <code>-(a*b)</code> is a partial application. It is syntactic sugar for <code>_,(a*b) : -</code>. If you want to negate a complex term in parenthesis, you'll have to use <code>0 - (a*b)</code> instead.</p>
<p>The primitives may use the <code>int</code> type for their arguments, but will automatically use the <code>float</code> type when the actual computation requires it. For instance <code>1/2</code> using <code>int</code> type arguments will correctly result in <code>0.5</code> in float type. Logical and shift primitives use the <code>int</code> type.</p>
<!-- TODO: need to make sure that the identify function and the exclamation
are properly documented/mentioned somewhere and demonstrated -->

<h4 id="integer-number">Integer Number</h4>
<p>Integer numbers are of type <script type="math/tex">\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}</script> in Faust and can be described mathematically as <script type="math/tex">y(t)=n</script>.</p>
<p><strong>Example: DC Offset of 1</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust41/exfaust41.svg" class="mx-auto d-block">
<faust-editor><!--

process = 1;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="floating-point-number">Floating Point Number</h4>
<p>Floating point numbers are of type <script type="math/tex">\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}</script> in Faust and can be described as <script type="math/tex">y(t)=n.m</script>.</p>
<p><strong>Example: DC Offset of 0.5</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust42/exfaust42.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.5;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="identity-function">Identity Function</h4>
<p>The identity function is expressed in Faust with the <code>_</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x(t)</script>
</li>
</ul>
<p><strong>Example: a Signal Passing Through</strong></p>
<p>In the following example, the <code>_</code> primitive is used to connect the single audio input of a Faust program to its output:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust43/exfaust43.svg" class="mx-auto d-block">
<faust-editor><!--

process = _;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="cut-primitive">Cut Primitive</h4>
<p>The cut primitive is expressed in Faust with <code>!</code>. It can be used to "stop"/terminate a signal.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{0}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">\forall x\in\mathbb{S},(x)\rightarrow ()</script>
</li>
</ul>
<p><strong>Example: Stopping a Signal</strong></p>
<p>In the following example, the <code>!</code> primitive is used to stop one of two parallel signals:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust44/exfaust44.svg" class="mx-auto d-block">
<faust-editor><!--

process = 1,2 : !,_;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="int-primitive"><code>int</code> Primitive</h4>
<p>The <code>int</code> primitive can be used to force the cast of a signal to int. It is of type <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script> and can be described mathematically as <script type="math/tex">y(t)=(int)x(t)</script>. This primitive is useful when declaringindices to read in a table, etc.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=(int)x(t)</script>
</li>
</ul>
<p><strong>Example: Simple Cast</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust45/exfaust45.svg" class="mx-auto d-block">
<faust-editor><!--

process = 1.5 : int;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="float-primitive"><code>float</code> Primitive</h4>
<p>The <code>float</code> primitive can be used to force the cast of a signal to float.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=(float)x(t)</script>
</li>
</ul>
<p><strong>Example: Simple Cast</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust46/exfaust46.svg" class="mx-auto d-block">
<faust-editor><!--

process = 1.5 : float;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="add-primitive">Add Primitive</h4>
<p>The <code>+</code> primitive can be used to add two signals together. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)+x_{2}(t)</script>
</li>
</ul>
<p><strong>Example: Simple Mixer</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust47/exfaust47.svg" class="mx-auto d-block">
<faust-editor><!--

process = +;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="subtract-primitive">Subtract Primitive</h4>
<p>The <code>-</code> primitive can be used to subtract two signals. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)-x_{2}(t)</script>
</li>
</ul>
<p><strong>Example: Subtracting Two Input Signals</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust48/exfaust48.svg" class="mx-auto d-block">
<faust-editor><!--

process = -;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="multiply-primitive">Multiply Primitive</h4>
<p>The <code>*</code> primitive can be used to multiply two signals. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)*x_{2}(t)</script>
</li>
</ul>
<p><strong>Example: Multiplying a Signal by 0.5</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust49/exfaust49.svg" class="mx-auto d-block">
<faust-editor><!--

process = *(0.5);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="divide-primitive">Divide Primitive</h4>
<p>The <code>/</code> primitive can be used to divide two signals. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)/{x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example: Dividing a Signal by 2</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust50/exfaust50.svg" class="mx-auto d-block">
<faust-editor><!--

process = /(2);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="power-primitive">Power Primitive</h4>
<p>The <code>^</code> primitive can be used to raise to the power of <code>N</code> a signal. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)^{x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example: Power of Two of a Signal</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust51/exfaust51.svg" class="mx-auto d-block">
<faust-editor><!--

process = ^(2);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="modulo-primitive">Modulo Primitive</h4>
<p>The <code>%</code> primitive can be used to take the modulo of a signal. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)\%{x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example: Phaser</strong></p>
<p>The following example uses a counter and the <code>%</code> primitive to implement a basic phaser:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust52/exfaust52.svg" class="mx-auto d-block">
<faust-editor><!--

process = _~+(1) : -(1) : %(10);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>will output a signal: <code>(0,1,2,3,4,5,6,7,8,9,0,1,2,3,4)</code>.</p>
<h4 id="and-primitive">AND Primitive</h4>
<p>Bitwise AND can be expressed in Faust with the <code>&amp;</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)\&{x_{2}(t)}</script>
</li>
</ul>
<!--
**Example**

TODO
-->

<h4 id="or-primitive">OR Primitive</h4>
<p>Bitwise OR can be expressed in Faust with the <code>|</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)|{x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<p>The following example will output 1 if the incoming signal is smaller than 0.5 or greater than 0.7 and 0 otherwise. Note that the result of this operation could be multiplied to another signal to create a condition.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust53/exfaust53.svg" class="mx-auto d-block">
<faust-editor><!--

process = _ <: <(0.5) | >(0.7);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="xor-primitive">XOR Primitive</h4>
<p>Bitwise XOR can be expressed in Faust with the <code>xor</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t)\land {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust54/exfaust54.svg" class="mx-auto d-block">
<faust-editor><!--

process = _ <: <(0.5) xor >(0.7);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="left-shift-primitive">Left Shift Primitive</h4>
<p>Left shift can be expressed in Faust with the <code>&lt;&lt;</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) << {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust55/exfaust55.svg" class="mx-auto d-block">
<faust-editor><!--

process = 1 << 2;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="right-shift-primitive">Right Shift Primitive</h4>
<p>Right shift can be expressed in Faust with the <code>&gt;&gt;</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) >> {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust56/exfaust56.svg" class="mx-auto d-block">
<faust-editor><!--

process = 1 >> 2;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="smaller-than-primitive">Smaller Than Primitive</h4>
<p>The smaller than comparison can be expressed in Faust with the <code>&lt;</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) < {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is smaller than 0.5 and 0 otherwise.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust57/exfaust57.svg" class="mx-auto d-block">
<faust-editor><!--

process = <(0.5);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="smaller-or-equal-than-primitive">Smaller or Equal Than Primitive</h4>
<p>The smaller or equal than comparison can be expressed in Faust with the <code>&lt;=</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) <= {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is smaller or equal than 0.5 and 0 otherwise.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust58/exfaust58.svg" class="mx-auto d-block">
<faust-editor><!--

process = <=(0.5);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="greater-than-primitive">Greater Than Primitive</h4>
<p>The greater than comparison can be expressed in Faust with the <code>&gt;</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) > {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is greater than 0.5 and 0 otherwise.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust59/exfaust59.svg" class="mx-auto d-block">
<faust-editor><!--

process = >(0.5);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="greater-or-equal-than-primitive">Greater or Equal Than Primitive</h4>
<p>The greater or equal than comparison can be expressed in Faust with the <code>&gt;=</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) >= {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is greater or equal than 0.5 and 0 otherwise.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust60/exfaust60.svg" class="mx-auto d-block">
<faust-editor><!--

process = >=(0.5);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="equal-to-primitive">Equal to Primitive</h4>
<p>The equal to comparison can be expressed in Faust with the <code>==</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) == {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust61/exfaust61.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0 == 1;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="different-than-primitive">Different Than Primitive</h4>
<p>The different than comparison can be expressed in Faust with the <code>!=</code> primitive. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=x_{1}(t) != {x_{2}(t)}</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust62/exfaust62.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0 != 1;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h3 id="mathh-equivalent-primitives"><code>math.h</code>-Equivalent Primitives</h3>
<p>Most of the C <code>math.h</code> functions are also built-in as primitives (the others are defined as external functions in file <a href="https://faustlibraries.grame.fr/libs/maths/"><code>maths.lib</code></a>). The primitives may use the <code>int</code> type for their arguments, but will automatically use the <code>float</code> type when the actual computation requires it. </p>
<h4 id="acos-primitive"><code>acos</code> Primitive</h4>
<p>Arc cosine can be expressed as <code>acos</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{acosf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust63/exfaust63.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : acos;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="asin-primitive"><code>asin</code> Primitive</h4>
<p>Arc sine can be expressed as <code>asin</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{asinf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust64/exfaust64.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : asin;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="atan-primitive"><code>atan</code> Primitive</h4>
<p>Arc tangent can be expressed as <code>atan</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{atanf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust65/exfaust65.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : atan;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="atan2-primitive"><code>atan2</code> Primitive</h4>
<p>The arc tangent of 2 signals can be expressed as <code>atan2</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{atan2f}(x_{1}(t), x_{2}(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust66/exfaust66.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1,-0.1 : atan2;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="cos-primitive"><code>cos</code> Primitive</h4>
<p>Cosine can be expressed as <code>cos</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{cosf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust67/exfaust67.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : cos;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="sin-primitive"><code>sin</code> Primitive</h4>
<p>Sine can be expressed as <code>sin</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{sinf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust68/exfaust68.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : sin;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="tan-primitive"><code>tan</code> Primitive</h4>
<p>Tangent can be expressed as <code>tan</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{tanf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust69/exfaust69.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : tan;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="exp-primitive"><code>exp</code> Primitive</h4>
<p>Base-e exponential can be expressed as <code>exp</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{expf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust70/exfaust70.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : exp;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="log-primitive"><code>log</code> Primitive</h4>
<p>Base-e logarithm can be expressed as <code>log</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{logf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust71/exfaust71.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : log;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="log10-primitive"><code>log10</code> Primitive</h4>
<p>Base-10 logarithm can be expressed as <code>log10</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{log10}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust72/exfaust72.svg" class="mx-auto d-block">
<faust-editor><!--

process = 0.1 : log10;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="pow-primitive"><code>pow</code> Primitive</h4>
<p>Power can be expressed as <code>pow</code> in Faust.  </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{powf}(x_{1}(t),x_{2}(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust73/exfaust73.svg" class="mx-auto d-block">
<faust-editor><!--

process = 2,4 : pow;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="sqrt-primitive"><code>sqrt</code> Primitive</h4>
<p>Square root can be expressed as <code>sqrt</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{sqrtf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust74/exfaust74.svg" class="mx-auto d-block">
<faust-editor><!--

process = 4 : sqrt;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="abs-primitive"><code>abs</code> Primitive</h4>
<p>Absolute value can be expressed as <code>abs</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{abs}(x(t))</script> (int) or<br />
<script type="math/tex">y(t)=\mathrm{fabsf}(x(t))</script> (float)</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust75/exfaust75.svg" class="mx-auto d-block">
<faust-editor><!--

process = -0.5 : abs;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="min-primitive"><code>min</code> Primitive</h4>
<p><em>Minimum</em> can be expressed as <code>min</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{min}(x_{1}(t),x_{2}(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust76/exfaust76.svg" class="mx-auto d-block">
<faust-editor><!--

process = -0.5,0.2 : min;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="max-primitive"><code>max</code> Primitive</h4>
<p><em>Maximum</em> can be expressed as <code>max</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{max}(x_{1}(t),x_{2}(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust77/exfaust77.svg" class="mx-auto d-block">
<faust-editor><!--

process = -0.5,0.2 : max;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="fmod-primitive"><code>fmod</code> Primitive</h4>
<p>Float modulo can be expressed as <code>fmod</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{fmodf}(x_{1}(t),x_{2}(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust78/exfaust78.svg" class="mx-auto d-block">
<faust-editor><!--

process = 5.3,2 : fmod;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="remainder-primitive"><code>remainder</code> Primitive</h4>
<p>Float remainder can be expressed as <code>remainder</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{remainderf}(x_{1}(t),x_{2}(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust79/exfaust79.svg" class="mx-auto d-block">
<faust-editor><!--

process = 5.3,2 : remainder;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="floor-primitive"><code>floor</code> Primitive</h4>
<p>Largest int can be expressed as <code>floor</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">\leq</script>: <script type="math/tex">y(t)=\mathrm{floorf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust80/exfaust80.svg" class="mx-auto d-block">
<faust-editor><!--

process = 3.6 : floor;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="ceil-primitive"><code>ceil</code> Primitive</h4>
<p>Smallest int can be expressed as <code>ceil</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">\geq</script>: <script type="math/tex">y(t)=\mathrm{ceilf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust81/exfaust81.svg" class="mx-auto d-block">
<faust-editor><!--

process = 3.6 : ceil;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="rint-primitive"><code>rint</code> Primitive</h4>
<p>Closest int (using the current rounding mode) can be expressed as <code>rint</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{rintf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust82/exfaust82.svg" class="mx-auto d-block">
<faust-editor><!--

process = 3.6 : rint;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="round-primitive"><code>round</code> Primitive</h4>
<p>Nearest int value (regardless of the current rounding mode) can be expressed as <code>round</code> in Faust. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=\mathrm{roundf}(x(t))</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust83/exfaust83.svg" class="mx-auto d-block">
<faust-editor><!--

process = 3.6 : round;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<!-- TODO: say something about the fact that things are expressed in core
syntax -->

<h3 id="delay-primitives-and-modifiers">Delay Primitives and Modifiers</h3>
<p>Faust hosts various modifiers and primitives to define one sample or integer delay of arbitrary length. They are presented in this section.  </p>
<h4 id="mem-primitive"><code>mem</code> Primitive</h4>
<p>A 1 sample delay can be expressed as <code>mem</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t+1)=x(t),y(0)=0</script>
</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust84/exfaust84.svg" class="mx-auto d-block">
<faust-editor><!--

process = mem;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that this is equivalent to <code>process = _'</code> (see <a href="#modifier"><code>'</code> Modifier</a>) and <code>process = @(1)</code> (see <a href="#time-expression_1"><code>@</code> Primitive</a>)</p>
<h4 id="modifier"><code>'</code> Modifier</h4>
<p><code>'</code> can be used to apply a 1 sample delay to a signal in Faust. It can be seen as syntactic sugar to the <a href="#mem-primitive"><code>mem</code> primitive</a>. <code>'</code> is very convenient when implementing filters and can help significantly decrease the size of the Faust code.</p>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust85/exfaust85.svg" class="mx-auto d-block">
<faust-editor><!--

process = _';

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="primitive"><code>@</code> Primitive</h4>
<p>An integer delay of <code>N</code> samples can be expressed as <code>@(N)</code> in Faust. Note that <code>N</code> (automatically promoted to <em>int</em>) can be dynamic but that its range must be bounded. This can be done by using a UI primitive (see example below) allowing for the definition of a range such as <a href="#hslider-primitive"><code>hslider</code></a>, <a href="#vslider-primitive"><code>vslider</code></a>, or <a href="#nentry-primitive"><code>nentry</code></a>.</p>
<p>Note that floating point delay is also available in Faust by the mean of <a href="https://faustlibraries.grame.fr/libs/delays/">various fractional delay implementations</a> available in the Faust standard libraries.</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t+x_{2}(t))=x_{1}(t), y(t<x_{2}(t))=0</script>
</li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_ : @(N) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the length of the delay as a number of samples</li>
</ul>
<p><strong>Example: Static N Samples Delay</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust86/exfaust86.svg" class="mx-auto d-block">
<faust-editor><!--

N = 10;
process = @(N);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><strong>Example: Dynamic N Samples Delay</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust87/exfaust87.svg" class="mx-auto d-block">
<faust-editor><!--

N = hslider("N",10,1,10,1);
process = @(N);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h3 id="table-primitives">Table Primitives</h3>
<!-- TODO: intro here -->

<h4 id="rdtable-primitive"><code>rdtable</code> Primitive</h4>
<p>The <code>rdtable</code> primitive can be used to read through a read-only (pre-defined at initialisation time) table. The table can either be implemented by using the <code>waveform</code> primitive (as shown in the first example) or using a function controlled by a timer (such as <a href="https://faustlibraries.grame.fr/libs/basics/#batime"><code>ba.time</code></a>) as demonstrated in the second example. The idea is that the table is created during the initialization step and before audio computation begins. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{3}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">y(t)=T[r(t)]</script>
</li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>rdtable(n,s,r) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the table size, an integer as a  <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li><code>s</code>: the table content</li>
<li><code>r</code>: the read index (an <code>int</code> between 0 and <code>n-1</code>), automatically promoted to <em>int</em></li>
</ul>
<p><strong>Example: Basic Triangle Wave Oscillator Using the <code>waveform</code> Primitive</strong></p>
<p>In this example, a basic (and dirty) triangle wave-table is defined using the <a href="#waveform-primitive"><code>waveform</code></a>. It is then used with the <code>rdtable</code> primitive and a phasor to implement a triangle wave oscillator:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust88/exfaust88.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5};
triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable;
f = hslider("freq",440,50,2000,0.01);
process = triangleOsc(f);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><strong>Example: Basic Triangle Wave Oscillator Using the <code>sin</code> Primitive and a Timer</strong></p>
<p>In this example, a sine table is implemented using the <a href="#sin-primitive"><code>sin</code></a> primitive and a timer (<a href="https://faustlibraries.grame.fr/libs/basics/#batime"><code>ba.time</code></a>). The timer calls the <code>sin</code> function during the initialization step of the Faust program. It is then used with <code>rdtable</code> to implement a sine wave oscillator. </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust89/exfaust89.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
tableSize = 1 << 16;
sineWave(tablesize) = float(ba.time)*(2.0*ma.PI)/float(tablesize) : sin;
triangleOsc(f) = tableSize,sineWave(tableSize),int(os.phasor(tableSize,f)) : rdtable;
f = hslider("freq",440,50,2000,0.01);
process = triangleOsc(f);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="rwtable-primitive"><code>rwtable</code> Primitive</h4>
<p>The <code>rwtable</code> primitive can be used to implement a read/write table. It takes an audio input that can be written in the table using a <em>write index</em> (i.e., <code>w</code> below) and read using a <em>read index</em> (i.e., <code>r</code> below).</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">\mathbb{S}^{5}\rightarrow\mathbb{S}^{1}</script>
</li>
<li><strong>Mathematical Description:</strong> <script type="math/tex">T[w(t)]=c(t); y(t)=T[r(t)]</script>
</li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_ : rwtable(n,s,w,_,r) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the table size, an integer as a <a href="#constant-numerical-expressions">constant numerical expression</a>, automatically promoted to <em>int</em></li>
<li><code>s</code>: the initial table content</li>
<li><code>w</code>: the write index (an <code>int</code> between 0 and <code>n-1</code>), automatically promoted to <em>int</em></li>
<li><code>r</code>: the read index (an <code>int</code> between 0 and <code>n-1</code>), automatically promoted to <em>int</em></li>
</ul>
<p>Note that the fourth argument of <code>rwtable</code> corresponds to the input of the table.</p>
<p><strong>Example: Simple Looper</strong></p>
<p>In this example, an input signal is written in the table when <code>record</code> is true (equal to 1). The read index is constantly updated to loop through the table. The table size is set to 48000, which corresponds to one second if the sampling rate is 48000 KHz. </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust90/exfaust90.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
tableSize = 48000;
recIndex = (+(1) : %(tableSize)) ~ *(record);
readIndex = readSpeed/float(ma.SR) : (+ : ma.frac) ~ _ : *(float(tableSize)) : int;
readSpeed = hslider("[0]Read Speed",1,0.001,10,0.01);
record = button("[1]Record") : int;
looper = rwtable(tableSize,0.0,recIndex,_,readIndex);
process = looper;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<!-- TODO: we might want to have a better example here -->

<h3 id="selector-primitives">Selector Primitives</h3>
<p>Selector primitives can be used to create conditions in Faust and to implement switches to choose between several signals. </p>
<h4 id="select2-primitive"><code>select2</code> Primitive</h4>
<p>The <code>select2</code> primitive is a "two-way selector". It has three input signals: <script type="math/tex">s</script>, <script type="math/tex">x_0</script>, <script type="math/tex">x_1</script> and one output signal <script type="math/tex">y</script>. At each instant the value of the selector signal <script type="math/tex">s(t)</script> is used to dynamically route samples from the other two inputs <script type="math/tex">x_0(t)</script> and <script type="math/tex">x_1(t)</script> to the output <script type="math/tex">y(t)</script>.  </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that <code>select2</code> is <strong>not</strong> the equivalent of a traditional <em>if-then-else</em> construction. Like every Faust primitive, it has a <em>strict</em> semantics. All input signals are always computed, even when they are not selected. Therefore you <em>can't</em> use <code>select2</code> to <em>avoid</em> computing something. </p>
</div>
<p>The semantics of <code>select2</code> is as follows:</p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">(s,x_0,x_1)\rightarrow y</script>
</li>
<li><strong>Mathematical Description:</strong> 
  <script type="math/tex; mode=display"> y(t) = \left\{ \begin{array}{ll}
         x_0(t) & \mathrm{if\ } s(t) = 0;\\
         x_1(t) & \mathrm{if\ } s(t) = 1.\end{array} \right. </script>
</li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_,_ : select2(s) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>s</code>: the selector (<code>0</code> for the first signal, <code>1</code> for the second one), automatically promoted to <em>int</em></li>
</ul>
<p><strong>Example: Signal Selector</strong></p>
<p>The following example allows the user to choose between a sine and a sawtooth wave oscillator.  </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust91/exfaust91.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
s = nentry("Selector",0,0,1,1) : int;
sig = os.osc(440),os.sawtooth(440) : select2(s);
process = sig;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that <code>select2</code> could be easily implemented from scratch in Faust:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust92/exfaust92.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
s = nentry("Selector",0,0,1,1);
mySelect2(s) = *(s==0),*(s==1) :> _;
sig = os.osc(440),os.sawtooth(440) : mySelect2(s);
process = sig;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>While the behavior of this last solution is identical to the first one, the generated code will be a bit different and potentially less efficient.</p>
<h4 id="select3-primitive"><code>select3</code> Primitive</h4>
<p>The <code>select3</code> primitive is a "three-ways selector". It has four input signals: <script type="math/tex">s</script>, <script type="math/tex">x_0</script>, <script type="math/tex">x_1</script>, <script type="math/tex">x_2</script> and one output signal <script type="math/tex">y</script>. At each instant the value of the selector signal <script type="math/tex">s(t)</script> is used to dynamically route samples from the other three inputs <script type="math/tex">x_0(t)</script>, <script type="math/tex">x_1(t)</script> and <script type="math/tex">x_2(t)</script> to the output <script type="math/tex">y(t)</script>. </p>
<ul>
<li><strong>Type:</strong> <script type="math/tex">(s,x_0,x_1,x_2)\rightarrow y</script>
</li>
<li><strong>Mathematical Description:</strong> 
  <script type="math/tex; mode=display"> y(t) = \left\{ \begin{array}{ll}
         x_0(t) & \mathrm{if\ } s(t) = 0;\\
         x_1(t) & \mathrm{if\ } s(t) = 1.\\
         x_2(t) & \mathrm{if\ } s(t) = 2.\end{array} \right. </script>
</li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_,_,_ : select3(s) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>s</code>: the selector (<code>0</code> for the first signal, <code>1</code> for the second one, <code>2</code> for the third one), automatically promoted to <em>int</em></li>
</ul>
<p><strong>Example: Signal Selector</strong></p>
<p>The following example allows the user to choose between a sine, a sawtooth and a triangle wave oscillator.  </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust93/exfaust93.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
s = nentry("Selector",0,0,1,1);
sig = os.osc(440),os.sawtooth(440),os.triangle(440) : select3(s);
process = sig;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that <code>select3</code> could be easily implemented from scratch in Faust using Boolean primitives:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust94/exfaust94.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
s = nentry("Selector",0,0,2,1) : int;
mySelect3(s) = *(s==0),*(s==1),*(s==2) :> _;
sig = os.osc(440),os.sawtooth(440),os.triangle(440) : mySelect3(s);
process = sig;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>While the behavior of this last solution is identical to the first one, the generated code will be a bit different and potentially less efficient.</p>
<h3 id="user-interface-primitives-and-configuration">User Interface Primitives and Configuration</h3>
<p>Faust user interface widgets/primitives allow for an <strong>abstract</strong> description of a user interface from within the Faust code. This description is independent from any GUI toolkits/frameworks and is purely abstract. Widgets can be <strong>discrete</strong> (e.g., <a href="#button-primitive"><code>button</code></a>, <a href="#checkbox-primitive"><code>checkbox</code></a>, etc.), <strong>continuous</strong> (e.g., <a href="#hslider-primitive"><code>hslider</code></a>, <a href="#vslider-primitive"><code>vslider</code></a>, <a href="#nentry-primitive"><code>nentry</code></a>), and <strong>organizational</strong> (e.g., <a href="#vgroup-primitive"><code>vgroup</code></a>, <a href="#hgroup-primitive"><code>hgroup</code></a>).</p>
<p>Discrete and continuous elements are signal generators. For example, a <code>button</code> produces a signal which is 1 when the button is pressed and 0 otherwise: </p>
<p><img src="img/button.svg" class="mx-auto d-block" width="50%"></p>
<p>These signals can be freely combined with other audio signals. In fact, the following code is perfectly valid and will generate sound:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust95/exfaust95.svg" class="mx-auto d-block">
<faust-editor><!--

process = button("DC");

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Each primitive implements a specific UI element, but their appearance can also be completely modified using <a href="#metadata">metadata</a> (a little bit like HTML and CSS in the web). Therefore, <a href="#hslider-primitive"><code>hslider</code></a>, <a href="#vslider-primitive"><code>vslider</code></a>, and <a href="#nentry-primitive"><code>nentry</code></a>) can for example be turned into a knob, a dropdown menu, etc. This concept is further developed in the <a href="#metadata">section on UI metadata</a>.</p>
<p>Continuous UI elements (i.e., <a href="#hslider-primitive"><code>hslider</code></a>, <a href="#vslider-primitive"><code>vslider</code></a>, and <a href="#nentry-primitive"><code>nentry</code></a>) must all declare a range for the parameter they're controlling. In some cases, this range is used during compilation to allocate memory and will impact the generated code. For example, in the case of:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust96/exfaust96.svg" class="mx-auto d-block">
<faust-editor><!--

process = @(hslider("N",1,1,10,1));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>a buffer of 10 samples will be allocated for the delay implemented with the <a href="#primitive"><code>@</code> primitive</a> while 20 samples will be allocated in the following example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust97/exfaust97.svg" class="mx-auto d-block">
<faust-editor><!--

process = @(hslider("N",1,1,20,1));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="button-primitive"><code>button</code> Primitive</h4>
<p>The <code>button</code> primitive implements a button.</p>
<p><strong>Usage</strong></p>
<pre><code>button(&quot;label&quot;) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
</ul>
<p><strong>Example: Trigger</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust98/exfaust98.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = no.noise*button("gate");

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="checkbox-primitive"><code>checkbox</code> Primitive</h4>
<p>The <code>checkbox</code> primitive implements a checkbox/toggle.</p>
<p><strong>Usage</strong></p>
<pre><code>checkbox(&quot;label&quot;) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
</ul>
<p><strong>Example: Trigger</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust99/exfaust99.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = no.noise*checkbox("gate");

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="hslider-primitive"><code>hslider</code> Primitive</h4>
<p>The <code>hslider</code> primitive implements a horizontal slider.</p>
<p><strong>Usage</strong></p>
<pre><code>hslider(&quot;label&quot;,init,min,max,step) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the slider, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>min</code>: the minimum value of the slider, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>max</code>: the maximum value of the slider, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>step</code>: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.), a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
</ul>
<p><strong>Example: Gain Control</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust100/exfaust100.svg" class="mx-auto d-block">
<faust-editor><!--

gain = hslider("gain",0,0,1,0.01);
process = *(gain);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p><strong>Example: Additive Oscillator</strong></p>
<p>Here is an example of a 3 oscillators instrument where the default frequency of each partial is <em>computed using a more complex <a href="#constant-numerical-expressions">constant numerical expression</a></em>.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust101/exfaust101.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = par(i,3,os.osc(hslider("Freq%i", 200+i*400, 200, 2000, 1)));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="vslider-primitive"><code>vslider</code> Primitive</h4>
<p>The <code>vslider</code> primitive implements a vertical slider.</p>
<p><strong>Usage</strong></p>
<pre><code>vslider(&quot;label&quot;,init,min,max,step) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the slider, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>min</code>: the minimum value of the slider, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>max</code>: the maximum value of the slider, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>step</code>: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.), a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust102/exfaust102.svg" class="mx-auto d-block">
<faust-editor><!--

gain = vslider("gain",0,0,1,0.01);
process = *(gain);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="nentry-primitive"><code>nentry</code> Primitive</h4>
<p>The <code>nentry</code> primitive implements a "numerical entry".</p>
<p><strong>Usage</strong></p>
<pre><code>nentry(&quot;label&quot;,init,min,max,step) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the numerical entry, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>min</code>: the minimum value of the numerical entry, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>max</code>: the maximum value of the numerical entry, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>step</code>: the precision (step) of the numerical entry (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.), a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust103/exfaust103.svg" class="mx-auto d-block">
<faust-editor><!--

gain = nentry("gain",0,0,1,0.01);
process = *(gain);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="hgroup-primitive"><code>hgroup</code> Primitive</h4>
<p>The <code>hgroup</code> primitive implements a horizontal group. A group contains other UI elements that can also be groups. <code>hgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>hgroup(&quot;label&quot;,x)
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust104/exfaust104.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = vslider("freq",440,50,1000,0.1);
gain = vslider("gain",0,0,1,0.01);
process = hgroup("Oscillator",os.sawtooth(freq)*gain);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that the <code>Oscillator</code> group can be placed in a function in case we'd like to add elements to it multiple times. </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust105/exfaust105.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
oscGroup(x) = hgroup("Oscillator",x);
freq = oscGroup(vslider("freq",440,50,1000,0.1));
gain = oscGroup(vslider("gain",0,0,1,0.01));
process = os.sawtooth(freq)*gain;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="vgroup-primitive"><code>vgroup</code> Primitive</h4>
<p>The <code>vgroup</code> primitive implements a vertical group. A group contains other UI elements that can also be groups. <code>vgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>vgroup(&quot;label&quot;,x)
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust106/exfaust106.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,1000,0.1);
gain = hslider("gain",0,0,1,0.01);
process = vgroup("Oscillator",os.sawtooth(freq)*gain);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that the <code>Oscillator</code> group can be placed in a function in case we'd like to add elements to it multiple times. </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust107/exfaust107.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
oscGroup(x) = vgroup("Oscillator",x);
freq = oscGroup(hslider("freq",440,50,1000,0.1));
gain = oscGroup(hslider("gain",0,0,1,0.01));
process = os.sawtooth(freq)*gain;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="tgroup-primitive"><code>tgroup</code> Primitive</h4>
<p>The <code>tgroup</code> primitive implements a "tab group." Tab groups can be used to group UI elements in tabs in the interface. A group contains other UI elements that can also be groups. <code>tgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>tgroup(&quot;label&quot;,x)
</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#variable-parts-of-a-label">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust108/exfaust108.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,1000,0.1);
gain = hslider("gain",0,0,1,0.01);
process = tgroup("Oscillator",os.sawtooth(freq)*gain);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that the <code>Oscillator</code> group can be placed in a function in case we'd like to add elements to it multiple times. </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust109/exfaust109.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
oscGroup(x) = tgroup("Oscillator",x);
freq = oscGroup(hslider("freq",440,50,1000,0.1));
gain = oscGroup(hslider("gain",0,0,1,0.01));
process = os.sawtooth(freq)*gain;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="vbargraph-primitive"><code>vbargraph</code> Primitive</h4>
<p>The <code>vbargraph</code> primitive implements a vertical bar-graph (typically a meter displaying the level of a signal).</p>
<p><strong>Usage</strong></p>
<p><code>vbargraph</code> takes an input signal and outputs it while making it available to the UI.</p>
<pre><code>_ : vbargraph(&quot;label&quot;,min,max) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>min</code>: the minimum value of the signal in the interface, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>max</code>: the maximum value of the signal in the interface, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
</ul>
<p><strong>Example: Simple VU Meter</strong> </p>
<p>A simple VU meter can be implemented using the <code>vbargraph</code> primitive:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust110/exfaust110.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = _ <: attach(_,abs : ba.linear2db : vbargraph("Level",-60,0));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note the use of the <a href="#attach-primitive"><code>attach</code></a> primitive here that forces the compilation of the <code>vbargraph</code> without using its output signal (see section on the <a href="#attach-primitive"><code>attach</code> primitive</a>).</p>
<h4 id="hbargraph-primitive"><code>hbargraph</code> Primitive</h4>
<p>The <code>hbargraph</code> primitive implements a horizontal bar-graph (typically a meter displaying the level of a signal).</p>
<p><strong>Usage</strong></p>
<p><code>hbargraph</code> takes an input signal and outputs it while making it available to the UI.</p>
<pre><code>_ : hbargraph(&quot;label&quot;,min,max) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>min</code>: the minimum value of the signal in the interface, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
<li><code>max</code>: the maximum value of the signal in the interface, a <a href="#constant-numerical-expressions">constant numerical expression</a></li>
</ul>
<p><strong>Example: Simple VU Meter</strong> </p>
<p>A simple VU meter can be implemented using the <code>hbargraph</code> primitive:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust111/exfaust111.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = _ <: attach(_,abs : ba.linear2db : hbargraph("Level",-60,0));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note the use of the <a href="#attach-primitive"><code>attach</code></a> primitive here that forces the compilation of the <code>hbargraph</code> without using its output signal (see section on the <a href="#attach-primitive"><code>attach</code> primitive</a>).</p>
<h4 id="attach-primitive"><code>attach</code> Primitive</h4>
<p>The <code>attach</code> primitive takes two input signals and produces one output signal which is a copy of the first input. The role of <code>attach</code> is to force its second input signal to be compiled with the first one. From a mathematical standpoint <code>attach(x,y)</code> is equivalent to <code>1*x+0*y</code>, which is in turn equivalent to <code>x</code>, but it tells the compiler not to optimize-out <code>y</code>.</p>
<p>To illustrate this role, let's say that we want to develop a mixer application with a vumeter for each input signals. Such vumeters can be easily coded in Faust using an envelope detector connected to a bargraph. The problem is that the signal of the envelope generators has no role in the output signals. Using <code>attach(x,vumeter(x))</code> one can tell the compiler that when <code>x</code> is compiled <code>vumeter(x)</code> should also be compiled. </p>
<p>The examples in the <a href="#hbargraph-primitive"><code>hbargraph</code> Primitive</a> and the <a href="#vbargraph-primitive"><code>vbargraph</code> Primitive</a> illustrate well the use of <code>attach</code>.</p>
<h4 id="variable-parts-of-a-label">Variable Parts of a Label</h4>
<p>Labels can contain variable parts. These are indicated with the sign <code>%</code> followed by the name of a variable. During compilation each label is processed in order to replace the variable parts by the value of the variable. For example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust112/exfaust112.svg" class="mx-auto d-block">
<faust-editor><!--

process = par(i,8,hslider("Voice %i",0.9,0,1,0.01));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>creates 8 sliders in parallel with different names while <code>par(i,8,hslider("Voice",0.9,0,1,0.01))</code> would have created only one slider and duplicated its output 8 times.</p>
<p>The variable part can have an optional format digit. For example <code>"Voice %2i"</code> would indicate to use two digits when inserting the value of <code>i</code> in the string.</p>
<p>An escape mechanism is provided. If the sign <code>%</code> is followed by itself, it will be included in the resulting string. For example <code>"feedback (%%)"</code> will result in <code>"feedback (%)"</code>.</p>
<p>The variable name can be enclosed in curly brackets to clearly separate it from the rest of the string, as in <code>par(i,8,hslider("Voice %{i}", 0.9, 0, 1, 0.01))</code>.</p>
<h4 id="labels-as-pathnames">Labels as Pathnames</h4>
<p>Thanks to <a href="#hgroup-primitive">horizontal</a>, <a href="#vgroup-primitive">vertical</a>, and <a href="#tgroup-primitive">tabs</a> groups, user interfaces have a hierarchical structure analog to a hierarchical file system. Each widget has an associated <em>path name</em> obtained by concatenating the labels of all its surrounding groups with its own label.</p>
<p>In the following example:</p>
<pre><code>hgroup(&quot;Foo&quot;,
    ...
    vgroup(&quot;Faa&quot;, 
        ...
        hslider(&quot;volume&quot;,...)
        ...
    )
    ...
)
</code></pre>
<p>the volume slider has pathname <code>/h:Foo/v:Faa/volume</code>.</p>
<p>In order to give more flexibility to the design of user interfaces, it is possible to explicitly specify the absolute or relative pathname of a widget directly in its label. </p>
<p>In our previous example the pathname of <code>hslider("../volume",...)</code> would have been <code>/h:Foo/volume</code>, while the pathname of <code>hslider("t:Fii/volume",...)</code> would have been <code>/h:Foo/v:Faa/t:Fii/volume</code>. </p>
<p>Elements of a path are separated using <code>/</code>. Group types are defined with the following identifiers:</p>
<table>
<thead>
<tr>
<th>Group Type</th>
<th>Group Identifier</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hgroup</code></td>
<td><code>h:</code></td>
</tr>
<tr>
<td><code>vgroup</code></td>
<td><code>v:</code></td>
</tr>
<tr>
<td><code>tgroup</code></td>
<td><code>t:</code></td>
</tr>
</tbody>
</table>
<p>Hence, the example presented in the <a href="#hgroup-primitive">section on the <code>hgroup</code> primitive</a> can be rewritten as:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust113/exfaust113.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = vslider("h:Oscillator/freq",440,50,1000,0.1);
gain = vslider("h:Oscillator/gain",0,0,1,0.01);
process = os.sawtooth(freq)*gain;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>which will be reflected in C++ as:</p>
<pre><code>virtual void buildUserInterface(UI* ui_interface) {
  ui_interface-&gt;openHorizontalBox(&quot;Oscillator&quot;);
  ui_interface-&gt;addVerticalSlider(&quot;freq&quot;, &amp;fVslider1, 440.0f, 50.0f, 1000.0f, 0.100000001f);
  ui_interface-&gt;addVerticalSlider(&quot;gain&quot;, &amp;fVslider0, 0.0f, 0.0f, 1.0f, 0.00999999978f);
  ui_interface-&gt;closeBox();
}
</code></pre>
<p>Note that path names are inherent to the use of tools gravitating around Faust such as <a href="../osc">OSC control</a> or <code>faust2api</code>. In the case of <code>faust2api</code>, since no user interface is actually generated, UI elements just become a way to declare parameters of a Faust object. Therefore, there's no distinction between <code>nentry</code>, <code>hslider</code>, <code>vslider</code>, etc.</p>
<h4 id="smoothing">Smoothing</h4>
<p>Despite the fact that the signal generated by user interface elements can be used in Faust with any other signals, UI elements run at a slower rate than the audio rate. This might be a source of clicking if the value of the corresponding parameter is modified while the program is running. This behavior is also amplified by the low resolution of signals generated by UI elements (as opposed to actual audio signals). For example, changing the value of the <code>freq</code> or <code>gain</code> parameters of the following code will likely create clicks (in the case of <code>gain</code>) or abrupt jumps (in the case of <code>freq</code>) in the signal:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust114/exfaust114.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,1000,0.1);
gain = hslider("gain",0,0,1,0.01);
process = os.osc(freq)*gain;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>This problem can be easily solved in Faust by using the <a href="https://faustlibraries.grame.fr/libs/signals/#sismoo"><code>si.smoo</code></a> function which implements an exponential smoothing by a unit-dc-gain one-pole lowpass with a pole at 0.999 (<code>si.smoo</code> is just sugar for <code>si.smooth(0.999)</code>). Therefore, the previous example can be rewritten as:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust115/exfaust115.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = hslider("freq",440,50,1000,0.1) : si.smoo;
gain = hslider("gain",0,0,1,0.01) : si.smoo;
process = os.osc(freq)*gain;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Beware that each <code>si.smoo</code> that you place in your code will add some extra computation so they should be used precociously.  </p>
<h4 id="links-to-generated-code">Links to Generated Code</h4>
<p>UI elements provide a convenient entry point to the DSP process in the code generated by the Faust compiler (e.g., C++, etc.). For example, the Faust program:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1);
process = os.osc(freq);
</code></pre>
<p>will have the corresponding <code>buildUserInterface</code> method in C++:</p>
<pre><code>virtual void buildUserInterface(UI* ui_interface) {
  ui_interface-&gt;openVerticalBox(&quot;osc&quot;);
  ui_interface-&gt;addHorizontalSlider(&quot;freq&quot;, &amp;fHslider0, 440.0f, 50.0f, 1000.0f, 0.100001f);
  ui_interface-&gt;closeBox();
}
</code></pre>
<p>The second argument of the <code>addHorizontalSlider</code> method is a pointer to the variable containing the current value of the <code>freq</code> parameter. The value of this pointer can be updated at any point to change the frequency of the corresponding oscillator.</p>
<h3 id="ui-label-metadata">UI Label Metadata</h3>
<p><a href="#user-interface-primitives-and-configuration">Widget labels</a> can contain metadata enclosed in square brackets. These metadata associate a key with a value and are used to provide additional information to the architecture file. They are typically used to improve the look and feel of the user interface, configure OSC and accelerometer control/mapping, etc. Since the format of the value associated to a key is relatively open, metadata constitute a flexible way for programmers to add features to the language.</p>
<p>The Faust code:</p>
<pre><code>process = *(hslider(&quot;foo[key1: val 1][key2: val 2]&quot;,0,0,1,0.1));
</code></pre>
<p>will produce the corresponding C++ code:</p>
<pre><code>class mydsp : public dsp {
  ...
  virtual void buildUserInterface(UI* ui_interface) {
    ui_interface-&gt;openVerticalBox(&quot;tst&quot;);
    ui_interface-&gt;declare(&amp;fHslider0, &quot;key1&quot;, &quot;val 1&quot;);
    ui_interface-&gt;declare(&amp;fHslider0, &quot;key2&quot;, &quot;val 2&quot;);
    ui_interface-&gt;addHorizontalSlider(&quot;foo&quot;, &amp;fHslider0, 0.0f, 0.0f, 1.0f, 0.100000001f);
    ui_interface-&gt;closeBox();
  }
  ...
};
</code></pre>
<p>All metadata are removed from the label by the compiler and transformed in calls to the <code>UI::declare()</code> method. All these <code>UI::declare()</code> calls will always take place before the <code>UI::AddSomething()</code> call that creates the User Interface element. This allows the <code>UI::AddSomething()</code> method to make full use of the available metadata.</p>
<p>Metadata are architecture-specific: it is up to the architecture file to decide what to do with it. While some metadata will work with most architectures (e.g., accelerometer and OSC configuration, etc.), others might be more specific. Some of them are presented in the following sections.</p>
<h4 id="ordering-ui-elements">Ordering UI Elements</h4>
<p>The order of UI declarations in a Faust code doesn't necessarily reflect the actual order of the UI elements in the corresponding interface. Therefore, UI elements can be ordered by placing a metadata before the declaration of the name of the UI element in the label. For example, in the following declaration:</p>
<pre><code>gain = vslider(&quot;h:Oscillator/[1]gain&quot;,0,0,1,0.01);
freq = vslider(&quot;h:Oscillator/[0]freq&quot;,440,50,1000,0.1);
</code></pre>
<p>the <code>freq</code> parameter will be placed before <code>gain</code> despite the fact that <code>gain</code> is declared first.</p>
<p>This system can be used to order groups as well. Ordering will be carried out on elements at the same level. For example:  </p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust116/exfaust116.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freqS = vslider("h:Oscillators/h:[0]Sawtooth/[0]freq",440,50,1000,0.1);
gainS = vslider("h:Oscillators/h:[0]Sawtooth/[1]gain",0,0,1,0.01);
freqT = vslider("h:Oscillators/h:[1]Triangle/[0]freq",440,50,1000,0.1);
gainT = vslider("h:Oscillators/h:[1]Triangle/[1]gain",0,0,1,0.01);
process = os.sawtooth(freqS)*gainS + os.triangle(freqT)*gainT;

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<p>Note that this could also be written as:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust117/exfaust117.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freqS = vslider("[0]freq",440,50,1000,0.1);
gainS = vslider("[1]gain",0,0,1,0.01);
freqT = vslider("[0]freq",440,50,1000,0.1);
gainT = vslider("[1]gain",0,0,1,0.01);
process = hgroup("Oscillators",
  hgroup("[0]Sawtooth",os.sawtooth(freqS)*gainS) + 
  hgroup("[1]Triangle",os.triangle(freqT)*gainT)
);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="global-ui-metadata">Global UI Metadata</h4>
<p>Note that global user interfaces completely replacing the one defined using the standard Faust UI primitives may be declared using <a href="#global-metadata">global metadata</a>. This is the case of the <a href="https://ccrma.stanford.edu/~rmichon/smartKeyboard/">SmartKeyboard</a> interface for example. </p>
<!-- TODO Link to metadata declaration section -->

<p>In the following subsections, the standard Faust UI metadata are documented. Other types of metadata (e.g., accelerometers, OSC, etc.) are documented in the sections related to these topics.</p>
<h4 id="styleknob-metadata"><code>[style:knob]</code> Metadata</h4>
<p>The <code>[style:knob]</code> metadata turns any continuous UI element (i.e., <a href="#hslider-metadata"><code>hslider</code></a>, <a href="#vslider-metadata"><code>vslider</code></a>, <a href="#nentry-metadata"><code>nentry</code></a>) into a knob.</p>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust118/exfaust118.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = vslider("freq[style:knob]",440,50,1000,0.1);
process = os.sawtooth(freq);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="stylemenu-metadata"><code>[style:menu]</code> Metadata</h4>
<p>The <code>[style:menu]</code> metadata turns any continuous UI element (i.e., <a href="#hslider-metadata"><code>hslider</code></a>, <a href="#vslider-metadata"><code>vslider</code></a>, <a href="#nentry-metadata"><code>nentry</code></a>) into a drop-down menu.</p>
<p><strong>Usage</strong></p>
<pre><code>[style:menu{'Name0':value0;'Name1':value1}]
</code></pre>
<p>Where:</p>
<ul>
<li><code>NameN</code>: the name associated to <code>valueN</code></li>
<li><code>valueN</code>: the value associated to <code>NameN</code></li>
</ul>
<p><strong>Example: Selector</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust119/exfaust119.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
s = vslider("Signal[style:menu{'Noise':0;'Sawtooth':1}]",0,0,1,1);
process = select2(s,no.noise,os.sawtooth(440));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="styleradio-metadata"><code>[style:radio]</code> Metadata</h4>
<p>The <code>[style:radio]</code> metadata turns a <a href="#hslider-metadata"><code>hslider</code></a> or a <a href="#vslider-metadata"><code>vslider</code></a> into a radio-button-menu. The orientation of the menu is determined by the type of UI element (i.e., <code>hslider</code> for horizontal and <code>vslider</code> for vertical).</p>
<p><strong>Usage</strong></p>
<pre><code>[style:radio{'Name0':value0;'Name1':value1}]
</code></pre>
<p>Where:</p>
<ul>
<li><code>NameN</code>: the name associated to <code>valueN</code></li>
<li><code>valueN</code>: the value associated to <code>NameN</code></li>
</ul>
<p><strong>Example: Selector</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust120/exfaust120.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
s = vslider("Signal[style:radio{'Noise':0;'Sawtooth':1}]",0,0,1,1);
process = select2(s,no.noise,os.sawtooth(440));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="styleled-metadata"><code>[style:led]</code> Metadata</h4>
<p>The <code>[style:led]</code> metadata turns a <a href="#vbargraph-metadata"><code>vbargraph</code></a> or a <a href="#hbargraph-metadata"><code>hbargraph</code></a> into a blinking LED (with varying intensity).</p>
<p><strong>Example: Level Display</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust121/exfaust121.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = _ <: attach(_,abs : ba.linear2db : vbargraph("Level[style:led]",-60,0));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="stylenumerical-metadata"><code>[style:numerical]</code> Metadata</h4>
<p>The <code>[style:numerical]</code> metadata turns a <a href="#vbargraph-metadata"><code>vbargraph</code></a> or a <a href="#hbargraph-metadata"><code>hbargraph</code></a> into a numerical zone (thus the bargraph itself is no more displayed).</p>
<p><strong>Example: Level Display</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust122/exfaust122.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = _ <: attach(_,abs : ba.linear2db : vbargraph("Level[style:numerical]",-60,0));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="unitdb-metadata"><code>[unit:dB]</code> Metadata</h4>
<p>The <code>[unit:dB]</code> metadata changes the unit of a <a href="#vbargraph-metadata"><code>vbargraph</code></a> or a <a href="#hbargraph-metadata"><code>hbargraph</code></a> to dB. This impacts its overall appearance by applying a rainbow color scheme, etc.</p>
<p><strong>Example: Level Display</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust123/exfaust123.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
process = _ <: attach(_,abs : ba.linear2db : vbargraph("Level[unit:dB]",-60,0));

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="unitxx-metadata"><code>[unit:xx]</code> Metadata</h4>
<p>The <code>[unit:xx]</code> metadata allows us to specify the unit of a UI element. The unit will be displayed right next to the current value of the parameter in the interface. </p>
<p><strong>Usage</strong></p>
<pre><code>[unit:xx]
</code></pre>
<p>Where:</p>
<ul>
<li><code>xx</code>: the unit of the current parameter</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust124/exfaust124.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = vslider("freq[unit:Hz]",440,50,1000,0.1);
process = os.sawtooth(freq);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="scalexx-metadata"><code>[scale:xx]</code> Metadata</h4>
<p>The <code>[scale:xx]</code> metadata allows for the specification of a scale (different than the default linear one) to the parameter in the UI. <code>[scale:log]</code> can be used to change to scale to logarithmic and <code>[scale:exp]</code> to exponential.</p>
<h4 id="tooltipxx-metadata"><code>[tooltip:xx]</code> Metadata</h4>
<p>The <code>[tooltip:xx]</code> metadata allows for the specification of a "tooltip" when the mouse hover a parameter in the interface. This is very convenient when implementing complex interfaces.   </p>
<p><strong>Usage</strong></p>
<pre><code>[tooltip:xx]
</code></pre>
<p>Where:</p>
<ul>
<li><code>xx</code>: a string to be used as a tooltip in the interface</li>
</ul>
<p><strong>Example</strong></p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust125/exfaust125.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");
freq = vslider("freq[tooltip:The frequency of the oscillator]",440,50,1000,0.1);
process = os.sawtooth(freq);

--></faust-editor>
<br>
</div>
<!-- /faust-run -->

<h4 id="hidden01-metadata"><code>[hidden:0|1]</code> Metadata</h4>
<p>The <code>[hidden:0|1]</code> metadata can be used to hide a parameter in the interface. This is convenient when controlling a parameter with a <a href="#sensors-control-metadatas">motion sensor</a> or <a href="../osc">OSC messages</a> and we don't want it to be visible in the interface. This feature is commonly used when making apps for Android and iOS using <code>faust2android</code> or <code>faust2ios</code>.</p>
<p><strong>Compatibility</strong></p>
<ul>
<li>iOS </li>
<li>Android</li>
</ul>
<h3 id="sensors-control-metadatas">Sensors Control Metadatas</h3>
<p>Sensors control metadata can be used to map the built-in sensors of mobile devices to some of the parameters of a Faust program.</p>
<p><strong>Compatibility</strong></p>
<p>These metadatas are compatible with the following Faust targets and no additional step is required for them to be taken into account when the corresponding application is generated:</p>
<ul>
<li><a href="https://faustdoc.grame.fr/manual/tools/"><code>faust2android</code></a></li>
<li><a href="https://faustdoc.grame.fr/manual/tools/"><code>faust2ios</code></a></li>
<li><a href="https://faustdoc.grame.fr/manual/tools/"><code>faust2smartkeyb</code></a></li>
</ul>
<p>Sensors control metadatas have five parameters and follow the following syntax:</p>
<pre><code>[acc: a b c d e] // for accelerometer
[gyr: a b c d e] // for gyroscope
</code></pre>
<p>They can be used in a Faust UI parameter declaration:</p>
<pre><code>parameter = nentry(&quot;UIparamName[acc: a b c d e]&quot;,def,min,max,step);
</code></pre>
<p>with:</p>
<ul>
<li><code>a</code>: the accelerometer axis (<strong>0</strong>: x, <strong>1</strong>: y, <strong>2</strong>: z)</li>
<li><code>b</code>: the accelerometer curve (see figure below)</li>
<li><code>c</code>: the minimum acceleration (m/s^2)</li>
<li><code>d</code>: the center acceleration (m/s^2)</li>
<li><code>e</code>: the maximum acceleration (m/s^2)</li>
<li><code>def</code>: the default/init value of the parameter</li>
<li><code>min</code>: the minimum value of the parameter</li>
<li><code>max</code>: the maximum value of the parameter</li>
<li><code>step</code>: the step of the parameter (precision)</li>
</ul>
<p>This allows for the implementation of complex linear and non-linear mappings that are summarized in this figure:</p>
<p><img src="img/accelMapping.jpg" class="mx-auto d-block" width="80%"></p>
<p>For example, controlling the gain of a synthesizer using the X axis of the accelerometer can be easily done simply by writing something like:</p>
<pre><code>g = nentry(&quot;gain[acc: 0 0 -10 0 10]&quot;,0.5,0,1,0.01);
</code></pre>
<p>With this configuration, <code>g = 0</code> when the device is standing vertically on its right side, <code>g = 0.5</code> when the device is standing horizontally with screen facing up, and <code>g = 1</code> when the device is standing vertically on its left side.</p>
<p>Finally, in this slightly more complex mapping, <code>g = 0</code> when the device is tilted on its right side and the value of <code>g</code> increases towards 1 when the device is tilted on its left side:</p>
<pre><code>g = nentry(&quot;gain[acc: 0 0 0 0 10]&quot;,0,0,1,0.01);
</code></pre>
<p>Complex nonlinear mappings can be implemented using this system.</p>
<h3 id="widget-modulation">Widget Modulation</h3>
<p><em>Widget modulation</em> acts on the widgets of an existing Faust expression, but without requiring any manual modifications of the expression's code. This operation is done directly by the compiler, according to a list of <em>target widgets</em> and associated <em>modulators</em>. Target widgets are specified by their label, as used in the graphical user interface. Modulators are Faust expressions that describe how to transform the signal produced by widgets. The syntax of a widget modulation is the following:</p>
<p><img src="img/widgetModulation.jpg" class="mx-auto d-block" width="60%"></p>
<p>Here is a very simple example, assuming freeverb is a fully fonctional reverb with a <code>"Wet"</code> slider:</p>
<pre><code>[&quot;Wet&quot; -&gt; freeverb]
</code></pre>
<p>The resulting circuit will have three inputs instead of two. The additional input is for the <code>"Wet"</code> widget. It acts on the values produced by the widget inside the freeverb expression. By default, the additional input signal, and the widget signal are multiplied together. In the following example, an external LFO is connected to this additional input:</p>
<pre><code>lfo(10, 0.5), _, _ : [&quot;Wet&quot; -&gt; freeverb]
</code></pre>
<h4 id="target-widgets">Target Widgets</h4>
<p>Target widgets are specified by their label. Of course, this presupposes knowing the names of the sliders. But as these names appear on the user interface, it's easy enough. If several widgets have the same name, adding the names of some (not necessarily all) of the surrounding groups, as in: <code>"h:group/h:subgroup/label"</code> can help distinguish them. </p>
<p>Multiple targets can be indicated in the same widget modulation expression as in: </p>
<pre><code>[&quot;Wet&quot;, &quot;Damp&quot;, &quot;RoomSize&quot; -&gt; freeverb]
</code></pre>
<h4 id="modulators">Modulators</h4>
<p>Modulators are Faust expressions, with exactly one output and at most two inputs that describe how to transform the signals produced by widgets. By default, when nothing is specified, the modulator is a multiplication. This is why our previous example is equivalent to:</p>
<pre><code>[&quot;Wet&quot;: * -&gt; freeverb]
</code></pre>
<p>Please note that the <code>':'</code> sign used here is just a visual separator, it is not the sequential composition operator. </p>
<p>To indicate that the modulation signal should be added, instead of multiplied, one could write:</p>
<pre><code>[&quot;Wet&quot;: + -&gt; freeverb]
</code></pre>
<p>Multiplications and addition are examples of  <code>2-&gt;1</code> modulators, but two other types are allowed: <code>0-&gt;1</code> and <code>1-&gt;1</code>. </p>
<h5 id="modulators-with-no-inputs">Modulators with no inputs</h5>
<p>Modulators with no inputs <code>0-&gt;1</code> completely replace the target widget (it won't appear anymore in the user interface). Let's say that we want to remove the <code>"Damp"</code> slider and replace it with the constant <code>0.5</code>, we can write:</p>
<pre><code>[&quot;Damp&quot;: 0.5 -&gt; freeverb]
</code></pre>
<h5 id="modulators-with-one-input">Modulators with one input</h5>
<p>A <code>1-&gt;1</code> modulator transforms the signal produced by the widget without the help of an external input. Our previous example could be written as:</p>
<pre><code>[&quot;Wet&quot;: *(lfo(10, 0.5)) -&gt; freeverb]
</code></pre>
<p>If <code>lfo</code> had its user interface, it would be added to the freeverb interface, at the same level as the <code>"Wet"</code> slider. </p>
<h5 id="modulators-with-two-inputs">Modulators with two inputs</h5>
<p>Modulators with two inputs, like <code>*</code> or <code>+</code>, are used to combine the signal produced by the target widget with an external signal. The first input is connected to the widget, the second one is connected to the external signal. As we have already seen, our example could be written as:</p>
<pre><code>lfo(10, 0.5), _, _ : [&quot;Wet&quot;: * -&gt; freeverb]
</code></pre>
<p>The main difference with the previous case is that if <code>lfo</code> had a user interface, it would be added outside of the freeverb interface. Please note that only <code>2-&gt;1</code> modulators result in additional inputs. </p>
<p>Here is a complete example:</p>
<!-- faust-run -->
<div class="faust-run"><img src="exfaust126/exfaust126.svg" class="mx-auto d-block">
<faust-editor><!--

import("stdfaust.lib");

process = ["Wet": *(lfo(0.5, 0.9)) -> dm.freeverb_demo]
with {
    lfo(f,g) = 1+os.osc(f)*g;
};

--></faust-editor>
<br>
</div>
<!-- /faust-run --></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2020-2024 <a href="https://www.grame.fr">Grame-CNCM</a></p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

        <script src="https://cdn.jsdelivr.net/npm/@grame/faust-web-component@0.2.25/dist/faust-web-component.js" defer></script>
    </body>
</html>
