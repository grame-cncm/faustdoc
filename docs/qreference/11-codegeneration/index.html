<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <title>11 codegeneration - Faust Documentation
    </title>
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="/css/quickref.css" rel="stylesheet">
    <link href="/css/github.min.css" rel="stylesheet">
    <link href="/rail/railroad-diagrams.css" rel="stylesheet">
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <script src="../../js/bootstrap.min.js" defer></script>
    <script src="../../js/MathJax-2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"defer></script>
    <script src="../../js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="../.."><img
                    src="../../img/faustText.svg" width="150px"> </a>
            <!-- Expander button -->
            <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                <span class="navbar-toggler-icon"></span>
            </button>

            <!-- Expanded navigation -->
            <div id="navbar-collapse" class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li class="navitem">
                        <a href="../.." class="nav-link">Home</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Manual <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../manual/introduction/" class="dropdown-item">Introduction</a>
</li>
                            
<li>
    <a href="../../manual/overview/" class="dropdown-item">Overview of the Faust Universe</a>
</li>
                            
<li>
    <a href="../../manual/quick-start/" class="dropdown-item">Quick Start</a>
</li>
                            
<li>
    <a href="../../manual/syntax/" class="dropdown-item">Faust Syntax</a>
</li>
                            
<li>
    <a href="../../manual/errors/" class="dropdown-item">Error Messages</a>
</li>
                            
<li>
    <a href="../../manual/compiler/" class="dropdown-item">Using the Compiler</a>
</li>
                            
<li>
    <a href="../../manual/options/" class="dropdown-item">Compiler Options</a>
</li>
                            
<li>
    <a href="../../manual/tools/" class="dropdown-item">faust2[...] Tools</a>
</li>
                            
<li>
    <a href="../../manual/architectures/" class="dropdown-item">Architecture Files</a>
</li>
                            
<li>
    <a href="../../manual/embedding/" class="dropdown-item">Embedding the Compiler</a>
</li>
                            
<li>
    <a href="../../manual/optimizing/" class="dropdown-item">Optimizing the Code</a>
</li>
                            
<li>
    <a href="../../manual/debugging/" class="dropdown-item">Debugging the Code</a>
</li>
                            
<li>
    <a href="../../manual/deploying/" class="dropdown-item">Deploying on the Web</a>
</li>
                            
<li>
    <a href="../../manual/remote/" class="dropdown-item">Remote Compilation</a>
</li>
                            
<li>
    <a href="../../manual/mathdoc/" class="dropdown-item">Mathematical Documentation</a>
</li>
                            
<li>
    <a href="../../manual/osc/" class="dropdown-item">OSC Support</a>
</li>
                            
<li>
    <a href="../../manual/http/" class="dropdown-item">HTTP Support</a>
</li>
                            
<li>
    <a href="../../manual/midi/" class="dropdown-item">MIDI Support</a>
</li>
                            
<li>
    <a href="../../manual/soundfiles/" class="dropdown-item">Soundfiles Support</a>
</li>
                            
<li>
    <a href="../../manual/community/" class="dropdown-item">Community</a>
</li>
                            
<li>
    <a href="../../manual/faq/" class="dropdown-item">Frequently Asked Questions</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Examples <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../examples/ambisonics/" class="dropdown-item"> ambisonics </a>
</li>
                            
<li>
    <a href="../../examples/analysis/" class="dropdown-item"> analysis </a>
</li>
                            
<li>
    <a href="../../examples/bela/" class="dropdown-item"> bela </a>
</li>
                            
<li>
    <a href="../../examples/delayEcho/" class="dropdown-item"> delayEcho </a>
</li>
                            
<li>
    <a href="../../examples/dynamic/" class="dropdown-item"> dynamic </a>
</li>
                            
<li>
    <a href="../../examples/filtering/" class="dropdown-item"> filtering </a>
</li>
                            
<li>
    <a href="../../examples/gameaudio/" class="dropdown-item"> gameaudio </a>
</li>
                            
<li>
    <a href="../../examples/generator/" class="dropdown-item"> generator </a>
</li>
                            
<li>
    <a href="../../examples/misc/" class="dropdown-item"> misc </a>
</li>
                            
<li>
    <a href="../../examples/phasing/" class="dropdown-item"> phasing </a>
</li>
                            
<li>
    <a href="../../examples/physicalModeling/" class="dropdown-item"> physicalModeling </a>
</li>
                            
<li>
    <a href="../../examples/pitchShifting/" class="dropdown-item"> pitchShifting </a>
</li>
                            
<li>
    <a href="../../examples/psychoacoustic/" class="dropdown-item"> psychoacoustic </a>
</li>
                            
<li>
    <a href="../../examples/reverb/" class="dropdown-item"> reverb </a>
</li>
                            
<li>
    <a href="../../examples/SAM/" class="dropdown-item"> SAM </a>
</li>
                            
<li>
    <a href="../../examples/smartKeyboard/" class="dropdown-item"> smartKeyboard </a>
</li>
                            
<li>
    <a href="../../examples/spat/" class="dropdown-item"> spat </a>
</li>
                            
<li>
    <a href="../../rsrc/examples.zip" class="dropdown-item"> Download examples </a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Tutorials <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item">Faust & JUCE</a>
</li>
                            
<li>
    <a href="../../tutorials/teensy/" class="dropdown-item">DSP on the Teensy With Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/esp32/" class="dropdown-item">DSP on the ESP-32 With Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/basic-osc/" class="dropdown-item">Making a Sine Oscillator From Scratch</a>
</li>
                            
<li>
    <a href="../../tutorials/summation/" class="dropdown-item">RMS and Summation in Faust</a>
</li>
                            
<li>
    <a href="../../tutorials/box-api/" class="dropdown-item">Using the box API</a>
</li>
                            
<li>
    <a href="../../tutorials/signal-api/" class="dropdown-item">Using the signal API</a>
</li>
                            
<li>
    <a href="../../tutorials/julia/" class="dropdown-item">Using Faust in Julia</a>
</li>
                            
<li>
    <a href="../../tutorials/cmajor/" class="dropdown-item">Using Faust in Cmajor</a>
</li>
                            
<li>
    <a href="../../tutorials/jsfx/" class="dropdown-item">Using Faust in JSFX</a>
</li>
                            
<li>
    <a href="../../tutorials/rnbo/" class="dropdown-item">Using Faust in RNBO with codebox~</a>
</li>
                            
<li>
    <a href="../../tutorials/debugging/" class="dropdown-item">Advanced debugging with interp-tracer</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Workshops <b
                                class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li>
    <a href="../../workshops/2018-12-01-paw/" class="dropdown-item"> 2018-12-01 PAW </a>
</li>
                            
<li>
    <a href="../../workshops/2020-03-24-faust-citi/" class="dropdown-item"> 2020-03-24 CITI </a>
</li>
                            
<li>
    <a href="../../workshops/2020-04-10-faust-101/" class="dropdown-item"> 2020-04-10 Faust 101 </a>
</li>
                            
<li>
    <a href="../../workshops/2020-04-10-faust-juce/" class="dropdown-item"> 2020-04-10 Faust & JUCE </a>
</li>
                            
<li>
    <a href="../../workshops/2020-11-21-faust-vcvrack/" class="dropdown-item"> 2020-11-21 Faust & VCV Rack </a>
</li>
                        </ul>
                    </li>
                    <li class="navitem">
                        <a href="../../about/" class="nav-link">About</a>
                    </li>
                </ul>

                <ul class="nav navbar-nav ml-auto">
                    <li class="nav-item">
                        <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fa fa-search"></i> Search
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    

    <div class="container">
        <div class="row"><div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#controlling-the-code-generation" class="nav-link">Controlling the code generation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#vector-code-generation" class="nav-link">Vector code generation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#parallel-code-generation" class="nav-link">Parallel code generation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#the-openmp-code-generator" class="nav-link">The OpenMP code generator</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#adding-openmp-directives" class="nav-link">Adding OpenMP directives</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#example-of-parallel-openmp-code" class="nav-link">Example of parallel OpenMP code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#the-scheduler-code-generator" class="nav-link">The scheduler code generator</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#example-of-parallel-scheduler-code" class="nav-link">Example of parallel scheduler code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
            <div class="col-md-9 main-container" role="main">

<script src='/rail/railroad-diagrams.js'></script>

<h1 id="controlling-the-code-generation">Controlling the code generation</h1>
<p><a name="codegeneration"></a></p>
<p>Several options of the <span class="smallcaps">Faust</span> compiler allow to control the generated C++ code. By default the computations are done sample by sample in a single loop. But the compiler can also generate <em>vector</em> and <em>parallel</em> code.</p>
<h2 id="vector-code-generation">Vector code generation</h2>
<p>Modern C++ compilers are able to do autovectorization, that is to use SIMD instructions to speedup the code. These instructions can typically operate in parallel on short vectors of 4 simple precision floating point numbers thus leading to a theoretical speedup of <script type="math/tex">\times4</script>. 
Autovectorization of C/C++ programs is a difficult task. Current compilers are very sensitive to the way the code is arranged. In particular too complex loops can prevent autovectorization. The goal of the vector code generation is to rearrange the C++ code in a way that facilitates the autovectorization job of the C++ compiler. Instead of generating a single sample computation loop, it splits the computation into several simpler loops that communicates by vectors.</p>
<p>The vector code generation is activated by passing the <span class="lstinline">--vectorize</span> (or <span class="lstinline">-vec</span>) option to the <span class="smallcaps">Faust</span> compiler. Two additional options are available:  <span class="lstinline">--vec-size <n></span> controls the size of the vector (by default 32 samples) and <span class="lstinline">--loop-variant 0/1</span> gives some additional control on the loops: <span class="lstinline">--loop-variant 0</span> generates fixed-size sub-loops with a final sub-loop that processes the last samples, <span class="lstinline">--loop-variant 1</span> generates sub-loops of variable vector size. </p>
<p>To illustrate the difference between scalar code and vector code, let's take the computation of the RMS (Root Mean Square) value of a signal.  Here is the <span class="smallcaps">Faust</span> code that computes the Root Mean Square of a sliding window of 1000 samples:
<a name="rms"></a></p>
<pre><code>// Root Mean Square of n consecutive samples
RMS(n) = square : mean(n) : sqrt;

// Square of a signal
square(x) = x * x;

// Mean of n consecutive samples of a signal
// (uses fixpoint to avoid the accumulation of
// rounding errors) 
mean(n) = float2fix : integrate(n) : 
          fix2float : /(n); 

// Sliding sum of n consecutive samples
integrate(n,x) = x - x@n : +~_;

// Convertion between float and fix point
float2fix(x) = int(x*(1&lt;&lt;20));      
fix2float(x) = float(x)/(1&lt;&lt;20);    

// Root Mean Square of 1000 consecutive samples
process = RMS(1000);
</code></pre>
<p>The compute() method generated in scalar mode is the following:</p>
<pre><code>virtual void compute (int count, 
                      float** input, 
                      float** output) 
{
  float* input0 = input[0];
  float* output0 = output[0];
  for (int i=0; i&lt;count; i++) {
    float fTemp0 = input0[i];
    int iTemp1 = int(1048576*fTemp0*fTemp0);
    iVec0[IOTA&amp;1023] = iTemp1;
    iRec0[0] = ((iVec0[IOTA&amp;1023] + iRec0[1])
                    - iVec0[(IOTA-1000)&amp;1023]);
    output0[i] = sqrtf(9.536744e-10f * 
                       float(iRec0[0]));
    // post processing
    iRec0[1] = iRec0[0];
    IOTA = IOTA+1;
  }
</code></pre>
<p>The <span class="lstinline">-vec</span> option leads to the following reorganization of the code:</p>
<pre><code>virtual void compute (int fullcount, 
                      float** input, 
                      float** output) 
{
  int iRec0_tmp[32+4];
  int* iRec0 = &amp;iRec0_tmp[4];
  for (int index=0; index&lt;fullcount; index+=32) 
  {
    int count = min (32, fullcount-index);
    float* input0 = &amp;input[0][index];
    float* output0 = &amp;output[0][index];
    for (int i=0; i&lt;4; i++) 
      iRec0_tmp[i]=iRec0_perm[i];
    // SECTION : 1
    for (int i=0; i&lt;count; i++) {
      iYec0[(iYec0_idx+i)&amp;2047] =
               int(1048576*input0[i]*input0[i]);
    }
    // SECTION : 2
    for (int i=0; i&lt;count; i++) {
      iRec0[i] = ((iYec0[i] + iRec0[i-1]) - 
               iYec0[(iYec0_idx+i-1000)&amp;2047]);
    }
    // SECTION : 3
    for (int i=0; i&lt;count; i++) {
      output0[i] = sqrtf((9.536744e-10f * 
                 float(iRec0[i])));
    }
    // SECTION : 4
    iYec0_idx = (iYec0_idx+count)&amp;2047;
    for (int i=0; i&lt;4; i++)
      iRec0_perm[i]=iRec0_tmp[count+i];
  }
</code></pre>
<p>While the second version of the code is more complex, it turns out to be much easier to vectorize efficiently by the C++ compiler. Using Intel icc 11.0, with the exact same compilation options: -O3 -xHost -ftz -fno-alias -fp-model fast=2, the scalar version leads to a throughput performance of 129.144  MB/s, while the vector version achieves 359.548  MB/s, a speedup of x2.8 ! </p>
<p><a name="fig:stack"></a>
<img alt="fig:stack" src="../images/compiler-stack.png" />
<span class='caption'><span class="smallcaps">Faust</span>'s stack of code generators</span></p>
<p>The vector code generation is built on top of the scalar code generation (see figure <a href="../11-codegeneration#fig:stack">fig:stack</a>). Every time an expression needs to be compiled, the compiler checks if it requires a separate loop or not. It applies some simple rules for that. Expressions that are shared (and are complex enough) are good candidates to be compiled in a separate loop, as well as recursive expressions and expressions used in delay lines. </p>
<p>The result is a directed graph in which each node is a computation loop (see Figure <a href="../11-codegeneration#fig:loopgraph">fig:loopgraph</a>). This graph is stored in the klass object and a topological sort is applied to it before printing the code. </p>
<p><a name="fig:loopgraph"></a>
<img alt="fig:loopgraph" src="../graphs/loopgraph2.png" />
<span class='caption'>The result of the -vec option is a directed acyclic graph (DAG) of small computation loops</span></p>
<h2 id="parallel-code-generation">Parallel code generation</h2>
<p>The parallel code generation is activated by passing either the <span class="lstinline">--openMP</span> (or <span class="lstinline">-omp</span>) option or the <span class="lstinline">--scheduler</span> (or <span class="lstinline">-sch</span>) option. It implies the <span class="lstinline">-vec</span> options as the parallel code generation is built on top of the vector code generation.  </p>
<h3 id="the-openmp-code-generator">The OpenMP code generator</h3>
<p><a name="fig:openmp"></a>
<img alt="fig:openmp" src="../images/openmp-model.png" />
<span class='caption'>OpenMP is based on a fork-join model</span></p>
<p>The <span class="lstinline">--openMP</span> (or <span class="lstinline">-omp</span>) option given to the <span class="smallcaps">Faust</span> compiler will insert appropriate OpenMP directives in the C++ code. OpenMP (http://wwww.openmp.org) is a well established API that is used to explicitly define direct multi-threaded, shared memory parallelism. It is based on a fork-join model of parallelism (see figure <a href="../11-codegeneration#fig:openmp">fig:openmp</a>). 
Parallel regions are delimited by <span class="lstinline">#pragma omp parallel</span> constructs. At the entrance of a parallel region a team of parallel threads is activated. The code within a parallel region is executed by each thread of the parallel team until the end of the region. </p>
<pre><code>#pragma omp parallel
{
  // the code here is executed simultaneously by 
  // every thread of the parallel team
  ...
</code></pre>
<p>In order not to have every thread doing redundantly the exact same work, OpemMP provides specific <em>work-sharing</em> directives. For example <span class="lstinline">#pragma omp sections</span> allows to break the work into separate, discrete sections, each section being executed by one thread:</p>
<pre><code>#pragma omp parallel
{
  #pragma omp sections
  {
    #pragma omp section
    {
      // job 1
    }
    #pragma omp section
    {
      // job 2
    }
    ...
  }

  ...
</code></pre>
<h3 id="adding-openmp-directives">Adding OpenMP directives</h3>
<p>As said before the parallel code generation is built on top of the vector code generation. The graph of loops produced by the vector code generator is topologically sorted in order to detect the loops that can be computed in parallel. The first set <script type="math/tex">S_0</script> (loops <script type="math/tex">L1</script>, <script type="math/tex">L2</script> and <script type="math/tex">L3</script> in the DAG of Figure <a href="../11-codegeneration#fig:loopgraph">fig:loopgraph</a>) contains the loops that don't depend on any other loops, the set <script type="math/tex">S_1</script> contains the loops that only depend on loops of <script type="math/tex">S_0</script>, (that is loops <script type="math/tex">L4</script> and <script type="math/tex">L5</script>), etc.. </p>
<p>As all the loops of a given set <script type="math/tex">S_n</script> can be computed in parallel, the compiler will generate a <span class="lstinline">sections</span> construct with a <span class="lstinline">section</span> for each loop. </p>
<pre><code>  #pragma omp sections
  {
    #pragma omp section
    for (...) {
      // Loop 1
    }
    #pragma omp section
    for (...) {
      // Loop 2
    }
    ...
  }
</code></pre>
<p>If a given set contains only one loop, then the compiler checks to see if the loop can be parallelized (no recursive dependencies) or not. If it can be parallelized, it generates:</p>
<pre><code>  #pragma omp for
  for (...) {
   // Loop code
  }
</code></pre>
<p>otherwise it generates a <span class="lstinline">single</span> construct so that only one thread will execute the loop:</p>
<pre><code>  #pragma omp single
  for (...) {
   // Loop code
  }
</code></pre>
<h3 id="example-of-parallel-openmp-code">Example of parallel OpenMP code</h3>
<p>To illustrate how <span class="smallcaps">Faust</span> uses the OpenMP directives, here is a very simple example, two 1-pole filters in parallel connected to an adder (see figure <a href="../11-codegeneration#fig:parfilter">fig:parfilter</a> the corresponding block-diagram):</p>
<pre><code>filter(c) = *(1-c) : + ~ *(c);
process = filter(0.9), filter(0.9) : +; 
</code></pre>
<p><a name="fig:parfilter"></a>
<img alt="fig:parfilter" src="../images/filter2.png" />
<span class='caption'>two filters in parallel connected to an adder</span></p>
<p>The corresponding compute() method obtained using the <span class="lstinline">-omp</span> option is the following:</p>
<pre><code>
virtual void compute (int fullcount, 
                      float** input, 
                      float** output) 
{
  float   fRec0_tmp[32+4];
  float   fRec1_tmp[32+4];
  float*  fRec0 = &amp;fRec0_tmp[4];
  float*  fRec1 = &amp;fRec1_tmp[4];
  #pragma omp parallel firstprivate(fRec0,fRec1)
  {
    for (int index = 0; index &lt; fullcount; 
                                index += 32) 
    {
      int count = min (32, fullcount-index);
      float* input0 = &amp;input[0][index];
      float* input1 = &amp;input[1][index];
      float* output0 = &amp;output[0][index];
      #pragma omp single
      {
        for (int i=0; i&lt;4; i++) 
          fRec0_tmp[i]=fRec0_perm[i];
        for (int i=0; i&lt;4; i++) 
          fRec1_tmp[i]=fRec1_perm[i];
      }
      // SECTION : 1
      #pragma omp sections
      {
        #pragma omp section
        for (int i=0; i&lt;count; i++) {
          fRec0[i] = ((0.1f * input1[i]) 
                   + (0.9f * fRec0[i-1]));
        }
        #pragma omp section
        for (int i=0; i&lt;count; i++) {
          fRec1[i] = ((0.1f * input0[i]) 
                   + (0.9f * fRec1[i-1]));
        }
      }
      // SECTION : 2
      #pragma omp for
      for (int i=0; i&lt;count; i++) {
        output0[i] = (fRec1[i] + fRec0[i]);
      }
      // SECTION : 3
      #pragma omp single
      {
        for (int i=0; i&lt;4; i++) 
          fRec0_perm[i]=fRec0_tmp[count+i];
        for (int i=0; i&lt;4; i++) 
          fRec1_perm[i]=fRec1_tmp[count+i];
      }
    }
  }

</code></pre>
<p>This code requires some comments:</p>
<ul>
<li>
<p>The parallel construct <span class="lstinline">#pragma omp parallel</span> is the fundamental construct that starts parallel execution. The number of parallel threads is generally the number of CPU cores but it can be controlled in several ways.</p>
</li>
<li>
<p>Variables external to the parallel region are shared by default. The pragma <span class="lstinline">firstprivate(fRec0,fRec1)</span> indicates that each thread should have its private copy of fRec0 and fRec1. The reason is that accessing shared variables requires an indirection and is quite inefficient compared to private copies.</p>
</li>
<li>
<p>The top level loop <span class="lstinline">for (int index = 0;...)...</span> is executed by all threads simultaneously. The subsequent work-sharing directives inside the loop will indicate how the work must be shared between the threads. </p>
</li>
<li>
<p>Please note that an implied barrier exists at the end of each work-sharing region. All threads must have executed the barrier before any of them can continue.</p>
</li>
<li>
<p>The work-sharing directive <span class="lstinline">#pragma omp single</span> indicates that this first section will be executed by only one thread (any of them).</p>
</li>
<li>
<p>The work-sharing directive <span class="lstinline">#pragma omp sections</span> indicates that each corresponding <span class="lstinline">#pragma omp section</span>, here our two filters, will be executed in parallel.</p>
</li>
<li>
<p>The loop construct <span class="lstinline">#pragma omp for</span> specifies that the iterations of the associated loop will be executed in parallel. The iterations of the loop are distributed across the parallel threads. For example, if we have two threads, the first one can compute indices between 0 and count/2 and the other one between count/2 and count. </p>
</li>
<li>
<p>Finally <span class="lstinline">#pragma omp single</span>  in section 3 indicates that this last section will be executed by only one thread (any of them).</p>
</li>
</ul>
<h3 id="the-scheduler-code-generator">The scheduler code generator</h3>
<p>With the <span class="lstinline">--scheduler</span> (or <span class="lstinline">-sch</span>) option given to the <span class="smallcaps">Faust</span> compiler, the computation graph is cut into separated computation loops (called "tasks"), and a "Work Stealing Scheduler" is used to activate and execute them following their dependencies. A pool of worked threads is created and each thread uses it's own local WSQ (Work Stealing Queue) of tasks. A WSQ is a special queue with a Push operation, a "private" LIFO Pop operation and a "public" FIFO Pop operation.</p>
<p>Starting from a ready task, each thread follows the dependencies, possibly pushing ready sub-tasks into it's own local WSQ. When no more tasks can be activated on a given computation path, the thread pops a task from it's local WSQ. If the WSQ is empty, then the thread is allowed to "steal" tasks from other threads WSQ.</p>
<p>The local LIFO Pop operation allows better cache locality and the FIFO steal Pop "larger chuck" of work to be done. The reason for this is that many work stealing workloads are divide-and-conquer in nature, stealing one of the oldest task implicitly also steals a (potentially) large subtree of computations that will unfold once that piece of work is stolen and run.</p>
<p>Compared to the OpenMP model (<span class="lstinline">-omp</span>) the new model is worse for simple <span class="smallcaps">Faust</span>  programs and usually starts to behave comparable or sometimes better for "complex enough" <span class="smallcaps">Faust</span>  programs. In any case, since OpenMP does not behave so well with GCC compilers (only quite recent versions like GCC 4.4 start to show some improvements), and is unusable on OSX in real-time contexts, this new scheduler option has it's own value.  We plan to improve it adding a "pipelining" idea in the future.</p>
<h3 id="example-of-parallel-scheduler-code">Example of parallel scheduler code</h3>
<p>To illustrate how <span class="smallcaps">Faust</span> generates the scheduler code, here is a very simple example, two 1-pole filters in parallel connected to an adder (see figure <a href="../11-codegeneration#fig:parfilter">fig:parfilter</a> the corresponding block-diagram):</p>
<pre><code>filter(c) = *(1-c) : + ~ *(c);
process = filter(0.9), filter(0.9) : +; 
</code></pre>
<p>When <span class="lstinline">-sch</span> option is used, the content of the additional <em>architecture/scheduler.h</em> file is inserted in the generated code. It contains code to deal with WSQ and thread management. The <span class="lstinline">compute()</span> and <span class="lstinline">computeThread()</span> methods are the following:</p>
<pre><code>
virtual void compute (int fullcount, 
                      float** input, 
                      float** output) 
{
    GetRealTime();
    this-&gt;input = input;
    this-&gt;output = output;
    StartMeasure();
    for (fIndex = 0; fIndex &lt; fullcount; fIndex += 32) {
        fFullCount = min (32, fullcount-fIndex);
        TaskQueue::Init();
        // Initialize end task
        fGraph.InitTask(1,1);
        // Only initialize tasks with inputs
        fGraph.InitTask(4,2);
        fIsFinished = false;
        fThreadPool.SignalAll(fDynamicNumThreads - 1);
        computeThread(0);
        while (!fThreadPool.IsFinished()) {}
    }
    StopMeasure(fStaticNumThreads, 
        fDynamicNumThreads);
void computeThread (int cur_thread) {
    float*  fRec0 = &amp;fRec0_tmp[4];
    float*  fRec1 = &amp;fRec1_tmp[4];
    // Init graph state
    {
        TaskQueue taskqueue;
        int tasknum = -1;
        int count = fFullCount;
        // Init input and output
        FAUSTFLOAT* input0 = &amp;input[0][fIndex];
        FAUSTFLOAT* input1 = &amp;input[1][fIndex];
        FAUSTFLOAT* output0 = &amp;output[0][fIndex];
        int task_list_size = 2;
        int task_list[2] = {2,3};
        taskqueue.InitTaskList(task_list_size, task_list, fDynamicNumThreads, cur_thread, tasknum);
        while (!fIsFinished) {
            switch (tasknum) {
                case WORK_STEALING_INDEX: { 
                    tasknum = TaskQueue::GetNextTask(cur_thread);
                    break;
                } 
                case LAST_TASK_INDEX: { 
                    fIsFinished = true;
                    break;
                } 
                // SECTION : 1
                case 2: { 
                    // LOOP 0x101111680
                    // pre processing
                    for (int i=0; i&lt;4; i++) fRec0_tmp[i]=fRec0_perm[i];
                    // exec code
                    for (int i=0; i&lt;count; i++) {
                        fRec0[i] = ((1.000000e-01f * (float)input1[i]) + (0.9f * fRec0[i-1]));
                    }
                    // post processing
                    for (int i=0; i&lt;4; i++) fRec0_perm[i]=fRec0_tmp[count+i];

                    fGraph.ActivateOneOutputTask(taskqueue, 4, tasknum);
                    break;
                } 
                case 3: { 
                    // LOOP 0x1011125e0
                    // pre processing
                    for (int i=0; i&lt;4; i++) fRec1_tmp[i]=fRec1_perm[i];
                    // exec code
                    for (int i=0; i&lt;count; i++) {
                        fRec1[i] = ((1.000000e-01f * (float)input0[i]) + (0.9f * fRec1[i-1]));
                    }
                    // post processing
                    for (int i=0; i&lt;4; i++) fRec1_perm[i]=fRec1_tmp[count+i];

                    fGraph.ActivateOneOutputTask(taskqueue, 4, tasknum);
                    break;
                } 
                case 4: { 
                    // LOOP 0x101111580
                    // exec code
                    for (int i=0; i&lt;count; i++) {
                        output0[i] = (FAUSTFLOAT)(fRec1[i] + fRec0[i]);
                    }

                    tasknum = LAST_TASK_INDEX;
                    break;
                } 
            }
        }
    }

</code></pre></div>
        </div>
    </div>

    <footer class="col-md-12">
        <hr>
        <p>Copyright &copy; 2020-2025 <a href="https://www.grame.fr">Grame-CNCM</a></p>
    </footer>
    <script>
        var base_url = "../..",
        shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
    </script>
    <script src="../../js/base.js" defer></script>
    <script src="/js/faust-web-component.js" defer></script>
    <script src="../../search/main.js" defer></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
