\chapter{\faust syntax}
\label{syntax}


This section describes the syntax of \faust. Figure \ref{fig-syntax} gives an overview of the various concepts and where they are defined in this section. 
%% suggestion Carlos: la figure cr√©e une confusion entre la structure de la syntaxe et la structure de la section. Faire un autre schema!
\begin{figure}[ht!]
\centering
\includegraphics[scale=0.45]{illustrations/syntax-chart}
\caption{Overview of \faust syntax}
\label{fig-syntax}
\end{figure}

As we will see, \textit{definitions} and \textit{expressions} have a central role.

\section{\faust program}

A \faust program is essentially a list of \textit{statements}. These statements can be \textit{declarations}, \textit{imports}, \textit{definitions} and \textit{documentation tags}, with optional C++ style (//... and /*...*/) comments.
 
\begin{rail}
program : (statement)+;
\end{rail}

\subsection{A Simple Program}

Here is a short \faust program that implements of a simple noise generator. It exhibits various kind of statements: two \textit{declarations}, an \textit{import}, a \textit{comment} and a \textit{definition}. We will see later on \textit{documentation} statements (\ref{sec-documentation}).

\begin{lstlisting}
declare name       "noise";
declare copyright  "(c)GRAME 2006";

import("music.lib");

// noise level controlled by a slider
process = noise * vslider("volume", 0, 0, 1, 0.1);
\end{lstlisting}
 
The keyword \lstinline'process' is the equivalent of \lstinline'main' in C/C++. Any \faust program, to be valid, must at least define \lstinline'process'.

\section{Statements}

The \textit{statements} of a \faust program are of four kinds: \textit{metadata declarations}, \textit{file imports},  \textit{definitions} and \textit{documentation}. All statements but documentation end with a semicolon (\lstinline';'). 
% 
% \begin{grammar}
%   <statement> ::= 
%   \begin{syntdiag}
%     \begin{stack}
%       <declaration>\\
%       <fileimport>\\
%       <definition>\\
%       <documentation>
%     \end{stack}
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
statement : declaration | fileimport | definition | documentation;
\end{rail}

\subsection{Declarations}

Meta-data declarations (for example \lstinline'declare name "noise";') are optional and typically used to document a \faust project. 

% \begin{grammar}
%   <declaration> ::= 
%   \begin{syntdiag}
%     "declare" <key> <string> ";"
%   \end{syntdiag}
% \end{grammar}
% 
% \begin{grammar}
%   <key> ::= 
%     <identifier>
% \end{grammar}

\begin{rail}
declaration : "declare" key string ';';
\end{rail}

\begin{rail}
key : identifier;
\end{rail}

Contrary to regular comments, these declarations will appear in the C++ code generated by the compiler. A good practice is to start a \faust program with some standard declarations:
\begin{lstlisting}
declare name "MyProgram";
declare author "MySelf";
declare copyright "MyCompany";
declare version "1.00";
declare license "BSD"; 
\end{lstlisting}

\subsection{Imports}

File imports allow to import definitions from other source files.  

% \begin{grammar}
%   <fileimport> ::= 
%   \begin{syntdiag}
%     "import"  "(" <filename> ")" ";"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
fileimport : "import" '(' filename ')' ';';
\end{rail}

For example \lstinline{import("maths.lib");} imports the definitions of the \lstinline{maths.lib} library, a set of additional mathematical functions provided as foreign functions.

\subsection{Documentation}
\label{sec-documentation}

Documentation statements are optional and typically used to control the generation of the mathematical documentation of a \faust program. This documentation system is detailed chapter \ref{mdoc}. In this section we will essentially describe the documentation statements syntax.

A documentation statement starts with an opening \lstinline'<mdoc>' tag and ends with a closing \lstinline'</mdoc>' tag. Free text content, typically in \latex format, can be placed in between these two tags. 

% \begin{grammar}
%   <documentation> ::= 
%   \begin{syntdiag}
%     "<mdoc>"     
%     \begin{stack}
%       <free text>\\
%       <equation>\\
%       <diagram>\\
%       <metadata>\\
%       <notice>\\
%       <listing>
%     \end{stack}
%     "</mdoc>"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
documentation : "<mdoc>" ((freetext|equation|diagram|metadata|notice|listing)+) "</mdoc>";
\end{rail}

Moreover, optional sub-tags can be inserted in the text content itself to require the generation, at the insertion point, of mathematical \textit{equations}, graphical \textit{block-diagrams}, \faust source code \textit{listing} and explanation \textit{notice}.

% \begin{grammar}
%   <equation> ::= 
%   \begin{syntdiag}
%     "<equation>" <expression> "</equation>"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
equation : "<equation>" expression "</equation>";
\end{rail}

The generation of the mathematical equations of a \faust expression can be requested by placing this expression between an opening \lstinline'<equation>' and a closing \lstinline'</equation>' tag. The expression is evaluated within the lexical context of the \faust program.

% \begin{grammar}
%   <diagram> ::= 
%   \begin{syntdiag}
%     "<diagram>" <expression> "</diagram>"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
diagram : "<diagram>" expression "</diagram>";
\end{rail}

Similarly, the generation of the graphical block-diagram of a \faust expression can be requested by placing this expression between an opening \lstinline'<diagram>' and a closing \lstinline'</diagram>' tag. The expression is evaluated within the lexical context of the \faust program.

% \begin{grammar}
%   <diagram> ::= 
%   \begin{syntdiag}
%     "<metadata>" <keyword> "</metadata>"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
metadata : "<metadata>" keyword "</metadata>";
\end{rail}

The \lstinline'<metadata>' tags allow to reference \faust metadatas (cf. declarations), calling the corresponding keyword.

% \begin{grammar}
%   <notice> ::= 
%   \begin{syntdiag}
%     "<notice />"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
notice : "<notice />";
\end{rail}

The \lstinline'<notice />' empty-element tag is used to generate the conventions used in the mathematical equations.
% 
% \begin{grammar}
%   <listing> ::= 
%   \begin{syntdiag}
%     "<listing " 
%     \begin{stack}
%       \\
%       \begin{rep}
%         <listingattribute>
%       \end{rep}
%     \end{stack}
%     " />"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
listing : "<listing" (listingattribute*) " />";
\end{rail}

\begin{rail}
listingattribute : ("mdoctags" | "dependencies" | "distributed") "=" ('"true"' | '"false"');
\end{rail}

% \begin{grammar}
%   <listingattribute> ::= 
%   \begin{syntdiag}
%     \begin{stack}
%       "mdoctags" \\
%       "dependencies" \\
%       "distributed"
%     \end{stack}
%     "=" "\""
%     \begin{stack}
%       "true" \\ "false"
%     \end{stack}
%     "\""
%   \end{syntdiag}
% \end{grammar}

The \lstinline'<listing />' empty-element tag is used to generate the listing of the \faust program. Its three attributes \lstinline'mdoctags', \lstinline'dependencies' and \lstinline'distributed' enable or disable respectively \lstinline'<mdoc>' tags, other files dependencies and distribution of interleaved faust code between \lstinline'<mdoc>' sections.

\section{Definitions}

A \textit{definition} associates an identifier with an expression it stands for. 

Definitions are essentially a convenient shortcut avoiding to type long expressions. During compilation, more precisely during the evaluation stage, identifiers are replaced by their definitions. It is therefore always equivalent to use an identifier or directly its definition. Please note that multiple definitions of a same identifier are not allowed, unless it is a pattern matching based definition.

\subsection{Simple Definitions}

The syntax of a simple definition is:

\begin{rail}
definition  : identifier '=' expression ';';
\end{rail} 

For example here is the definition of \lstinline'random', a simple pseudo-random number generator:

\begin{lstlisting}
 random = +(12345) ~ *(1103515245);
\end{lstlisting}

\subsection{Function Definitions}

Definitions with formal parameters correspond to functions definitions.

\begin{rail}
fdefinition  : identifier '(' (parameter + ',')  ')' '=' expression ';';
\end{rail} 

For example the definition of \lstinline'linear2db', a function that converts linear values to decibels, is :

\begin{lstlisting}
 linear2db(x) = 20*log10(x);
\end{lstlisting}
 
Please note that this notation is only a convenient alternative to the direct use of \textit{lambda-abstractions} (also called anonymous functions). The following is an equivalent definition of \lstinline'linear2db' using a lambda-abstraction:

\begin{lstlisting}
 linear2db = \(x).(20*log10(x));
\end{lstlisting}

\subsection{Definitions with pattern matching}

Moreover, formal parameters can also be full expressions representing patterns. 
\begin{rail}
pdefinition  : identifier '(' (pattern + ',')  ')' '=' expression ';';
\end{rail}

\begin{rail}
pattern : identifier | expression; 
\end{rail}

This powerful mechanism allows to algorithmically create and manipulate block diagrams expressions. Let's say that you want to describe a function to duplicate an expression several times in parallel:
\begin{lstlisting}
 duplicate(1,x) = x;
 duplicate(n,x) = x, duplicate(n-1,x);
\end{lstlisting}

Please note that this last definition is a convenient alternative to the more verbose :
\begin{lstlisting}
 duplicate = case { 
               (1,x) => x; 
               (n,x) => duplicate(n-1,x); 
             };
\end{lstlisting}

Here is another example to count the number of elements of a list. Please note that we simulate lists using parallel composition : (1,2,3,5,7,11). The main limitation of this approach is that there is no empty list. Moreover lists of only one element are represented by this element :
\begin{lstlisting}
 count((x,xs)) = 1+count(xs);
 count(x) = 1;
\end{lstlisting}

If we now write \lstinline'count(duplicate(10,666))' the expression will be evaluated to \lstinline'10'.

Please note that the order of pattern matching rules matters. The more specific rules must precede the more general rules. When this order is not respected, as in :
\begin{lstlisting}
 count(x) = 1;
 count((x,xs)) = 1+count(xs);
\end{lstlisting}
the first rule will always match and the second rule will never be called.

Please note that number arguments in pattern matching rules are typically \textit{constant numerical expressions}, so can be the result of more complex expressions involving computations done at compile-time.

\subsection{Variants}

Some statements (imports, definitions) can be preceded by a variantlist, composed of variants which can be \textit{singleprecision}, \textit{doubleprecision}, \textit{quadprecision} or \textit{fixedpointprecision} This allows some imports and definitions to be effective only for a (or several) specific float precision option in the compiler (that is either \lstinline'-single', \lstinline'-double', \lstinline'-quad' or \lstinline'-fx' respectively). A typical use-case is the definition of floating point constants in the maths.lib library with the following lines:

\begin{lstlisting}

singleprecision MAX = 3.402823466e+38;
doubleprecision MAX = 1.7976931348623158e+308;

\end{lstlisting}

\section{Expressions}

Despite its textual syntax, \faust is conceptually a block-diagram language. \faust expressions represent DSP block-diagrams and are assembled from primitive ones using various \textit{composition} operations. More traditional \textit{numerical} expressions in infix notation are also possible. Additionally \faust provides time based expressions, like delays, expressions related to lexical environments, expressions to interface with foreign function and lambda expressions.

\begin{rail}
expression : diagram | insouts | numerical | time | lexical | foreign | lambda;
\end{rail}

\subsection{Constant Numerical Expressions}

Some language primitives (like \textit{rdtable}, \textit{rwtable}, \textit{hslider} etc.) take constant numbers as some of their parameters. This is the case also for expressions using pattern matching techniques. Those numbers can be directly given in the code, but can also be computed by more complex expressions which have to produce numbers known at compile time. We will refer to them as \textit{constant numerical expressions} in the documentation.

\subsection{Diagram Expressions}

Diagram expressions are assembled from primitive ones using either binary composition operations or high level iterative constructions.
 
\begin{rail}
diagramexp : diagcomposition | diagiteration;
\end{rail}

\subsubsection{Diagram composition operations} 
Five binary \emph{composition operations} are available to combine block-diagrams: \textit{recursion}, \textit{parallel}, \textit{sequential}, \textit{split} and \textit{merge} composition. One can think of each of these composition operations as a particular way to connect two block diagrams. 

\begin{rail}
diagcomposition : expression (recur|','|':'|'<:'|':>') expression;
\end{rail}

To describe precisely how these connections are done, we have to introduce some notation.  The number of inputs and outputs of a bloc-diagram $A$ are notated $\mathrm{inputs}(A)$ and $\mathrm{outputs}(A)$ . The inputs and outputs themselves are respectively notated : $[0]A$, $[1]A$, $[2]A$, $\ldots$ and $A[0]$, $A[1]$, $A[2]$, etc.. 

For each composition operation between two block-diagrams $A$ and $B$ we will describe the connections $A[i]\rightarrow [j]B$ that are created and the constraints on their relative numbers of inputs and outputs.

The priority and associativity of this five operations are given table \ref{table-composition}. Please note that a higher priority value means a higher priority in the evaluation order. There is a companion table \ref{infix-comparison-priority} that gives the associativity of each numerical operator in infix expressions.
 
\begin{table}[ht]
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Syntax} & \textbf{Pri.}  & \textbf{Assoc.}  & \textbf{Description} \\
		\hline
		\texttt{\farg{expression}\ $\sim$\ \farg{expression}}		& 4 & left & recursive composition     \\
		\texttt{\farg{expression}\ ,\ \farg{expression}}			& 3 & right &  parallel composition      \\
		\texttt{\farg{expression}\ :\ \farg{expression}}			& 2 & right & sequential composition    \\
		\texttt{\farg{expression}\ <:\ \farg{expression}}			& 1 & right & split composition      	\\
		\texttt{\farg{expression}\ :>\ \farg{expression}}			& 1 & right & merge composition      	\\
		\hline
	\end{tabular}
	\caption{Block-Diagram composition operation priorities}   
  	\label{table-composition}
\end{table}
 

\paragraph{Parallel Composition}
The \emph{parallel composition}  \lstinline'(A,B)' (figure \ref{figure-par1}) is probably the simplest one. It places the two block-dia\-grams one on top of the other, without connections. The inputs of the resulting block-diagram are the inputs of \lstinline$A$ and \lstinline$B$. The outputs of the resulting block-diagram are the outputs of \lstinline$A$ and \lstinline$B$. 

\emph{Parallel composition} is an associative operation : \lstinline$(A,(B,C))$ and \lstinline$((A,B),C)$ are equivalents. When no parenthesis are used : \lstinline'A,B,C,D', \faust uses right associativity and therefore build internally the expression \lstinline$(A,(B,(C,D)))$. This organization is important to know when using pattern matching techniques on parallel compositions. 

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{images/par1}
\caption{Example of parallel composition  \lstinline'(10,*)'}
\label{figure-par1}
\end{figure}


\paragraph{Sequential Composition}
The \emph{sequential composition}  \lstinline$A:B$ (figure \ref{figure-seq1}) expects:
\begin{equation}
\mathrm{outputs}(A)=\mathrm{inputs}(B)
\end{equation}  
It connects each output of  $A$ to the corresponding input of $B$: 
\begin{equation}
A[i]\rightarrow[i]B
\end{equation}  

\begin{figure}[h]
\centering 
\includegraphics[scale=0.7]{images/seq1}
\caption{Example of sequential composition  \lstinline'((*,/):+)' } 
\label{figure-seq1}
\end{figure}

\emph{Sequential composition} is an associative operation : \lstinline$(A:(B:C))$ and \lstinline$((A:B):C)$ are equivalents. When no parenthesis are used, like in \lstinline$A:B:C:D$, \faust uses right associativity and therefore build internally the expression \lstinline$(A:(B:(C:D)))$.

\paragraph{Split Composition}
The \emph{split composition}  \lstinline$A<:B$ (figure \ref{figure-split1}) operator is used to distribute the outputs
of $A$ to the inputs of $B$.

\begin{figure}[h]
\centering 
\includegraphics[scale=0.7]{images/split1} 
\caption{example of split composition   \lstinline'((10,20) <: (+,*,/))'}  
\label{figure-split1}
\end{figure}

For the operation to be valid the number of inputs of $B$ must be a multiple of the number of outputs of $A$ : \begin{equation}
\mathrm{outputs}(A).k=\mathrm{inputs}(B)                                                                                                                                                         \end{equation}
Each input $i$ of $B$ is connected to the output $i \bmod k$ of $A$ : 
\begin{equation}
A[i \bmod k]\rightarrow\ [i]B                                                                                                                                                                                                                                                                                                                       \end{equation}


\paragraph{Merge Composition}
The \emph{merge composition}  \lstinline$A:>B$ (figure \ref{figure-merge1}) is the dual of the \emph{split composition}. The number of outputs of $A$ must be a multiple of the number of inputs of $B$ : 
\begin{equation}
\mathrm{outputs}(A)=k.\mathrm{inputs}(B)                                                                                                                                                                                                                                                  \end{equation}
Each output $i$ of $A$ is connected to the input $i \bmod k$ of $B$ : 
\begin{equation}
A[i]\rightarrow\ [i \bmod k]B                                                                                                   \end{equation} 
The $k$ incoming signals of an input of $B$ are summed together.

\begin{figure}[h]
\centering 
\includegraphics[scale=0.7]{images/merge1} 
\caption{example of merge composition \lstinline'((10,20,30,40) :> *)'}  
\label{figure-merge1}
\end{figure}


\paragraph{Recursive Composition}
The \emph{recursive composition} \lstinline'A~B' (figure \ref{figure-rec1}) is used to create cycles in the block-diagram in order to express recursive computations. It is the most complex operation in terms of connections.

To be applicable it requires that :
\begin{equation}
\mathrm{outputs}(A) \geq \mathrm{inputs}(B) and \mathrm{inputs}(A) \geq \mathrm{outputs}(B)                                                                                               \end{equation}
Each input of $B$ is connected to the corresponding output of $A$ via an implicit 1-sample delay : 
\begin{equation}
A[i]\stackrel{Z^{-1}}{\rightarrow}[i]B
\end{equation} 
and each output of $B$ is connected to the corresponding input of $A$:
\begin{equation}
B[i]\rightarrow [i]A
\end{equation} 

The inputs of the resulting block diagram are the remaining unconnected inputs of $A$. The outputs are all the outputs of $A$.
 
\begin{figure}[h]
\centering 
\includegraphics[scale=0.7]{images/rec1} 
\caption{example of recursive composition \lstinline'+(12345) ~ *(1103515245)'}  
\label{figure-rec1}
\end{figure}

\subsubsection{Inputs and outputs of an expression}
These two constructions can be used to know at compile time the number of inputs and outputs of any Faust expression. 

\begin{rail}
insouts: "inputs" '(' expression ')'
       | "outputs" '(' expression ')';
\end{rail}

They are useful to define high order functions and build algorithmically complex block-diagrams. Here is an example to automatically reverse the order of the outputs of an expression.

\begin{lstlisting}
Xo(expr) = expr <: par(i,n,selector(n-i-1,n)) 
		 with { n=outputs(expr); };
\end{lstlisting}

And the inputs of an expression :

\begin{lstlisting}
Xi(expr) = bus(n) <: par(i,n,selector(n-i-1,n)) : expr 
		 with { n=inputs(expr); };
\end{lstlisting}

For example \lstinline'Xi(-)' will reverse the order of the two inputs of the substraction.

%Let's see these composition operations in action with two simple examples (figure \ref{fig-integrator}). 

%The first example uses the recursive composition operator (\lstinline'~'). It is an integrator \lstinline'process = +~_;' that produces an output signal $Y$ such that $Y(t)=X(t)+Y(t-1)$.

%\begin{figure}[t]
%  \centering
%  \begin{tabular}{ccc}
%    \includegraphics[scale=0.7]{illustrations/integrator}&
%    \includegraphics[scale=0.7]{illustrations/ms}
%  \end{tabular}
%  \caption{a) integrator, b) mid/side stereo matrix}   
%  \label{fig-integrator}
%\end{figure}

%The second example uses the parallel (\lstinline',') and split (\lstinline'<:') composition operators. It implements a Mid/Side stereophonic matrix: \lstinline'process = _,_<:+,-;' that produces two output signals $Y_0$ and $Y_1$ such that $Y_0(t)=X_0(t)+X_1(t)$ and $Y_1(t)=X_0(t)-X_1(t)$


\subsubsection{Iterations} 
Iterations are analogous to \lstinline'for(...)' loops and provide a convenient way to automate some complex block-diagram constructions. 

% \begin{grammar}
%   <diagiteration> ::= 
%   \begin{syntdiag}
%     \begin{stack}
%        "par" "(" <ident> "," <numiter> "," <expression> ")"\\
%       "seq" "(" <ident> "," <numiter> "," <expression> ")"\\
%       "sum" "(" <ident> "," <numiter> "," <expression> ")"\\
%       "prod" "(" <ident> "," <numiter> "," <expression> ")"
%     \end{stack}
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
diagiteration: "par" '(' ident ',' numiter ',' expression ')'
           | "seq" '(' ident ',' numiter ',' expression ')'
           | "sum" '(' ident ',' numiter ',' expression ')'
           | "prod" '(' ident ',' numiter ',' expression ')';
\end{rail}

The following example shows the usage of  \lstinline'seq' to create a 10-bands filter:

\begin{lstlisting}
process  =	seq(i, 10, 
				vgroup("band %i", 
					bandfilter( 1000*(1+i) ) 
				) 
			);
\end{lstlisting}

\begin{rail}
numiter : expression;
\end{rail}
The number of iterations must be a constant expression. 

%--------------------------------------------------------------------------------------------------------------
\subsection{Infix Notation}
%--------------------------------------------------------------------------------------------------------------

\marginpar{Infix notation is commonly used in mathematics. It consists in placing the operand between the arguments as in $2+3$}Besides its algebra-based core syntax, Faust provides some syntax extensions, in particular the familiar \emph{infix notation}. For example if you want to multiply two numbers, let say \lstinline'2' and \lstinline'3', you can write directly \lstinline'2*3' instead of the equivalent core-syntax expression \lstinline'2,3:*'.

The \emph{infix notation} is not limited to numbers or numerical expressions. Arbitrary expressions \lstinline'A' and \lstinline'B' can be used, provided that \lstinline'A,B' has exactly two outputs. For example you can write \lstinline'_/2'. It is equivalent to \lstinline'_,2:/' which divides the incoming signal by \lstinline'2'. 

Examples of equivalences are given table \ref{tab-infixrules}.

\begin{table}[h]
	\begin{center}
	\begin{tabular}{|rcl|}
	\hline
	\lstinline'2-3' & $\equiv$ & \lstinline'2,3 : -'\\
	\lstinline'2*3' & $\equiv$ & \lstinline'2,3 : *'\\
	\lstinline'_@7' & $\equiv$ & \lstinline'_,7 : @'\\
	\lstinline'_/2' & $\equiv$ & \lstinline'_,2 : /'\\
	\lstinline'A<B' & $\equiv$ & \lstinline'A,B : <'\\
	\hline
	\end{tabular}
	\end{center}
	\caption{Infix and core syntax equivalences}
	\label{tab-infixrules}
\end{table}

In case of doubts on the meaning of an infix expression, for example \lstinline'_*_', it is useful to translate it to its core syntax equivalent, here \lstinline'_,_:*', which is equivalent to \lstinline'*'.
	
Built-in primitives that can be used in infix notation are called \emph{infix operators} and are listed in this section. Please note that a more detailed description of these operators is available section \ref{primitives}. 


\subsubsection{Comparison Operators}
%---------------------------------------------------------------------------------------

Comparison operators compare two signals and produce a signal that is 1 when the comparison is true and 0 when the comparison is false. 

\begin{rail}
	comparison : expression ('<'|'<='|'>'|'>='|'=='|'!=') expression;
\end{rail}

The priority and associativity of the comparison operators is given table \ref{infix-comparison-priority}.
	
\begin{table}[ht]
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Syntax} & \textbf{Pri.}  & \textbf{Assoc.}  & \textbf{Description}  \\
		\hline
		\texttt{\farg{expression}\ <\ \farg{expression}}	& 5 & left & less than               \\ 
		\texttt{\farg{expression}\ <=\ \farg{expression}}	& 5 & left & less or equal         \\ 
		\texttt{\farg{expression}\ !=\ \farg{expression}}	& 5 & left & different                 \\ 
		\texttt{\farg{expression}\ >=\ \farg{expression}}	& 5 & left & greater or equal     \\ 
		\texttt{\farg{expression}\ >\ \farg{expression}}	& 5 & left & greater than           \\ 
		\hline
	\end{tabular}
	\caption{Comparison operators priorities in infix expressions}   
  	\label{infix-comparison-priority}
\end{table}


\subsubsection{Math Operators}
%---------------------------------------------------------------------------------------

Math operators combine two signals and produce a resulting signal by applying a numerical operation on each sample. 

\begin{rail}
	math : expression ('+'|'-'|'*'|'/'|'\%'|hat) expression;
\end{rail}

The priority and associativity of the math operators is given table \ref{infix-math-priority}.


\begin{table}[ht]
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Syntax} & \textbf{Pri.}  & \textbf{Assoc.}  & \textbf{Description}  \\
		\hline
		\texttt{\farg{expression}\ +\ \farg{expression}}	& 6 & left & addition           \\
		\texttt{\farg{expression}\ -\ \farg{expression}}	& 6 & left & subtraction      \\
		\texttt{\farg{expression}\ *\ \farg{expression}}	& 7 & left & multiplication   \\
		\texttt{\farg{expression}\ /\ \farg{expression}}	& 7 & left & division            \\
		\texttt{\farg{expression}\ \%\ \farg{expression}}	& 7 & left & modulo            \\
		\texttt{\farg{expression}\ \^\ \farg{expression}}	& 8 & left & power              \\
		\hline
	\end{tabular}
	\caption{Math operators priorities in infix expressions}   
  	\label{infix-math-priority}
\end{table}


\subsubsection{Bitwise operators}
%---------------------------------------------------------------------------------------

Bitwise operators combine two signals and produce a resulting signal by applying a bitwise operation on each sample. 

\begin{rail}
	bitwise : expression (pipe|ampersand|'xor'|'<<' |'>>') expression;
\end{rail}

The priority and associativity of the bitwise operators is given table \ref{infix-bitwise-priority}.

\begin{table}[ht]
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Syntax} & \textbf{Pri.}  & \textbf{Assoc.}  & \textbf{Description}  \\
		\hline
		\texttt{\farg{expression}\ |\ \farg{expression}}	& 6 & left & bitwise or              \\
		\texttt{\farg{expression}\ \&\ \farg{expression}}	& 7 & left & bitwise and           \\
		\texttt{\farg{expression}\ xor\ \farg{expression}}	& 7 & left & bitwise xor             \\
		\texttt{\farg{expression}\ <<\ \farg{expression}}	& 7 & left & bitwise left shift      \\
		\texttt{\farg{expression}\ >>\ \farg{expression}}	& 7 & left & bitwise right shift    \\
		\hline
	\end{tabular}
	\caption{Bitwise operators priorities in infix expressions}   
  	\label{infix-bitwise-priority}
\end{table}



\subsubsection{Delay operators}
%---------------------------------------------------------------------------------------

Delay operators combine two signals and produce a resulting signal by applying a bitwise operation on each sample. 

\begin{rail}
	delay : expression arobase expression | expression kot;
\end{rail}

The delay operator \lstinline'@' allows to delay left handside expression by the amount defined by the right handside expression. The unary operator \lstinline"'" delays the left handside expression by one sample.  

The priority and associativity of the delay operators is given table \ref{infix-delay-priority}.

\begin{table}[ht]
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		\textbf{Syntax} & \textbf{Pri.}  & \textbf{Assoc.}  & \textbf{Description}  \\
		\hline
		\texttt{\farg{expression}\ @\ \farg{expression}}	& 9 & left & variable delay        \\
		\texttt{\farg{expression}} \'					& 10 & left & one-sample delay  \\
		\hline
	\end{tabular}
	\caption{Delay operators priorities in infix expressions}   
  	\label{infix-delay-priority}
\end{table}


%--------------------------------------------------------------------------------------------------------------
\subsection{Prefix Notation}
%---------------------------------------------------------------------------------------

Beside \emph{infix notation}, it is also possible to use \emph{prefix notation}. 
The \emph{prefix notation} is the usual mathematical notation for functions $f(x,y,z,\ldots)$, but extended to \emph{infix operators}. 
%
\begin{table}[h!]
	\begin{center}
	\begin{tabular}{|rcl|}
	\hline
	%\lstinline'-(2,3)' & $\equiv$ & \lstinline'2,3 : -'\\
	\lstinline'*(2,3)' & $\equiv$ & \lstinline'2,3 : *'\\
	\lstinline'@(_,7)' & $\equiv$ & \lstinline'_,7 : @'\\
	\lstinline'/(_,2)' & $\equiv$ & \lstinline'_,2 : /'\\
	\lstinline'<(A,B)' & $\equiv$ & \lstinline'A,B : <'\\
	\hline
	\end{tabular}
	\end{center}
	\caption{Prefix to core syntax translation rules}
	\label{tab-prefixrules}
\end{table}

It consists in first having the operator, for example \lstinline'/', followed by its arguments between parentheses: \lstinline'/(2,3)' (see table \ref{tab-prefixrules}). 

\subsubsection{Partial Application}
%---------------------------------------------------------------------------------------

The \emph{partial application} notation is a variant of \emph{prefix notation} in which not all arguments are given. For instance  \lstinline'/(2)' (divide by 2), \lstinline'^(3)'  (rise to the cube) and \lstinline'@(512)' (delay by 512 samples) are examples of partial applications where only one argument is given. The result of a partial application is a function that "waits" for the remaining arguments. 

When doing partial application with an \emph{infix operator}, it is important to note that the supplied argument is not the first argument, but always the second one, as summarized table \ref{tab-partialrules}. 


\begin{table}[h]
	\begin{center}
	\begin{tabular}{|rcl|}
	\hline
	\lstinline'+(C)' & $\equiv$ & \lstinline'_,C:*'\\
	\lstinline'-(C)' & $\equiv$ & \lstinline'_,C:-'\\
	\lstinline'<(C)' & $\equiv$ & \lstinline'_,C:<'\\
	\lstinline'/(C)' & $\equiv$ & \lstinline'_,C:/'\\
	\hline
	\end{tabular}
	\end{center}
	\caption{Partial application of infix operators}
	\label{tab-partialrules}
	
\end{table}

For commutative operations that doesn't matter. But for non-commutative ones, it is more ``natural'' to fix the second argument.  We use divide by 2 (\lstinline'/(2)') or rise to the cube (\lstinline'^(3)') more often than the other way around.

Please note that this rule only applies to infix operators, not other primitives or functions. If you partially apply a regular function to a single argument, it will correspond to the first parameter.

%--------------------------------------------------------------------------------------------------------------
\subsection{Time expressions}
%--------------------------------------------------------------------------------------------------------------

Time expressions are used to express delays. The notation \lstinline'X@10' represent the signal \lstinline'X' delayed by 10 samples. The notation \lstinline"X'" represent the signal X delayed by one sample and is therefore equivalent to \lstinline'X@1'.

\begin{rail}
time : expression arobase expression|expression kot; 
\end{rail}

The delay (automatically promoted to \textit{int}) don't have to be fixed, but it must be positive and bounded. The values of a slider are perfectly acceptable as in the following example:

\begin{lstlisting}
process = _ @ hslider("delay",0, 0, 100, 1);
\end{lstlisting}

\subsection{Environment expressions}
\faust is a lexically scoped language. The meaning of a \faust expression is determined by its context of definition (its lexical environment) and not by its context of use. 

To keep their original meaning, \faust expressions are bounded to their lexical environment in structures called \textit{closures}. The following constructions allow to explicitly create and access such environments. Moreover they provide powerful means to reuse existing code and promote modular design.

% \begin{grammar}
%   <envexp> ::= 
%   \begin{syntdiag}
%     \begin{stack}
%       <expression> "with" "\{"
%         \begin{rep}
%           <definition>
%         \end{rep}
%         "\}" \\ 
%       "environment" "\{"
%         \begin{rep}
%           <definition>
%         \end{rep}
%         "\}" \\ 
%       <expression> "." <ident> \\
%       "library" "(" <filename> ")" \\
%       "component" "(" <filename> ")" \\ 
%       <expression> "["
%         \begin{rep}
%           <definition>
%         \end{rep}
%         "]"
%     \end{stack}
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
envexp :    expression 'with' lbrace (definition+) rbrace
          | expression 'letrec' \\ lbrace (diffequation +) (() | 'where' (definition +)) rbrace
          | 'environment' lbrace (definition +) rbrace
		  | expression '.' ident
          | 'library' '(' filename ')'
          | 'component' '(' filename ')'
          | expression '[' (definition +) ']';         
\end{rail}

\subsubsection{With} 
The \lstinline'with' construction allows to specify a \textit{local environment}, a private list of definition that will be used to evaluate the left hand expression

% \begin{grammar}
%   <withexpression> ::= 
%   \begin{syntdiag}
%       <expression> "with" "\{"
%         \begin{rep}
%           <definition>
%         \end{rep}
%         "\}"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
withexpression : expression 'with' lbrace (definition +) rbrace;
\end{rail}


In the following example :
\begin{lstlisting}
pink = f : + ~ g with {
	f(x) = 0.04957526213389*x 
		 - 0.06305581334498*x' 
         + 0.01483220320740*x'';
	g(x) = 1.80116083982126*x 
		 - 0.80257737639225*x';
};
\end{lstlisting}
the definitions of \lstinline'f(x)' and \lstinline'g(x)' are local to \lstinline'f : + ~ g'.

Please note that \lstinline'with' is left associative and has the lowest priority:
\begin{itemize} 
\item[-] \lstinline'f : + ~ g with {...}' is equivalent to \lstinline'(f : + ~ g)  with {...}'. 
\item[-] \lstinline'f : + ~ g with {...} with {...}' is equivalent to \lstinline'((f : + ~ g)  with {...})  with {...}'. 
\end{itemize}

\subsubsection{Letrec} 
The \lstinline'letrec' construction is somehow similar to \lstinline'with', but for   \emph{difference equations} instead of regular definitions. It allows to easily express groups of mutually recursive signals, for example:
\begin{eqnarray*}
x(t)&=&y(t-1)+10;\\
y(t)&=&x(t-1)-1;
\end{eqnarray*}
as \lstinline|E letrec { 'x = y+10; 'y = x-1; }|	

The syntax is defined by the following rules:
\begin{rail}
	letrecexpression : expression 'letrec' \\ lbrace (diffequation +) (() | 'where' (definition +)) rbrace;
\end{rail}
\begin{rail}
	diffequation :    kot ident '=' expression ';';  
\end{rail}

Please remarks the special notation \lstinline|'x=y+10| instead of \lstinline|x=y'+10|. It makes syntactically impossible to write non-sensical equations like \lstinline|x=x+1|.

Here is a more involved example. Let say we want to define an envelop generator with an attack time, a release time and a gate signal. A possible definition is the following:

\begin{lstlisting}
ar(a,r,g) = v
  letrec {
    'n = (n+1) * (g<=g');
    'v = max(0, v + (n<a)/a - (n>=a)/r) * (g<=g');
  };
\end{lstlisting}
With the following semantics for $n(t)$ and $v(t)$:
\begin{eqnarray*}
	n(t)&=&(n(t-1)+1) * (g(t) <= g(t-1))\\
	v(t)&=& max(0, v(t-1) + (n(t-1)<a(t))/a(t) \\
						  &-& (n(t-1)>=a(t))/r(t)) * (g(t)<=g(t-1))
\end{eqnarray*}

In order to factor some expressions common to several recursive definitions, we can use the clause \lstinline'where' followed by one or more definitions. These definitions will only be visible to the recursive equations of the \lstinline'letrec', but not to the outside world, unlike the recursive definitions themselves.

For instance in the previous example we can factorize \lstinline'(g<=g)' leading to the following expression:

\begin{lstlisting}
	ar(a,r,g) = v
	  letrec {
		'n = (n+1) * c;
		'v = max(0, v + (n<a)/a - (n>=a)/r) * c;
		where
		 c = g<=g';
	  };
\end{lstlisting}

Please note that \lstinline'letrec' is essentially syntactic sugar.

Here is an example of 'letrec':

\begin{lstlisting}
	x,y  letrec {
		 x = defx;
		 y = defy;
		 z = defz;
		where
		 f = deff;
		 g = defg;
	  };
\end{lstlisting}

and its translation as done internally by the compiler:

\begin{lstlisting}
	x,y  with {
		 x = BODY : _,!,!;
		 y = BODY : !,_,!;
		 z = BODY : !,!,_;
		 BODY = \(x,y,z).((defx,defy,defz) with {f=deff; g=defg;}) ~ (_,_,_);
	  };
\end{lstlisting}




\subsubsection{Environment}

The \lstinline'environment' construction allows to create an explicit environment. It is like a \lstinline'with', but without the left hand expression. It is a convenient way to group together related definitions, to isolate groups of definitions and to create a name space hierarchy. 

% \begin{grammar}
%   <environment> ::= 
%   \begin{syntdiag}
%       "environment" "\{"
%         \begin{rep}
%           <definition>
%         \end{rep}
%         "\}"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
environment : 'environment' lbrace (definition +) rbrace; 
\end{rail}

In the following example an \lstinline'environment' construction is used to group together some constant definitions :

\begin{lstlisting}
constant = environment {
	pi = 3.14159;
	e = 2.718;
	...
};
\end{lstlisting}
The  \lstinline'.' construction allows to access the definitions of an environment (see next paragraph).

\subsubsection{Access} 
Definitions inside an environment can be accessed using 
the '.' construction. 

% \begin{grammar}
%   <access> ::= 
%   \begin{syntdiag}
%       <expression> "." <ident>
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
access :    expression '.' ident;       
\end{rail}

For example \lstinline'constant.pi' refers to the definition of \lstinline'pi' in the above \lstinline'constant' environment.

Please note that environment don't have to be named. We could have written directly 
\lstinline'environment{pi = 3.14159; e = 2.718; ... }.pi'

\subsubsection{Library} 
The \lstinline'library' construct allows to create an environment by reading the definitions from a file.

\begin{rail}
library :    'library' '(' filename ')';
\end{rail}

For example \lstinline'library("miscfilter.lib")' represents the environment 
obtained by reading the file "miscfilter.lib". It works like \lstinline'import("miscfilter.lib")' but all the read definitions are stored in a new separate lexical environment. Individual definitions can be accessed as described in the previous paragraph. For example \lstinline'library("miscfilter.lib").lowpass' denotes the function \lstinline'lowpass' as defined in the file \lstinline'"miscfilter.lib"'.

To avoid name conflicts when importing libraries it is recommended to prefer \lstinline'library' to \lstinline'import'. So instead of :

\begin{lstlisting}
import("miscfilter.lib");
  ...
...lowpass....
	...
};
\end{lstlisting}
the following will ensure an absence of conflicts : 
\begin{lstlisting}
fl = library("miscfilter.lib");
  ...
...fl.lowpass....
	...
};
\end{lstlisting}

\subsubsection{Component} 
The \lstinline'component(...)' construction allows to reuse a full \faust program as a simple expression.

\begin{rail}
component :    'component' '(' filename ')';
\end{rail}

 For example \lstinline'component("freeverb.dsp")' denotes the signal processor defined in file "freeverb.dsp". 
 
 Components can be used within expressions like in: 
 \begin{lstlisting}
 ...component("karplus32.dsp"):component("freeverb.dsp")... 
 \end{lstlisting}
 
 Please note that \lstinline'component("freeverb.dsp")' is equivalent to \lstinline'library("freeverb.dsp").process'.

\subsubsection{Explicit substitution} 

Explicit substitution can be used to customize a component or any expression with a lexical environment by replacing some of its internal definitions, without having to modify it.

% \begin{grammar}
%   <explicitsubst> ::= 
%   \begin{syntdiag}
%       <expression> "["
%         \begin{rep}
%           <definition>
%         \end{rep}
%         "]"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
explicitsubst : expression "[" (definition +) "]";
\end{rail}

For example we can create a customized version of \lstinline'component("freeverb.dsp")', with a different definition of \lstinline'foo(x)', by writing :
\begin{lstlisting}
...component("freeverb.dsp")[foo(x) = ...;]...
};
\end{lstlisting}

\subsection{Foreign expressions}

Reference to external (foreign) C \textit{functions}, \textit{variables} and \textit{constants} can be introduced using the \textit{foreign expressions} mechanism.
 
\begin{rail}
foreignexp : 'ffunction' '(' signature ',' includefile ',' library')' 
          | 'fvariable' '(' type identifier ',' includefile ')' 
          | 'fconstant' '(' type identifier ',' includefile ')' ;
\end{rail}

\subsubsection{Foreign function declaration} 

An external C function is declared by indicating its name and signature as well as the required include file.
The file \lstinline'"maths.lib"' of the \faust distribution contains several foreign function definitions, for example the inverse hyperbolic sine function \lstinline'asinh' is defined as follows

\begin{lstlisting}
	asinh = ffunction(float asinhf|asinh|asinhl|asinfx(float), <math.h>, "");
\end{lstlisting}


The signature part of a foreign function, \lstinline'float asinhf|asinh|asinhl|asinfx(float)' in our previous example, describes the prototype of the C function: its return type, function names and list of parameter types. Because the name of the foreign function can possibly depend on the floating point precision in use (float, double, quad and fixed-point), it is possible to give a different function name for each floating point precision using a signature with up to four function names. 

In our example, the \lstinline'asinh' function is called \lstinline'asinhf' in single precision, \lstinline'asinh' in double precision, \lstinline'asinhl' in quad precision, and \lstinline'asinhfx' in fixed-point precision. This is why the four names are provided in the signature.


\begin{rail}
signature : type funnames '(' (argtype + ',') ')';
\end{rail}

\begin{rail}
funnames : identifier (| '|' identifier) (| '|' identifier);
\end{rail}

Foreign functions generally expect a precise type: (\textit{int} or \textit{float}) for their parameters. Note that currently only numerical functions involving scalar parameters are allowed. No vectors, tables or data structures can be passed as parameters or returned. During the compilation if the type of an argument is not the same as the type of the parameter, it is automatically converted to the expected one.

Some foreign functions are polymorphic and can accept either \textit{int} or \textit{float} arguments. In this case, the polymorphism can be indicated by using the type \textit{any} instead or int or float. Here is as an example the C function \textit{sizeof} that returns the size of its argument:

\begin{lstlisting}
	sizeof = ffunction(int sizeof(any), "","");
\end{lstlisting}

\begin{rail}
	type : 'int'|'float';
\end{rail}

\begin{rail}
	argtype : 'int'|'float'|'any';
\end{rail}

Foreign functions with input parameters are considered pure math functions. They are therefore considered free of side effects and called only when their parameters change (that is at the rate of the fastest parameter). 

Exceptions are functions with no input parameters. A typical example is the C \lstinline'rand()' function. In this case the compiler generates code to call the function at sample rate.

\subsubsection{Foreign variables and constants} 
External variables and constants can also be declared with a similar syntax. In the same \lstinline'"maths.lib"' file, the definition of the sampling rate constant \lstinline'SR' and the definition of the block-size variable \lstinline'BS' can be found :

\begin{lstlisting}
SR    = min(192000.0, 
	      max(1.0, 
	    	fconstant(int fSamplingFreq, <math.h>)));
BS    = fvariable(int count, <math.h>);
\end{lstlisting}

Foreign constants are not supposed to vary. Therefore expressions involving only foreign constants are computed once, during the initialization period. 

Foreign variables are considered to vary at block speed. This means that expressions depending of external variables are computed every block.

\subsubsection{Include file}
In declaring foreign functions one has also to specify the include file. It allows the \faust compiler to add the corresponding \lstinline'#include...' in the generated code.

\begin{rail}
includefile : '<' (char +) '>' | '"' (char +) '"' ;
\end{rail}

\subsubsection{Library file}
In declaring foreign functions one can possibly specify the library where the actual code is located. It allows the \faust compiler to (possibly) automatically link the library. Note that this feature is only used with the LLVM backend in 'libfaust' dynamic library model.


\subsubsection{Availability of Foreign Functions, Variables, and Constants}

Foreign functions, variables, and constants can only be used in \faust when the target backend provides a mechanism to access their definitions and compiled code. In practice, this means:  

\begin{itemize}
  \item \textbf{C/C++ backends}: full support, since external symbols can be resolved at link time.
  \item \textbf{LLVM backend}: partial support, as external calls can be lowered to LLVM instructions, or using libraries compiled to LLVM bitcode and linked in the final binary, but with more restrictions.
  \item \textbf{Other backends (e.g., JavaScript, WebAssembly, etc.)}: foreign expressions are generally not supported, and any attempt to use them will cause compilation to fail.
\end{itemize}

This limitation arises because many backends operate in isolated or sandboxed environments, where external code or symbols cannot be safely linked. Developers should therefore ensure that their DSP code either avoids foreign expressions or is explicitly targeted to backends that support them.

%The syntax of these foreign declarations is the following :
%The foreign function mechanism allows to use external functions, variables and constants. External functions are limited to numerical ones. 
%  

%\begin{lstlisting}
%process = ffunction(float toto (), "foo.h", "commentaire");
%\end{lstlisting}


%ffunction are pure math unless no params
%difference between fconstant and fvariable

%\begin{lstlisting}
%SR 			= fconstant(int fSamplingFreq, <math.h>);
%BS          = fvariable(int count, <math.h>);
%\end{lstlisting}

%\begin{rail}
%includefile : '<' (char +) '>' | string;

%signature : type identifier '(' (type + ',') ')';

%type : 'int'|'float';
%\end{rail}

%that take simple numerical parameters and return a number.
%Foreign functions, variables and constants. Example of foreign function expression : \lstinline'ffunction (float acoshf (float), <math.h>, "")'.

\subsection{Applications and Abstractions}

\textit{Abstractions} and \textit{applications} are fundamental programming constructions directly inspired by the Lambda-Calculus. These constructions provide powerful ways to describe and transform block-diagrams algorithmically.

% \begin{grammar}
%   <progexp> ::= 
%   \begin{syntdiag}
%     \begin{stack}
%       <abstraction> \\ <application>
%     \end{stack}
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
progexp : abstraction|application;
\end{rail}   
 
\subsubsection{Abstractions}

Abstractions correspond to functions definitions and allow to generalize a block-diagram by \textit{making variable} some of its parts. 

% \begin{grammar}
%   <abstraction> ::= 
%   \begin{syntdiag}
%     \begin{stack}
%       <lambdaabstraction> \\ <patternabstraction>
%     \end{stack}
%   \end{syntdiag}
% \end{grammar}
% 
% \begin{grammar}
%   <lambdaabstraction> ::= 
%   \begin{syntdiag}
%     "\\" "(" 
%     \begin{rep}
%       <ident> \\ ","
%     \end{rep}
%     ")" "." "(" <expression> ")"
%   \end{syntdiag}
% \end{grammar}

\begin{rail}
abstraction : lambdaabstraction | patternabstraction; 
\end{rail}

\begin{rail}
lambdaabstraction :  backslash '(' (ident + ',') ')' '.' '(' expression ')';
\end{rail}

Let's say you want to transform a stereo reverb, \lstinline'freeverb' for instance, into a mono effect. You can write the following expression: 
\begin{lstlisting}
	_ <: freeverb :> _ 
\end{lstlisting}
The incoming mono signal is splitted to feed the two input channels of the reverb, while the two output channels of the reverb are mixed together to produce the resulting mono output.

Imagine now that you are interested in transforming other stereo effects. It can be interesting to generalize this principle by making \lstinline'freeverb' a variable: 
\begin{lstlisting}
	\(freeverb).(_ <: freeverb :> _)
\end{lstlisting}

The resulting abstraction can then be applied to transform other effects. Note that if \lstinline'freeverb' is a perfectly valid variable name, a more neutral name would probably be easier to read like:
\begin{lstlisting}
	\(fx).(_ <: fx :> _)
\end{lstlisting}
 
Moreover it could be convenient to give a name to this abstraction:
\begin{lstlisting}
	mono = \(fx).(_ <: fx :> _);
\end{lstlisting}

Or even use a more traditional, but equivalent, notation:
\begin{lstlisting}
	mono(fx) = _ <: fx :> _;
\end{lstlisting}

\subsubsection{Applications}
Applications correspond to function calls and allow to replace the variable parts of an abstraction with the specified arguments.

\begin{rail}
application : expression '(' (expression + ',') ')';
\end{rail}   

For example you can apply the previous abstraction to transform your stereo harmonizer:
\begin{lstlisting}
	mono(harmonizer)
\end{lstlisting}

The compiler will start by replacing \lstinline'mono' by its definition:
\begin{lstlisting}
	\(fx).(_ <: fx :> _)(harmonizer)
\end{lstlisting}

Whenever the \faust compiler find an application of an abstraction it replaces\marginpar{Replacing the \emph{variable part} with the argument is called $\beta$-reduction in Lambda-Calculus} the \emph{variable part} with the argument. The resulting expression is as expected:
\begin{lstlisting}
	(_ <: harmonizer :> _)
\end{lstlisting}

Note that the arguments given to the primitive or function in applications are reduced to their \emph{block normal form} (that is the flat equivalent block) before the actual application. Thus if the number of outputs of the argument block does not mach the needed number of arguments, the application will be treated as \emph{partial application} and the missing arguments will be replaced by one or several \lstinline'_' (to complete the number of missing arguments). 

\subsubsection{Unapplied abstractions}

Usually, lambda abstractions are supposed to be applied on arguments, using beta-reduction in Lambda-Calculus. Functional languages generally treat them as first-class values\footnote{\url{https://en.wikipedia.org/wiki/First-class_function}} which give these languages high-order programming capabilities. 

Another way of looking at abstractions in Faust is as a means of routing or placing blocks that are given as parameters. For example, the following abstraction \lstinline'repeat(fx) = fx : fx;' could be used to duplicate an effect and route input signals to be successively processed by that effect:

\begin{lstlisting}
	import("stdfaust.lib");
	repeat(fx) = fx : fx;
	process = repeat(dm.zita_light); 
\end{lstlisting}

In Faust, a proper semantic has been given to \textit{unapplied abstractions}: when a lambda-abstraction is not applied to parameters, it indicates \textit{how to route input signals}. This is a convenient way to work with signals by \textit{explicitly naming them}, to be used in the lambda abstraction body \textit{with their parameter name}. 

For instance a stereo crossing block written in the core syntax:

\begin{lstlisting}
	process = _,_ <: !,_,_,!; 
\end{lstlisting}

can be simply defined as:  

\begin{lstlisting}
	process = \(x,y).(y,x); 
\end{lstlisting}

which is actually equivalent to: 

\begin{lstlisting}
	process(x,y) = y,x; 
\end{lstlisting}


\subsubsection{Pattern Matching}
Pattern matching rules provide an effective way to analyze and transform block-diagrams algorithmically.
\begin{rail}
patternabstraction :  "case" lbrace (rule +) rbrace ;
\end{rail}

\begin{rail}
Rule : '(' (pattern + ',') ')' "=>" expression ';';
\end{rail}

\begin{rail}
Pattern : ident | expression;
\end{rail}


For example \lstinline'case{ (x:y) => y:x; (x) => x; }' contains two rules. The first one will match a sequential expression and invert the two part. The second one will match all remaining expressions and leave it untouched. Therefore the application:

\begin{lstlisting}
case{(x:y) => y:x; (x) => x;}(freeverb:harmonizer)
\end{lstlisting}

will produce:

\begin{lstlisting}
	(harmonizer:freeverb)
\end{lstlisting}

Please note that patterns are evaluated before the pattern matching operation. Therefore only variables that appear free in the pattern are binding variables during pattern matching. 

\subsection{Equivalent expressions}

When programming in Faust, you may reuse the same expression in multiple places within your code. If the compiler can prove that these expressions are used in identical contexts, it will automatically share the computation between the different occurrences. This is particularly useful for expressions involving User Interface (UI) widgets like buttons or sliders. In these cases, equivalence is determined by the widget‚Äôs pathname, which is constructed by concatenating the labels of all surrounding groups. If the pathnames are identical, the compiler will treat the expressions as equivalent, allowing the same control (e.g., a button or slider) to affect different parts of the program.

To share UI widgets deeply nested within the hierarchical structure, you may need to "move them up" in the hierarchy by adjusting their pathnames. This can be done using syntax like the following:

\begin{lstlisting}
	hslider("../volume",...)
\end{lstlisting}

By doing so, the widget's pathname is made syntactically equivalent across different parts of the program, enabling shared control.
